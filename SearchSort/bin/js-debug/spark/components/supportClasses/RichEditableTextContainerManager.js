/**
 * Generated by Apache Royale Compiler from spark/components/supportClasses/RichEditableTextContainerManager.as
 * spark.components.supportClasses.RichEditableTextContainerManager
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('spark.components.supportClasses.RichEditableTextContainerManager');
/* Royale Dependency List: mx.core.mx_internal,org.apache.royale.textLayout.edit.EditingMode,org.apache.royale.textLayout.edit.ElementRange,org.apache.royale.textLayout.edit.IEditManager,org.apache.royale.textLayout.edit.SelectionFormat,org.apache.royale.textLayout.edit.SelectionState,org.apache.royale.textLayout.elements.IConfiguration,org.apache.royale.textLayout.elements.TextFlow,org.apache.royale.textLayout.elements.TextRange,org.apache.royale.textLayout.events.SelectionEvent,org.apache.royale.textLayout.formats.ITextLayoutFormat,org.apache.royale.textLayout.operations.InsertTextOperation,spark.components.RichEditableText,org.apache.royale.utils.Language,XML*/

goog.require('org.apache.royale.textLayout.container.TextContainerManager');



/**
 *  Constructor. 
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @constructor
 * @extends {org.apache.royale.textLayout.container.TextContainerManager}
 * @param {spark.components.RichEditableText} container
 * @param {org.apache.royale.textLayout.elements.IConfiguration=} configuration
 */
spark.components.supportClasses.RichEditableTextContainerManager = function(container, configuration) {
  configuration = typeof configuration !== 'undefined' ? configuration : null;
  spark.components.supportClasses.RichEditableTextContainerManager.base(this, 'constructor', container, configuration);
  this.spark_components_supportClasses_RichEditableTextContainerManager_textDisplay = container;
};
goog.inherits(spark.components.supportClasses.RichEditableTextContainerManager, org.apache.royale.textLayout.container.TextContainerManager);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('spark.components.supportClasses.RichEditableTextContainerManager', spark.components.supportClasses.RichEditableTextContainerManager);


/**
 * @type {boolean}
 */
spark.components.supportClasses.RichEditableTextContainerManager.http_$$www_adobe_com$2006$flex$mx$internal__hideCursor = false;


/**
 * @private
 * @type {boolean}
 */
spark.components.supportClasses.RichEditableTextContainerManager.prototype.spark_components_supportClasses_RichEditableTextContainerManager_hasScrollRect = false;


/**
 * @private
 * @type {spark.components.RichEditableText}
 */
spark.components.supportClasses.RichEditableTextContainerManager.prototype.spark_components_supportClasses_RichEditableTextContainerManager_textDisplay;


/**
 *  @asprivate
 * @protected
 * @override
 */
spark.components.supportClasses.RichEditableTextContainerManager.prototype.getFocusedSelectionFormat = function() {
  var /** @type {*} */ selectionColor = this.spark_components_supportClasses_RichEditableTextContainerManager_textDisplay.getStyle("focusedTextSelectionColor");
  var /** @type {number} */ focusedPointAlpha = this.editingMode == org.apache.royale.textLayout.edit.EditingMode.READ_WRITE ? 1.0 : 0.0;
  return new org.apache.royale.textLayout.edit.SelectionFormat(selectionColor, 1.0, "normal", 0x000000, spark.components.supportClasses.RichEditableTextContainerManager.http_$$www_adobe_com$2006$flex$mx$internal__hideCursor ? 0 : focusedPointAlpha, "invert");
};


/**
 *  @asprivate
 * @protected
 * @override
 */
spark.components.supportClasses.RichEditableTextContainerManager.prototype.getUnfocusedSelectionFormat = function() {
  var /** @type {*} */ unfocusedSelectionColor = this.spark_components_supportClasses_RichEditableTextContainerManager_textDisplay.getStyle("unfocusedTextSelectionColor");
  var /** @type {number} */ unfocusedAlpha = this.spark_components_supportClasses_RichEditableTextContainerManager_textDisplay.selectionHighlighting != "whenFocused" ? 1.0 : 0.0;
  return new org.apache.royale.textLayout.edit.SelectionFormat(unfocusedSelectionColor, unfocusedAlpha, "normal", unfocusedSelectionColor, 0.0);
};


/**
 *  @asprivate
 * @protected
 * @override
 */
spark.components.supportClasses.RichEditableTextContainerManager.prototype.getInactiveSelectionFormat = function() {
  var /** @type {*} */ inactiveSelectionColor = this.spark_components_supportClasses_RichEditableTextContainerManager_textDisplay.getStyle("inactiveTextSelectionColor");
  var /** @type {number} */ inactivePointAlpha = 0.0;
  var /** @type {number} */ inactiveRangeAlpha = this.spark_components_supportClasses_RichEditableTextContainerManager_textDisplay.selectionHighlighting == "always" ? 1.0 : 0.0;
  var /** @type {number} */ pointBlinkRate = 0.0;
  return new org.apache.royale.textLayout.edit.SelectionFormat(inactiveSelectionColor, inactiveRangeAlpha, "normal", inactiveSelectionColor, inactivePointAlpha, "invert", pointBlinkRate);
};


/**
 *  @asprivate
 * @export
 * @override
 */
spark.components.supportClasses.RichEditableTextContainerManager.prototype.setText = function(text) {
  spark.components.supportClasses.RichEditableTextContainerManager.superClass_.setText.apply(this, [ text] );
};


/**
 *  @asprivate
 * @export
 * @override
 */
spark.components.supportClasses.RichEditableTextContainerManager.prototype.setTextFlow = function(textFlow) {
  spark.components.supportClasses.RichEditableTextContainerManager.superClass_.setTextFlow.apply(this, [ textFlow] );
};


/**
 *  @asprivate
 *  To get the format of a character.  Our API allows this operation even
 *  when the editingMode does not permit either interactive selection or
 *  editing.
 * @export
 * @param {number} anchorPosition
 * @param {number} activePosition
 * @return {org.apache.royale.textLayout.formats.ITextLayoutFormat}
 */
spark.components.supportClasses.RichEditableTextContainerManager.prototype.http_$$www_adobe_com$2006$flex$mx$internal__getCommonCharacterFormat = function(anchorPosition, activePosition) {
  if (anchorPosition == -1 || activePosition == -1)
    return null;
  var /** @type {org.apache.royale.textLayout.elements.TextFlow} */ textFlow = this.http_$$www_adobe_com$2006$flex$mx$internal__getTextFlowWithComposer();
  if (textFlow.interactionManager) {
    
/**
 * @const
 * @type {org.apache.royale.textLayout.elements.TextRange}
 */
var range = new org.apache.royale.textLayout.elements.TextRange(textFlow, anchorPosition, activePosition);
    return textFlow.interactionManager.getCommonCharacterFormat(range);
  } else {
    var /** @type {org.apache.royale.textLayout.edit.ElementRange} */ selRange = org.apache.royale.textLayout.edit.ElementRange.createElementRange(textFlow, anchorPosition, activePosition);
    return selRange.getCommonCharacterFormat();
  }
};


/**
 *  @asprivate
 *  Insert or append text to the textFlow without using an EditManager.
 *  If there is a SelectionManager or EditManager its selection will be
 *  updated at the end of the operation to keep it in sync.
 * @export
 * @param {string} insertText
 * @param {number} anchorPosition
 * @param {number} activePosition
 * @return {boolean}
 */
spark.components.supportClasses.RichEditableTextContainerManager.prototype.http_$$www_adobe_com$2006$flex$mx$internal__insertTextOperation = function(insertText, anchorPosition, activePosition) {
  if (anchorPosition == -1 || activePosition == -1)
    return false;
  var /** @type {org.apache.royale.textLayout.elements.TextFlow} */ textFlow = this.http_$$www_adobe_com$2006$flex$mx$internal__getTextFlowWithComposer();
  var /** @type {number} */ absoluteStart = this.spark_components_supportClasses_RichEditableTextContainerManager_getAbsoluteStart(anchorPosition, activePosition);
  var /** @type {number} */ absoluteEnd = this.spark_components_supportClasses_RichEditableTextContainerManager_getAbsoluteEnd(anchorPosition, activePosition);
  var /** @type {org.apache.royale.textLayout.formats.ITextLayoutFormat} */ pointFormat = this.http_$$www_adobe_com$2006$flex$mx$internal__getCommonCharacterFormat(absoluteStart, absoluteStart);
  var /** @type {org.apache.royale.textLayout.edit.SelectionState} */ operationState = new org.apache.royale.textLayout.edit.SelectionState(textFlow, absoluteStart, absoluteEnd, pointFormat);
  operationState.selectionManagerOperationState = true;
  var /** @type {org.apache.royale.textLayout.operations.InsertTextOperation} */ op = new org.apache.royale.textLayout.operations.InsertTextOperation(operationState, insertText);
  var /** @type {boolean} */ success = op.doOperation();
  if (success) {
    textFlow.normalize();
    textFlow.flowComposer.updateAllControllers();
    var /** @type {number} */ insertPt = (absoluteEnd - (absoluteEnd - absoluteStart) + +insertText.length) >> 0;
    var /** @type {org.apache.royale.textLayout.edit.SelectionState} */ selectionState = new org.apache.royale.textLayout.edit.SelectionState(textFlow, insertPt, insertPt);
    var /** @type {org.apache.royale.textLayout.events.SelectionEvent} */ selectionEvent = new org.apache.royale.textLayout.events.SelectionEvent(org.apache.royale.textLayout.events.SelectionEvent.SELECTION_CHANGE, false, false, selectionState);
    textFlow.dispatchEvent(selectionEvent);
    this.scrollToRange(insertPt, insertPt);
  }
  return success;
};


/**
 *  Note:  It is probably a TLF bug that, if delayedUpdates is true, we have to call 
 *  updateAllControllers before doing a format operation to guarantee the correct
 *  results.
 * @export
 * @return {org.apache.royale.textLayout.elements.TextFlow}
 */
spark.components.supportClasses.RichEditableTextContainerManager.prototype.http_$$www_adobe_com$2006$flex$mx$internal__getTextFlowWithComposer = function() {
  var /** @type {org.apache.royale.textLayout.elements.TextFlow} */ textFlow = org.apache.royale.utils.Language.as(this.getTextFlow(), org.apache.royale.textLayout.elements.TextFlow);
  if (this.composeState != org.apache.royale.textLayout.container.TextContainerManager.COMPOSE_COMPOSER) {
    this.convertToTextFlowWithComposer();
  } else if (textFlow.interactionManager) {
    
/**
 * @const
 * @type {org.apache.royale.textLayout.edit.IEditManager}
 */
var editManager = org.apache.royale.utils.Language.as(textFlow.interactionManager, org.apache.royale.textLayout.edit.IEditManager);
    if (editManager && editManager.delayUpdates)
      editManager.updateAllControllers();
    else
      textFlow.interactionManager.flushPendingOperations();
  }
  return textFlow;
};


/**
 *  @asprivate
 * @private
 * @param {number} anchorPosition
 * @param {number} activePosition
 * @return {number}
 */
spark.components.supportClasses.RichEditableTextContainerManager.prototype.spark_components_supportClasses_RichEditableTextContainerManager_getAbsoluteStart = function(anchorPosition, activePosition) {
  return (anchorPosition < activePosition) ? anchorPosition : activePosition;
};


/**
 *  @asprivate
 * @private
 * @param {number} anchorPosition
 * @param {number} activePosition
 * @return {number}
 */
spark.components.supportClasses.RichEditableTextContainerManager.prototype.spark_components_supportClasses_RichEditableTextContainerManager_getAbsoluteEnd = function(anchorPosition, activePosition) {
  return (anchorPosition > activePosition) ? anchorPosition : activePosition;
};


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
spark.components.supportClasses.RichEditableTextContainerManager.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'RichEditableTextContainerManager', qName: 'spark.components.supportClasses.RichEditableTextContainerManager', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
spark.components.supportClasses.RichEditableTextContainerManager.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        '|http://www.adobe.com/2006/flex/mx/internal::hideCursor': { type: 'Boolean', get_set: function (/** * */ v) {return v !== undefined ? spark.components.supportClasses.RichEditableTextContainerManager.http_$$www_adobe_com$2006$flex$mx$internal__hideCursor = v : spark.components.supportClasses.RichEditableTextContainerManager.http_$$www_adobe_com$2006$flex$mx$internal__hideCursor;}}
      };
    },
    methods: function () {
      return {
        'RichEditableTextContainerManager': { type: '', declaredBy: 'spark.components.supportClasses.RichEditableTextContainerManager', parameters: function () { return [ 'spark.components.RichEditableText', false ,'org.apache.royale.textLayout.elements.IConfiguration', true ]; }},
        'setText': { type: 'void', declaredBy: 'spark.components.supportClasses.RichEditableTextContainerManager', parameters: function () { return [ 'String', false ]; }},
        'setTextFlow': { type: 'void', declaredBy: 'spark.components.supportClasses.RichEditableTextContainerManager', parameters: function () { return [ 'org.apache.royale.textLayout.elements.TextFlow', false ]; }},
        'http://www.adobe.com/2006/flex/mx/internal::getCommonCharacterFormat': { type: 'org.apache.royale.textLayout.formats.ITextLayoutFormat', declaredBy: 'spark.components.supportClasses.RichEditableTextContainerManager', parameters: function () { return [ 'int', false ,'int', false ]; }},
        'http://www.adobe.com/2006/flex/mx/internal::insertTextOperation': { type: 'Boolean', declaredBy: 'spark.components.supportClasses.RichEditableTextContainerManager', parameters: function () { return [ 'String', false ,'int', false ,'int', false ]; }},
        'http://www.adobe.com/2006/flex/mx/internal::getTextFlowWithComposer': { type: 'org.apache.royale.textLayout.elements.TextFlow', declaredBy: 'spark.components.supportClasses.RichEditableTextContainerManager'}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
spark.components.supportClasses.RichEditableTextContainerManager.prototype.ROYALE_COMPILE_FLAGS = 10;

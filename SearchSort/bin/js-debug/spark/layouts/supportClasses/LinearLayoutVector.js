/**
 * Generated by Apache Royale Compiler from spark/layouts/supportClasses/LinearLayoutVector.as
 * spark.layouts.supportClasses.LinearLayoutVector
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('spark.layouts.supportClasses.LinearLayoutVector');
/* Royale Dependency List: mx.core.ILayoutElement,org.apache.royale.geom.Rectangle,spark.layouts.supportClasses.Block,org.apache.royale.utils.Language,XML*/




/**
 * @constructor
 * @param {number=} majorAxis
 */
spark.layouts.supportClasses.LinearLayoutVector = function(majorAxis) {
  majorAxis = typeof majorAxis !== 'undefined' ? majorAxis : spark.layouts.supportClasses.LinearLayoutVector.VERTICAL;
  
  this.spark_layouts_supportClasses_LinearLayoutVector_blockTable = new (org.apache.royale.utils.Language.synthVector('spark.layouts.supportClasses.Block'))(0, false);
  this.spark_layouts_supportClasses_LinearLayoutVector__majorAxis = spark.layouts.supportClasses.LinearLayoutVector.VERTICAL;
  ;
  this.majorAxis = majorAxis;
};


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('spark.layouts.supportClasses.LinearLayoutVector', spark.layouts.supportClasses.LinearLayoutVector);


/**
 * @export
 * @nocollapse
 * @const
 * @type {number}
 */
spark.layouts.supportClasses.LinearLayoutVector.VERTICAL = 0;


/**
 * @export
 * @nocollapse
 * @const
 * @type {number}
 */
spark.layouts.supportClasses.LinearLayoutVector.HORIZONTAL = 1;


/**
 * @const
 * @type {number}
 */
spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SIZE = 128;


/**
 * @const
 * @type {number}
 */
spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SHIFT = 7;


/**
 * @const
 * @type {number}
 */
spark.layouts.supportClasses.LinearLayoutVector.BLOCK_MASK = 0x7f;


/**
 * @private
 * @const
 * @type {Array.<spark.layouts.supportClasses.Block>}
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.spark_layouts_supportClasses_LinearLayoutVector_blockTable;


/**
 * @private
 * @type {Array.<number>}
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.spark_layouts_supportClasses_LinearLayoutVector_pendingRemoves = null;


/**
 * @private
 * @type {Array.<number>}
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.spark_layouts_supportClasses_LinearLayoutVector_pendingInserts = null;


/**
 * @private
 * @type {number}
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.spark_layouts_supportClasses_LinearLayoutVector_pendingLength = -1;


/**
 * @private
 * @type {number}
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.spark_layouts_supportClasses_LinearLayoutVector__length = 0;


/**
 *  @asprivate
 *  Grows or truncates the vector to be the specified newLength.
 *  When truncating, releases empty blocks and sets to NaN any values 
 *  in the last block beyond the newLength.
 * @private
 * @param {number} newLength
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.spark_layouts_supportClasses_LinearLayoutVector_setLength = function(newLength) {
  if (newLength < this.spark_layouts_supportClasses_LinearLayoutVector__length) {
    var /** @type {number} */ blockIndex = (newLength >> spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SHIFT) >>> 0;
    var /** @type {number} */ endIndex = (Math.min(blockIndex * spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SIZE + spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SIZE, this.spark_layouts_supportClasses_LinearLayoutVector__length) - 1) >> 0;
    this.spark_layouts_supportClasses_LinearLayoutVector_clearInterval((newLength) >> 0, endIndex);
  }
  this.spark_layouts_supportClasses_LinearLayoutVector__length = newLength;
  var /** @type {number} */ partialBlock = (((this.spark_layouts_supportClasses_LinearLayoutVector__length & spark.layouts.supportClasses.LinearLayoutVector.BLOCK_MASK) == 0) ? 0 : 1) >>> 0;
  this.spark_layouts_supportClasses_LinearLayoutVector_blockTable[org.apache.royale.utils.Language.SYNTH_TAG_FIELD].length = ((this.spark_layouts_supportClasses_LinearLayoutVector__length >> spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SHIFT) + partialBlock) >>> 0;
};


/**
 * @private
 * @type {number}
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.spark_layouts_supportClasses_LinearLayoutVector__defaultMajorSize = 0;


/**
 * @private
 * @type {number}
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.spark_layouts_supportClasses_LinearLayoutVector__defaultMinorSize = 0;


/**
 * @private
 * @type {number}
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.spark_layouts_supportClasses_LinearLayoutVector__minorSize = 0;


/**
 * @private
 * @type {number}
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.spark_layouts_supportClasses_LinearLayoutVector__minMinorSize = 0;


/**
 * @private
 * @type {number}
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.spark_layouts_supportClasses_LinearLayoutVector__majorAxis;


/**
 * @private
 * @type {number}
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.spark_layouts_supportClasses_LinearLayoutVector__majorAxisOffset = 0;


/**
 * @private
 * @type {number}
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.spark_layouts_supportClasses_LinearLayoutVector__gap = 6;


/**
 *  Return the size of the item at index.  If no size was ever
 *  specified then then the defaultMajorSize is returned.
 * 
 *  @asparam index The item's index.
 *  @see defaultMajorSize
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 * @param {number} index
 * @return {number}
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.getMajorSize = function(index) {
  this.spark_layouts_supportClasses_LinearLayoutVector_flushPendingChanges();
  var /** @type {spark.layouts.supportClasses.Block} */ block = this.spark_layouts_supportClasses_LinearLayoutVector_blockTable[index >> spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SHIFT];
  if (block) {
    var /** @type {number} */ value = block.sizes[index & spark.layouts.supportClasses.LinearLayoutVector.BLOCK_MASK];
    return isNaN(value) ? this.spark_layouts_supportClasses_LinearLayoutVector__defaultMajorSize : value;
  }
  else
    return this.spark_layouts_supportClasses_LinearLayoutVector__defaultMajorSize;
};


/**
 *  Set the size of the item at index.   If an index is 
 *  set to <code>NaN</code> then subsequent calls to get
 *  will return the defaultMajorSize.
 * 
 *  @asparam index The item's index.
 *  @asparam value The item's size.
 *  @see defaultMajorSize
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 * @param {number} index
 * @param {number} value
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.setMajorSize = function(index, value) {
  this.spark_layouts_supportClasses_LinearLayoutVector_flushPendingChanges();
  if (index >= this.length)
    throw new Error("invalidIndex");
  var /** @type {number} */ blockIndex = (index >> spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SHIFT) >>> 0;
  var /** @type {spark.layouts.supportClasses.Block} */ block = this.spark_layouts_supportClasses_LinearLayoutVector_blockTable[blockIndex];
  if (!block)
    block = this.spark_layouts_supportClasses_LinearLayoutVector_blockTable[blockIndex] = new spark.layouts.supportClasses.Block();
  var /** @type {number} */ sizesIndex = (index & spark.layouts.supportClasses.LinearLayoutVector.BLOCK_MASK) >>> 0;
  var /** @type {Array.<number>} */ sizes = block.sizes;
  var /** @type {number} */ oldValue = sizes[sizesIndex];
  if (oldValue == value)
    return;
  if (isNaN(oldValue)) {
    block.defaultCount -= 1;
    block.sizesSum += value;
  } else if (isNaN(value)) {
    block.defaultCount += 1;
    block.sizesSum -= oldValue;
  }
  else
    block.sizesSum += value - oldValue;
  block.sizes[sizesIndex] = value;
};


/**
 *  Make room for a new item at index by shifting all of the sizes 
 *  one position to the right, beginning with startIndex.  
 * 
 *  The value at index will be NaN. 
 * 
 *  This is similar to array.splice(index, 0, NaN).
 * 
 *  @asparam index The position of the new NaN size item.
 * @export
 * @param {number} index
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.insert = function(index) {
  if (this.spark_layouts_supportClasses_LinearLayoutVector_pendingRemoves)
    this.spark_layouts_supportClasses_LinearLayoutVector_flushPendingChanges();
  if (this.spark_layouts_supportClasses_LinearLayoutVector_pendingInserts) {
    var /** @type {number} */ lastIndex = (this.spark_layouts_supportClasses_LinearLayoutVector_pendingInserts.length - 1) >> 0;
    var /** @type {number} */ intervalEnd = this.spark_layouts_supportClasses_LinearLayoutVector_pendingInserts[lastIndex];
    if (index == intervalEnd + 1) {
      this.spark_layouts_supportClasses_LinearLayoutVector_pendingInserts[lastIndex] = (index) >> 0;
    } else if (index > intervalEnd) {
      this.spark_layouts_supportClasses_LinearLayoutVector_pendingInserts.push(index);
      this.spark_layouts_supportClasses_LinearLayoutVector_pendingInserts.push(index);
    } else {
      this.spark_layouts_supportClasses_LinearLayoutVector_flushPendingChanges();
    }
  }
  this.spark_layouts_supportClasses_LinearLayoutVector_pendingLength = (Math.max(this.length + 1, index + 1)) >> 0;
  if (!this.spark_layouts_supportClasses_LinearLayoutVector_pendingInserts) {
    this.spark_layouts_supportClasses_LinearLayoutVector_pendingInserts = new (org.apache.royale.utils.Language.synthVector('int'))();
    this.spark_layouts_supportClasses_LinearLayoutVector_pendingInserts.push(index);
    this.spark_layouts_supportClasses_LinearLayoutVector_pendingInserts.push(index);
  }
};


/**
 *  Remove index by shifting all of the sizes one position to the left, 
 *  begining with index+1.  
 * 
 *  This is similar to array.splice(index, 1).
 * 
 *  @asparam index The position to be removed.
 * @export
 * @param {number} index
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.remove = function(index) {
  if (this.spark_layouts_supportClasses_LinearLayoutVector_pendingInserts)
    this.spark_layouts_supportClasses_LinearLayoutVector_flushPendingChanges();
  if (index >= this.length)
    throw new Error("invalidIndex");
  if (this.spark_layouts_supportClasses_LinearLayoutVector_pendingRemoves) {
    var /** @type {number} */ lastIndex = (this.spark_layouts_supportClasses_LinearLayoutVector_pendingRemoves.length - 1) >> 0;
    var /** @type {number} */ intervalStart = this.spark_layouts_supportClasses_LinearLayoutVector_pendingRemoves[lastIndex];
    if (index == intervalStart - 1) {
      this.spark_layouts_supportClasses_LinearLayoutVector_pendingRemoves[lastIndex] = (index) >> 0;
    } else if (index < intervalStart) {
      this.spark_layouts_supportClasses_LinearLayoutVector_pendingRemoves.push(index);
      this.spark_layouts_supportClasses_LinearLayoutVector_pendingRemoves.push(index);
    } else {
      this.spark_layouts_supportClasses_LinearLayoutVector_flushPendingChanges();
    }
  }
  this.spark_layouts_supportClasses_LinearLayoutVector_pendingLength = ((this.spark_layouts_supportClasses_LinearLayoutVector_pendingLength == -1) ? this.length - 1 : this.spark_layouts_supportClasses_LinearLayoutVector_pendingLength - 1) >> 0;
  if (!this.spark_layouts_supportClasses_LinearLayoutVector_pendingRemoves) {
    this.spark_layouts_supportClasses_LinearLayoutVector_pendingRemoves = new (org.apache.royale.utils.Language.synthVector('int'))();
    this.spark_layouts_supportClasses_LinearLayoutVector_pendingRemoves.push(index);
    this.spark_layouts_supportClasses_LinearLayoutVector_pendingRemoves.push(index);
  }
};


/**
 *  @asprivate
 *  Returns true when all sizes in the specified interval for the block are NaN
 * @private
 * @param {spark.layouts.supportClasses.Block} block
 * @param {number} index
 * @param {number} count
 * @return {boolean}
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.spark_layouts_supportClasses_LinearLayoutVector_isIntervalClear = function(block, index, count) {
  var /** @type {Array.<number>} */ sizesSrc = block.sizes;
  for (var /** @type {number} */ i = 0; i < count; i++) {
    if (!isNaN(sizesSrc[index + i]))
      return true;
  }
  return false;
};


/**
 *  @asprivate 
 *  Copies elements between blocks. Indices relative to the blocks.
 *  If srcBlock is null, then it fills the destination with NaNs.
 *  The case of srcBlock == dstBlock is also supported.
 *  The caller must ensure that count is within range.
 * @private
 * @param {spark.layouts.supportClasses.Block} dstBlock
 * @param {number} dstIndexStart
 * @param {spark.layouts.supportClasses.Block} srcBlock
 * @param {number} srcIndexStart
 * @param {number} count
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.spark_layouts_supportClasses_LinearLayoutVector_inBlockCopy = function(dstBlock, dstIndexStart, srcBlock, srcIndexStart, count) {
  var /** @type {boolean} */ ascending = dstIndexStart < srcIndexStart;
  var /** @type {number} */ srcIndex = (ascending ? srcIndexStart : srcIndexStart + count - 1) >> 0;
  var /** @type {number} */ dstIndex = (ascending ? dstIndexStart : dstIndexStart + count - 1) >> 0;
  var /** @type {number} */ increment = (ascending ? +1 : -1) >> 0;
  var /** @type {Array.<number>} */ dstSizes = dstBlock.sizes;
  var /** @type {Array.<number>} */ srcSizes = srcBlock ? srcBlock.sizes : null;
  var /** @type {number} */ dstValue = NaN;
  var /** @type {number} */ srcValue = NaN;
  var /** @type {number} */ sizesSumDelta = 0;
  var /** @type {number} */ defaultCountDelta = 0;
  while (count > 0) {
    if (srcSizes)
      srcValue = srcSizes[srcIndex];
    dstValue = dstSizes[dstIndex];
    if (!(srcValue === dstValue)) {
      if (isNaN(dstValue))
        defaultCountDelta--;
      else
        sizesSumDelta -= dstValue;
      if (isNaN(srcValue))
        defaultCountDelta++;
      else
        sizesSumDelta += srcValue;
      dstSizes[dstIndex] = srcValue;
    }
    srcIndex += increment;
    dstIndex += increment;
    count--;
  }
  dstBlock.sizesSum += sizesSumDelta;
  dstBlock.defaultCount += (defaultCountDelta) >>> 0;
};


/**
 *  @asprivate
 *  Copies 'count' elements from dstIndex to srcIndex.
 *  Safe for overlapping source and destination intervals.
 *  If any blocks are left full of NaNs, they will be deallcated.
 * @private
 * @param {number} dstIndex
 * @param {number} srcIndex
 * @param {number} count
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.spark_layouts_supportClasses_LinearLayoutVector_copyInterval = function(dstIndex, srcIndex, count) {
  var /** @type {number} */ copyCount = 0;
  var /** @type {boolean} */ ascending = dstIndex < srcIndex;
  if (!ascending) {
    dstIndex += (count - 1) >> 0;
    srcIndex += (count - 1) >> 0;
  }
  while (count > 0) {
    var /** @type {number} */ dstBlockIndex = (dstIndex >> spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SHIFT) >>> 0;
    var /** @type {number} */ dstSizesIndex = (dstIndex & spark.layouts.supportClasses.LinearLayoutVector.BLOCK_MASK) >>> 0;
    var /** @type {spark.layouts.supportClasses.Block} */ dstBlock = this.spark_layouts_supportClasses_LinearLayoutVector_blockTable[dstBlockIndex];
    var /** @type {number} */ srcBlockIndex = (srcIndex >> spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SHIFT) >>> 0;
    var /** @type {number} */ srcSizesIndex = (srcIndex & spark.layouts.supportClasses.LinearLayoutVector.BLOCK_MASK) >>> 0;
    var /** @type {spark.layouts.supportClasses.Block} */ srcBlock = this.spark_layouts_supportClasses_LinearLayoutVector_blockTable[srcBlockIndex];
    //var /** @type {number} */ copyCount = 0;
    if (ascending)
      copyCount = (Math.min(spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SIZE - dstSizesIndex, spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SIZE - srcSizesIndex)) >> 0;
    else
      copyCount = (1 + Math.min(dstSizesIndex, srcSizesIndex)) >> 0;
    copyCount = (Math.min(copyCount, count)) >> 0;
    var /** @type {number} */ dstStartIndex = (ascending ? dstSizesIndex : dstSizesIndex - copyCount + 1) >> 0;
    var /** @type {number} */ srcStartIndex = (ascending ? srcSizesIndex : srcSizesIndex - copyCount + 1) >> 0;
    if (srcBlock && !dstBlock && this.spark_layouts_supportClasses_LinearLayoutVector_isIntervalClear(srcBlock, srcStartIndex, copyCount)) {
      dstBlock = new spark.layouts.supportClasses.Block();
      this.spark_layouts_supportClasses_LinearLayoutVector_blockTable[dstBlockIndex] = dstBlock;
    }
    if (dstBlock) {
      this.spark_layouts_supportClasses_LinearLayoutVector_inBlockCopy(dstBlock, dstStartIndex, srcBlock, srcStartIndex, copyCount);
      if (dstBlock.defaultCount == spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SIZE) {
        var /** @type {boolean} */ blockEndReached = ascending ? (dstStartIndex + copyCount == spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SIZE) : (dstStartIndex == 0);
        if (blockEndReached || count == copyCount)
          this.spark_layouts_supportClasses_LinearLayoutVector_blockTable[dstBlockIndex] = null;
      }
    }
    dstIndex += (ascending ? copyCount : -copyCount) >> 0;
    srcIndex += (ascending ? copyCount : -copyCount) >> 0;
    count -= copyCount;
  }
};


/**
 *  @asprivate
 *  Sets all elements within the specified interval to NaN (both ends inclusive). 
 *  Releases empty blocks.
 * @private
 * @param {number} start
 * @param {number} end
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.spark_layouts_supportClasses_LinearLayoutVector_clearInterval = function(start, end) {
  while (start <= end) {
    var /** @type {number} */ blockIndex = (start >> spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SHIFT) >>> 0;
    var /** @type {number} */ sizesIndex = (start & spark.layouts.supportClasses.LinearLayoutVector.BLOCK_MASK) >>> 0;
    var /** @type {spark.layouts.supportClasses.Block} */ block = this.spark_layouts_supportClasses_LinearLayoutVector_blockTable[blockIndex];
    var /** @type {number} */ clearCount = (spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SIZE - sizesIndex) >> 0;
    clearCount = (Math.min(clearCount, end - start + 1)) >> 0;
    if (block) {
      if (clearCount == spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SIZE)
        this.spark_layouts_supportClasses_LinearLayoutVector_blockTable[blockIndex] = null; else {
        this.spark_layouts_supportClasses_LinearLayoutVector_inBlockCopy(block, (sizesIndex) >> 0, null, 0, clearCount);
        if (block.defaultCount == spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SIZE)
          this.spark_layouts_supportClasses_LinearLayoutVector_blockTable[blockIndex] = null;
      }
    }
    start += clearCount;
  }
};


/**
 *  @asprivate
 *  Removes the elements designated by the intervals and truncates
 *  the LinearLayoutVector to the new length.
 *  'intervals' is a Vector of descending intervals [7, 5, 3, 1]
 * @private
 * @param {Array.<number>} intervals
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.spark_layouts_supportClasses_LinearLayoutVector_removeIntervals = function(intervals) {
  var /** @type {number} */ srcStart = 0;
  var /** @type {number} */ count = 0;
  var /** @type {number} */ intervalsCount = (intervals.length) >> 0;
  if (intervalsCount == 0)
    return;
  intervals.reverse();
  intervals.push(this.length);
  var /** @type {number} */ dstStart = intervals[0];
  //var /** @type {number} */ srcStart = 0;
  //var /** @type {number} */ count = 0;
  var /** @type {number} */ i = 0;
  do {
    var /** @type {number} */ intervalEnd = intervals[i + 1];
    var /** @type {number} */ nextIntervalStart = intervals[i + 2];
    i += 2;
    srcStart = (intervalEnd + 1) >> 0;
    count = (nextIntervalStart - srcStart) >> 0;
    this.spark_layouts_supportClasses_LinearLayoutVector_copyInterval(dstStart, srcStart, count);
    dstStart += count;
  } while (i < intervalsCount);
  this.spark_layouts_supportClasses_LinearLayoutVector_setLength((dstStart) >>> 0);
};


/**
 *  @asprivate
 *  Increases the length and inserts NaN values for the elements designated by the intervals.
 *  'intervals' is a Vector of ascending intervals [1, 3, 5, 7]
 * @private
 * @param {Array.<number>} intervals
 * @param {number} newLength
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.spark_layouts_supportClasses_LinearLayoutVector_insertIntervals = function(intervals, newLength) {
  var /** @type {number} */ intervalsCount = (intervals.length) >> 0;
  if (intervalsCount == 0)
    return;
  var /** @type {number} */ oldLength = (this.length) >> 0;
  this.spark_layouts_supportClasses_LinearLayoutVector_setLength((newLength) >>> 0);
  var /** @type {number} */ srcEnd = (oldLength - 1) >> 0;
  var /** @type {number} */ dstEnd = (newLength - 1) >> 0;
  var /** @type {number} */ i = (intervalsCount - 2) >> 0;
  while (i >= 0) {
    var /** @type {number} */ intervalStart = intervals[i];
    var /** @type {number} */ intervalEnd = intervals[i + 1];
    i -= 2;
    var /** @type {number} */ dstStart = (intervalEnd + 1) >> 0;
    var /** @type {number} */ copyCount = (dstEnd - dstStart + 1) >> 0;
    var /** @type {number} */ srcStart = (srcEnd - copyCount + 1) >> 0;
    this.spark_layouts_supportClasses_LinearLayoutVector_copyInterval(dstStart, srcStart, copyCount);
    srcEnd -= copyCount;
    dstEnd = (intervalStart - 1) >> 0;
    this.spark_layouts_supportClasses_LinearLayoutVector_clearInterval(intervalStart, intervalEnd);
  }
};


/**
 *  @asprivate
 *  Processes any pending removes or pending inserts.
 * @private
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.spark_layouts_supportClasses_LinearLayoutVector_flushPendingChanges = function() {
  var /** @type {Array.<number>} */ intervals;
  if (this.spark_layouts_supportClasses_LinearLayoutVector_pendingRemoves) {
    intervals = this.spark_layouts_supportClasses_LinearLayoutVector_pendingRemoves;
    this.spark_layouts_supportClasses_LinearLayoutVector_pendingRemoves = null;
    this.spark_layouts_supportClasses_LinearLayoutVector_pendingLength = -1;
    this.spark_layouts_supportClasses_LinearLayoutVector_removeIntervals(intervals);
  } else if (this.spark_layouts_supportClasses_LinearLayoutVector_pendingInserts) {
    intervals = this.spark_layouts_supportClasses_LinearLayoutVector_pendingInserts;
    var /** @type {number} */ newLength = this.spark_layouts_supportClasses_LinearLayoutVector_pendingLength;
    this.spark_layouts_supportClasses_LinearLayoutVector_pendingInserts = null;
    this.spark_layouts_supportClasses_LinearLayoutVector_pendingLength = -1;
    this.spark_layouts_supportClasses_LinearLayoutVector_insertIntervals(intervals, newLength);
  }
};


/**
 *  The cumulative distance to the start of the item at index, including
 *  the gaps between items and the majorAxisOffset. 
 * 
 *  The value of start(0) is majorAxisOffset.  
 * 
 *  Equivalent to:
 *  <pre>
 *  var distance:Number = majorAxisOffset;
 *  for (var i:int = 0; i &lt; index; i++)
 *      distance += get(i);
 *  return distance + (gap * index);
 *  </pre>
 * 
 *  The actual implementation is relatively efficient.
 * 
 *  @asparam index The item's index.
 *  @see #end
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 * @param {number} index
 * @return {number}
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.start = function(index) {
  this.spark_layouts_supportClasses_LinearLayoutVector_flushPendingChanges();
  if ((this.spark_layouts_supportClasses_LinearLayoutVector__length == 0) || (index == 0))
    return this.majorAxisOffset;
  if (index >= this.spark_layouts_supportClasses_LinearLayoutVector__length)
    throw new Error("invalidIndex");
  var /** @type {number} */ distance = this.majorAxisOffset;
  var /** @type {number} */ blockIndex = (index >> spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SHIFT) >>> 0;
  for (var /** @type {number} */ i = 0; i < blockIndex; i++) {
    var /** @type {spark.layouts.supportClasses.Block} */ block = this.spark_layouts_supportClasses_LinearLayoutVector_blockTable[i];
    if (block)
      distance += block.sizesSum + (block.defaultCount * this.spark_layouts_supportClasses_LinearLayoutVector__defaultMajorSize);
    else
      distance += spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SIZE * this.spark_layouts_supportClasses_LinearLayoutVector__defaultMajorSize;
  }
  var /** @type {spark.layouts.supportClasses.Block} */ lastBlock = this.spark_layouts_supportClasses_LinearLayoutVector_blockTable[blockIndex];
  var /** @type {number} */ lastBlockOffset = (index & ~spark.layouts.supportClasses.LinearLayoutVector.BLOCK_MASK) >>> 0;
  var /** @type {number} */ lastBlockLength = (index - lastBlockOffset) >>> 0;
  if (lastBlock) {
    var /** @type {Array.<number>} */ sizes = lastBlock.sizes;
    for (i = 0; i < lastBlockLength; i++) {
      var /** @type {number} */ size = sizes[i];
      distance += isNaN(size) ? this.spark_layouts_supportClasses_LinearLayoutVector__defaultMajorSize : size;
    }
  }
  else
    distance += this.spark_layouts_supportClasses_LinearLayoutVector__defaultMajorSize * lastBlockLength;
  distance += index * this.gap;
  return distance;
};


/**
 *  The cumulative distance to the end of the item at index, including
 *  the gaps between items.
 * 
 *  If <code>index &lt;(length-1)</code> then the value of this 
 *  function is defined as: 
 *  <code>start(index) + get(index)</code>.
 * 
 *  @asparam index The item's index.
 *  @see #start
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 * @param {number} index
 * @return {number}
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.end = function(index) {
  this.spark_layouts_supportClasses_LinearLayoutVector_flushPendingChanges();
  return this.start(index) + this.getMajorSize(index);
};


/**
 *  Returns the index of the item that overlaps the specified distance.
 * 
 *  The item at index <code>i</code> overlaps a distance value 
 *  if <code>start(i) &lt;= distance &lt; end(i)</code>.
 * 
 *  If no such item exists, -1 is returned.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 * @param {number} distance
 * @return {number}
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.indexOf = function(distance) {
  this.spark_layouts_supportClasses_LinearLayoutVector_flushPendingChanges();
  var /** @type {number} */ index = this.spark_layouts_supportClasses_LinearLayoutVector_indexOfInternal(distance);
  return ((index >= this.spark_layouts_supportClasses_LinearLayoutVector__length) ? -1 : index) >> 0;
};


/**
 * @private
 * @param {number} distance
 * @return {number}
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.spark_layouts_supportClasses_LinearLayoutVector_indexOfInternal = function(distance) {
  if ((this.spark_layouts_supportClasses_LinearLayoutVector__length == 0) || (distance < 0))
    return -1;
  var /** @type {number} */ curDistance = this.majorAxisOffset;
  if (distance < curDistance)
    return 0;
  var /** @type {number} */ index = -1;
  var /** @type {spark.layouts.supportClasses.Block} */ block = null;
  var /** @type {number} */ blockGap = this.spark_layouts_supportClasses_LinearLayoutVector__gap * spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SIZE;
  for (var /** @type {number} */ blockIndex = 0; blockIndex < this.spark_layouts_supportClasses_LinearLayoutVector_blockTable.length; blockIndex++) {
    block = this.spark_layouts_supportClasses_LinearLayoutVector_blockTable[blockIndex];
    var /** @type {number} */ blockDistance = blockGap;
    if (block)
      blockDistance += block.sizesSum + (block.defaultCount * this.spark_layouts_supportClasses_LinearLayoutVector__defaultMajorSize);
    else
      blockDistance += spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SIZE * this.spark_layouts_supportClasses_LinearLayoutVector__defaultMajorSize;
    if ((distance == curDistance) || ((distance >= curDistance) && (distance < (curDistance + blockDistance)))) {
      index = blockIndex << spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SHIFT;
      break;
    }
    curDistance += blockDistance;
  }
  if ((index == -1) || (distance == curDistance))
    return index;
  if (block) {
    var /** @type {Array.<number>} */ sizes = block.sizes;
    for (var /** @type {number} */ i = 0; i < spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SIZE - 1; i++) {
      var /** @type {number} */ size = sizes[i];
      curDistance += this.spark_layouts_supportClasses_LinearLayoutVector__gap + (isNaN(size) ? this.spark_layouts_supportClasses_LinearLayoutVector__defaultMajorSize : size);
      if (curDistance > distance)
        return (index + i) >> 0;
    }
    return (index + spark.layouts.supportClasses.LinearLayoutVector.BLOCK_SIZE - 1) >> 0;
  } else {
    return (index + Math.floor(Number(distance - curDistance) / Number(this.spark_layouts_supportClasses_LinearLayoutVector__defaultMajorSize + this.spark_layouts_supportClasses_LinearLayoutVector__gap))) >> 0;
  }
};


/**
 *  Stores the <code>majorSize</code> for the specified ILayoutElement at index, 
 *  and updates the <code>minorSize</code> and <code>minMinorSize</code> properties.
 * 
 *  If <code>majorAxis</code> is <code>VERTICAL</code> then <code>majorSize</code> corresponds to the 
 *  height of this ILayoutElement, and the minor sizes to the 
 *  <code>preferredBoundsWidth</code> and <code>minWidth</code>.
 * 
 *  If <code>majorAxis</code> is <code>HORIZONTAL</code>, then the roles of the dimensions
 *  are reversed.
 * 
 *  The <code>minMinorSize</code> is intended to be used at the time that the <code>LinearLayout::measure()</code> method is called.
 * 
 *  It accumulates the maximum of the <code>minWidth</code>, <code>Height</code> for all items.
 * 
 *  @asparam index The item's index.
 *  @asparam elt The layout element at index.
 * 
 *  @see #getMajorSize
 *  @see minorSize
 *  @see minMinorSize
 *  @see majorAxis
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 * @param {number} index
 * @param {mx.core.ILayoutElement} elt
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.cacheDimensions = function(index, elt) {
  this.spark_layouts_supportClasses_LinearLayoutVector_flushPendingChanges();
  if (!elt || (index >= this.spark_layouts_supportClasses_LinearLayoutVector__length))
    return;
  if (this.majorAxis == spark.layouts.supportClasses.LinearLayoutVector.VERTICAL) {
    this.setMajorSize(index, elt.getLayoutBoundsHeight());
    var /** @type {number} */ w = Math.min(elt.getPreferredBoundsWidth(), elt.getLayoutBoundsWidth());
    this.spark_layouts_supportClasses_LinearLayoutVector__minorSize = Math.max(this.spark_layouts_supportClasses_LinearLayoutVector__minorSize, w);
    this.minMinorSize = Math.max(this.minMinorSize, elt.getMinBoundsWidth());
  } else {
    this.setMajorSize(index, elt.getLayoutBoundsWidth());
    var /** @type {number} */ h = Math.min(elt.getPreferredBoundsHeight(), elt.getLayoutBoundsHeight());
    this.spark_layouts_supportClasses_LinearLayoutVector__minorSize = Math.max(this.spark_layouts_supportClasses_LinearLayoutVector__minorSize, h);
    this.minMinorSize = Math.max(this.minMinorSize, elt.getMinBoundsHeight());
  }
};


/** 
 *  Returns the implict bounds of the item at index.
 * 
 *  The bounds do not include the gap that follows the item.
 * 
 *  If majorAxis is VERTICAL then the returned value is equivalent to:
 *  <pre>
 *    new Rectangle(0, start(index), major, minor)
 *  </pre>
 * 
 *  If majorAxis is HORIZONTAL then the returned value is equivalent to:
 *  <pre>
 *    new Rectangle(start(index), 0, minor, major)
 *  </pre>
 * 
 *  @asparam index The item's index.
 *  @asparam bounds The Rectangle to return or null for a new Rectangle
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 * @param {number} index
 * @param {org.apache.royale.geom.Rectangle=} bounds
 * @return {org.apache.royale.geom.Rectangle}
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.getBounds = function(index, bounds) {
  bounds = typeof bounds !== 'undefined' ? bounds : null;
  this.spark_layouts_supportClasses_LinearLayoutVector_flushPendingChanges();
  if (!bounds)
    bounds = new org.apache.royale.geom.Rectangle();
  var /** @type {number} */ major = this.getMajorSize(index);
  var /** @type {number} */ minor = this.minorSize;
  if (this.majorAxis == spark.layouts.supportClasses.LinearLayoutVector.VERTICAL) {
    bounds.x = 0;
    bounds.y = this.start(index);
    bounds.height = major;
    bounds.width = minor;
  } else {
    bounds.x = this.start(index);
    bounds.y = 0;
    bounds.height = minor;
    bounds.width = major;
  }
  return bounds;
};


/**
 *  Clear all cached state, reset length to zero.
 * @export
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.clear = function() {
  this.spark_layouts_supportClasses_LinearLayoutVector_pendingRemoves = null;
  this.spark_layouts_supportClasses_LinearLayoutVector_pendingInserts = null;
  this.spark_layouts_supportClasses_LinearLayoutVector_pendingLength = -1;
  this.length = 0;
  this.minorSize = 0;
  this.minMinorSize = 0;
};


/**
 * @export
 * @return {string}
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.toString = function() {
  return "LinearLayoutVector{" + "length=" + this.spark_layouts_supportClasses_LinearLayoutVector__length + " [blocks=" + this.spark_layouts_supportClasses_LinearLayoutVector_blockTable.length + "]" + " " + ((this.majorAxis == spark.layouts.supportClasses.LinearLayoutVector.VERTICAL) ? "VERTICAL" : "HORIZONTAL") + " gap=" + this.spark_layouts_supportClasses_LinearLayoutVector__gap + " defaultMajorSize=" + this.spark_layouts_supportClasses_LinearLayoutVector__defaultMajorSize + " pendingRemoves=" + (this.spark_layouts_supportClasses_LinearLayoutVector_pendingRemoves ? this.spark_layouts_supportClasses_LinearLayoutVector_pendingRemoves.length : 0) + " pendingInserts=" + (this.spark_layouts_supportClasses_LinearLayoutVector_pendingInserts ? this.spark_layouts_supportClasses_LinearLayoutVector_pendingInserts.length : 0) + "}";
};


spark.layouts.supportClasses.LinearLayoutVector.prototype.get__length = function() {
  return (this.spark_layouts_supportClasses_LinearLayoutVector_pendingLength == -1 ? this.spark_layouts_supportClasses_LinearLayoutVector__length : this.spark_layouts_supportClasses_LinearLayoutVector_pendingLength) >>> 0;
};


spark.layouts.supportClasses.LinearLayoutVector.prototype.set__length = function(value) {
  this.spark_layouts_supportClasses_LinearLayoutVector_flushPendingChanges();
  this.spark_layouts_supportClasses_LinearLayoutVector_setLength(value);
};


spark.layouts.supportClasses.LinearLayoutVector.prototype.get__defaultMajorSize = function() {
  return this.spark_layouts_supportClasses_LinearLayoutVector__defaultMajorSize;
};


spark.layouts.supportClasses.LinearLayoutVector.prototype.set__defaultMajorSize = function(value) {
  this.spark_layouts_supportClasses_LinearLayoutVector__defaultMajorSize = value;
};


spark.layouts.supportClasses.LinearLayoutVector.prototype.get__defaultMinorSize = function() {
  return this.spark_layouts_supportClasses_LinearLayoutVector__defaultMinorSize;
};


spark.layouts.supportClasses.LinearLayoutVector.prototype.set__defaultMinorSize = function(value) {
  this.spark_layouts_supportClasses_LinearLayoutVector__defaultMinorSize = value;
};


spark.layouts.supportClasses.LinearLayoutVector.prototype.get__minorSize = function() {
  return Math.max(this.defaultMinorSize, this.spark_layouts_supportClasses_LinearLayoutVector__minorSize);
};


spark.layouts.supportClasses.LinearLayoutVector.prototype.set__minorSize = function(value) {
  this.spark_layouts_supportClasses_LinearLayoutVector__minorSize = value;
};


spark.layouts.supportClasses.LinearLayoutVector.prototype.get__minMinorSize = function() {
  return this.spark_layouts_supportClasses_LinearLayoutVector__minMinorSize;
};


spark.layouts.supportClasses.LinearLayoutVector.prototype.set__minMinorSize = function(value) {
  this.spark_layouts_supportClasses_LinearLayoutVector__minMinorSize = value;
};


spark.layouts.supportClasses.LinearLayoutVector.prototype.get__majorAxis = function() {
  return this.spark_layouts_supportClasses_LinearLayoutVector__majorAxis;
};


spark.layouts.supportClasses.LinearLayoutVector.prototype.set__majorAxis = function(value) {
  this.spark_layouts_supportClasses_LinearLayoutVector__majorAxis = value;
};


spark.layouts.supportClasses.LinearLayoutVector.prototype.get__majorAxisOffset = function() {
  return this.spark_layouts_supportClasses_LinearLayoutVector__majorAxisOffset;
};


spark.layouts.supportClasses.LinearLayoutVector.prototype.set__majorAxisOffset = function(value) {
  this.spark_layouts_supportClasses_LinearLayoutVector__majorAxisOffset = value;
};


spark.layouts.supportClasses.LinearLayoutVector.prototype.get__gap = function() {
  return this.spark_layouts_supportClasses_LinearLayoutVector__gap;
};


spark.layouts.supportClasses.LinearLayoutVector.prototype.set__gap = function(value) {
  this.spark_layouts_supportClasses_LinearLayoutVector__gap = value;
};


Object.defineProperties(spark.layouts.supportClasses.LinearLayoutVector.prototype, /** @lends {spark.layouts.supportClasses.LinearLayoutVector.prototype} */ {
/**
  * @export
  * @type {number} */
length: {
get: spark.layouts.supportClasses.LinearLayoutVector.prototype.get__length,
set: spark.layouts.supportClasses.LinearLayoutVector.prototype.set__length},
/**
  * @export
  * @type {number} */
defaultMajorSize: {
get: spark.layouts.supportClasses.LinearLayoutVector.prototype.get__defaultMajorSize,
set: spark.layouts.supportClasses.LinearLayoutVector.prototype.set__defaultMajorSize},
/**
  * @export
  * @type {number} */
defaultMinorSize: {
get: spark.layouts.supportClasses.LinearLayoutVector.prototype.get__defaultMinorSize,
set: spark.layouts.supportClasses.LinearLayoutVector.prototype.set__defaultMinorSize},
/**
  * @export
  * @type {number} */
minorSize: {
get: spark.layouts.supportClasses.LinearLayoutVector.prototype.get__minorSize,
set: spark.layouts.supportClasses.LinearLayoutVector.prototype.set__minorSize},
/**
  * @export
  * @type {number} */
minMinorSize: {
get: spark.layouts.supportClasses.LinearLayoutVector.prototype.get__minMinorSize,
set: spark.layouts.supportClasses.LinearLayoutVector.prototype.set__minMinorSize},
/**
  * @export
  * @type {number} */
majorAxis: {
get: spark.layouts.supportClasses.LinearLayoutVector.prototype.get__majorAxis,
set: spark.layouts.supportClasses.LinearLayoutVector.prototype.set__majorAxis},
/**
  * @export
  * @type {number} */
majorAxisOffset: {
get: spark.layouts.supportClasses.LinearLayoutVector.prototype.get__majorAxisOffset,
set: spark.layouts.supportClasses.LinearLayoutVector.prototype.set__majorAxisOffset},
/**
  * @export
  * @type {number} */
gap: {
get: spark.layouts.supportClasses.LinearLayoutVector.prototype.get__gap,
set: spark.layouts.supportClasses.LinearLayoutVector.prototype.set__gap}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'LinearLayoutVector', qName: 'spark.layouts.supportClasses.LinearLayoutVector', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    accessors: function () {
      return {
        'length': { type: 'uint', access: 'readwrite', declaredBy: 'spark.layouts.supportClasses.LinearLayoutVector'},
        'defaultMajorSize': { type: 'Number', access: 'readwrite', declaredBy: 'spark.layouts.supportClasses.LinearLayoutVector'},
        'defaultMinorSize': { type: 'Number', access: 'readwrite', declaredBy: 'spark.layouts.supportClasses.LinearLayoutVector'},
        'minorSize': { type: 'Number', access: 'readwrite', declaredBy: 'spark.layouts.supportClasses.LinearLayoutVector'},
        'minMinorSize': { type: 'Number', access: 'readwrite', declaredBy: 'spark.layouts.supportClasses.LinearLayoutVector'},
        'majorAxis': { type: 'uint', access: 'readwrite', declaredBy: 'spark.layouts.supportClasses.LinearLayoutVector'},
        'majorAxisOffset': { type: 'Number', access: 'readwrite', declaredBy: 'spark.layouts.supportClasses.LinearLayoutVector'},
        'gap': { type: 'Number', access: 'readwrite', declaredBy: 'spark.layouts.supportClasses.LinearLayoutVector'}
      };
    },
    methods: function () {
      return {
        'LinearLayoutVector': { type: '', declaredBy: 'spark.layouts.supportClasses.LinearLayoutVector', parameters: function () { return [ 'uint', true ]; }},
        'getMajorSize': { type: 'Number', declaredBy: 'spark.layouts.supportClasses.LinearLayoutVector', parameters: function () { return [ 'uint', false ]; }},
        'setMajorSize': { type: 'void', declaredBy: 'spark.layouts.supportClasses.LinearLayoutVector', parameters: function () { return [ 'uint', false ,'Number', false ]; }},
        'insert': { type: 'void', declaredBy: 'spark.layouts.supportClasses.LinearLayoutVector', parameters: function () { return [ 'uint', false ]; }},
        'remove': { type: 'void', declaredBy: 'spark.layouts.supportClasses.LinearLayoutVector', parameters: function () { return [ 'uint', false ]; }},
        'start': { type: 'Number', declaredBy: 'spark.layouts.supportClasses.LinearLayoutVector', parameters: function () { return [ 'uint', false ]; }},
        'end': { type: 'Number', declaredBy: 'spark.layouts.supportClasses.LinearLayoutVector', parameters: function () { return [ 'uint', false ]; }},
        'indexOf': { type: 'int', declaredBy: 'spark.layouts.supportClasses.LinearLayoutVector', parameters: function () { return [ 'Number', false ]; }},
        'cacheDimensions': { type: 'void', declaredBy: 'spark.layouts.supportClasses.LinearLayoutVector', parameters: function () { return [ 'uint', false ,'mx.core.ILayoutElement', false ]; }},
        'getBounds': { type: 'org.apache.royale.geom.Rectangle', declaredBy: 'spark.layouts.supportClasses.LinearLayoutVector', parameters: function () { return [ 'uint', false ,'org.apache.royale.geom.Rectangle', true ]; }},
        'clear': { type: 'void', declaredBy: 'spark.layouts.supportClasses.LinearLayoutVector'},
        'toString': { type: 'String', declaredBy: 'spark.layouts.supportClasses.LinearLayoutVector'}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
spark.layouts.supportClasses.LinearLayoutVector.prototype.ROYALE_COMPILE_FLAGS = 10;

/**
 * Generated by Apache Royale Compiler from spark/layouts/supportClasses/LayoutBase.as
 * spark.layouts.supportClasses.LayoutBase
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('spark.layouts.supportClasses.LayoutBase');
/* Royale Dependency List: mx.core.ILayoutElement,mx.core.IVisualElement,mx.core.UIComponent,mx.core.mx_internal,org.apache.royale.core.IStrand,org.apache.royale.core.UIBase,org.apache.royale.events.Event,org.apache.royale.events.EventDispatcher,org.apache.royale.events.ValueChangeEvent,org.apache.royale.geom.Point,org.apache.royale.geom.Rectangle,org.apache.royale.utils.PointUtils,spark.components.Group,spark.components.supportClasses.GroupBase,spark.core.NavigationUnit,spark.layouts.HorizontalAlign,spark.layouts.VerticalLayout,spark.layouts.supportClasses.DropLocation,org.apache.royale.utils.Language,XML*/

goog.require('org.apache.royale.core.LayoutBase');
goog.require('org.apache.royale.events.IEventDispatcher');



/**
 *  Constructor. 
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @constructor
 * @extends {org.apache.royale.core.LayoutBase}
 * @implements {org.apache.royale.events.IEventDispatcher}
 */
spark.layouts.supportClasses.LayoutBase = function() {
  
  this.spark_layouts_supportClasses_LayoutBase_ed = new org.apache.royale.events.EventDispatcher(this);
  spark.layouts.supportClasses.LayoutBase.base(this, 'constructor');
};
goog.inherits(spark.layouts.supportClasses.LayoutBase, org.apache.royale.core.LayoutBase);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('spark.layouts.supportClasses.LayoutBase', spark.layouts.supportClasses.LayoutBase);


/**
 * @private
 * @type {spark.components.supportClasses.GroupBase}
 */
spark.layouts.supportClasses.LayoutBase.prototype.spark_layouts_supportClasses_LayoutBase__target;


/**
 * @private
 * @type {boolean}
 */
spark.layouts.supportClasses.LayoutBase.prototype.spark_layouts_supportClasses_LayoutBase__useVirtualLayout = false;


/**
 *  When <code>useVirtualLayout</code> is <code>true</code>, 
 *  this method can be used by the layout target
 *  to clear cached layout information when the target changes.   
 * 
 *  <p>For example, when a DataGroup's <code>dataProvider</code> or 
 *  <code>itemRenderer</code> property changes, cached 
 *  elements sizes become invalid. </p>
 * 
 *  <p>When the <code>useVirtualLayout</code> property changes to <code>false</code>, 
 *  this method is called automatically.</p>
 * 
 *  <p>Subclasses that support <code>useVirtualLayout</code> = <code>true</code> 
 *  must override this method. </p>
 * 
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 */
spark.layouts.supportClasses.LayoutBase.prototype.clearVirtualLayoutCache = function() {
};


/**
 * @private
 * @type {number}
 */
spark.layouts.supportClasses.LayoutBase.prototype.spark_layouts_supportClasses_LayoutBase__horizontalScrollPosition = 0;


/**
 * @private
 * @type {number}
 */
spark.layouts.supportClasses.LayoutBase.prototype.spark_layouts_supportClasses_LayoutBase__verticalScrollPosition = 0;


/**
 * @private
 * @type {boolean}
 */
spark.layouts.supportClasses.LayoutBase.prototype.spark_layouts_supportClasses_LayoutBase__clipAndEnableScrolling = false;


/**
 * @private
 * @type {mx.core.ILayoutElement}
 */
spark.layouts.supportClasses.LayoutBase.prototype.spark_layouts_supportClasses_LayoutBase__typicalLayoutElement = null;


/**
 * @private
 * @type {org.apache.royale.core.UIBase}
 */
spark.layouts.supportClasses.LayoutBase.prototype.spark_layouts_supportClasses_LayoutBase__dropIndicator;


/**
 *  Measures the target's default size based on its content, and optionally
 *  measures the target's default minimum size.
 *
 *  <p>This is one of the methods that you must override when creating a
 *  subclass of LayoutBase. The other method is <code>updateDisplayList()</code>.
 *  You do not call these methods directly. Flex calls this method as part
 *  of a layout pass. A layout pass consists of three phases.</p>
 *
 *  <p>First, if the target's properties are invalid, the LayoutManager calls
 *  the target's <code>commitProperties</code> method.</p>
 *
 *  <p>Second, if the target's size is invalid, LayoutManager calls the target's
 *  <code>validateSize()</code> method. The target's <code>validateSize()</code>
 *  will in turn call the layout's <code>measure()</code> to calculate the
 *  target's default size unless it was explicitly specified by both target's
 *  <code>explicitWidth</code> and <code>explicitHeight</code> properties.
 *  If the default size changes, Flex will invalidate the target's display list.</p>
 *
 *  <p>Last, if the target's display list is invalid, LayoutManager calls the target's
 *  <code>validateDisplayList</code>. The target's <code>validateDisplayList</code>
 *  will in turn call the layout's <code>updateDisplayList</code> method to
 *  size and position the target's elements.</p>
 *
 *  <p>When implementing this method, you must set the target's
 *  <code>measuredWidth</code> and <code>measuredHeight</code> properties
 *  to define the target's default size. You may optionally set the
 *  <code>measuredMinWidth</code> and <code>measuredMinHeight</code>
 *  properties to define the default minimum size.
 *  A typical implementation iterates through the target's elements
 *  and uses the methods defined by the <code>ILayoutElement</code> to
 *  accumulate the preferred and/or minimum sizes of the elements and then sets
 *  the target's <code>measuredWidth</code>, <code>measuredHeight</code>,
 *  <code>measuredMinWidth</code> and <code>measuredMinHeight</code>.</p>
 *
 *  @see #updateDisplayList()
 *
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 */
spark.layouts.supportClasses.LayoutBase.prototype.measure = function() {
};


/**
 *  Sizes and positions the target's elements.
 *
 *  <p>This is one of the methods that you must override when creating a
 *  subclass of LayoutBase. The other method is <code>measure()</code>.
 *  You do not call these methods directly. Flex calls this method as part
 *  of a layout pass. A layout pass consists of three phases.</p>
 *
 *  <p>First, if the target's properties are invalid, the LayoutManager calls
 *  the target's <code>commitProperties</code> method.</p>
 *
 *  <p>Second, if the target's size is invalid, LayoutManager calls the target's
 *  <code>validateSize()</code> method. The target's <code>validateSize()</code>
 *  will in turn call the layout's <code>measure()</code> to calculate the
 *  target's default size unless it was explicitly specified by both target's
 *  <code>explicitWidth</code> and <code>explicitHeight</code> properties.
 *  If the default size changes, Flex will invalidate the target's display list.</p>
 *
 *  <p>Last, if the target's display list is invalid, LayoutManager calls the target's
 *  <code>validateDisplayList</code>. The target's <code>validateDisplayList</code>
 *  will in turn call the layout's <code>updateDisplayList</code> method to
 *  size and position the target's elements.</p>
 *
 *  <p>A typical implementation iterates through the target's elements
 *  and uses the methods defined by the <code>ILayoutElement</code> to
 *  position and resize the elements. Then the layout must also calculate and set
 *  the target's <code>contentWidth</code> and <code>contentHeight</code>
 *  properties to define the target's scrolling region.</p>
 *
 *  @asparam unscaledWidth Specifies the width of the target, in pixels,
 *  in the targets's coordinates.
 *
 *  @asparam unscaledHeight Specifies the height of the component, in pixels,
 *  in the target's coordinates.
 *
 *  @see #measure()
 *
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 * @param {number} width
 * @param {number} height
 */
spark.layouts.supportClasses.LayoutBase.prototype.updateDisplayList = function(width, height) {
};


/**
 *  Called by the target after a layout element 
 *  has been added and before the target's size and display list are
 *  validated.   
 *  Layouts that cache per element state, like virtual layouts, can 
 *  override this method to update their cache.
 * 
 *  <p>If the target calls this method, it's only guaranteeing that a
 *  a layout element will exist at the specified index at
 *  <code>updateDisplayList()</code> time, for example a DataGroup
 *  with a virtual layout will call this method when an item is added 
 *  to the targets <code>dataProvider</code>.</p>
 * 
 *  <p>By default, this method does nothing.</p>
 * 
 *  @asparam index The index of the element that was added.
 * 
 *  @see #elementRemoved()    
 *
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 * @param {number} index
 */
spark.layouts.supportClasses.LayoutBase.prototype.elementAdded = function(index) {
};


/**
 *  This method must is called by the target after a layout element 
 *  has been removed and before the target's size and display list are
 *  validated.   
 *  Layouts that cache per element state, like virtual layouts, can 
 *  override this method to update their cache.
 * 
 *  <p>If the target calls this method, it's only guaranteeing that a
 *  a layout element will no longer exist at the specified index at
 *  <code>updateDisplayList()</code> time.
 *  For example, a DataGroup
 *  with a virtual layout calls this method when an item is added to 
 *  the <code>dataProvider</code> property.</p>
 * 
 *  <p>By default, this method does nothing.</p>
 * 
 *  @asparam index The index of the element that was added.
 *  @see #elementAdded()
 *
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 * @param {number} index
 */
spark.layouts.supportClasses.LayoutBase.prototype.elementRemoved = function(index) {
};


/**
 *  Called when the <code>verticalScrollPosition</code> or 
 *  <code>horizontalScrollPosition</code> properties change.
 *
 *  <p>The default implementation updates the target's <code>scrollRect</code> property by
 *  calling <code>updateScrollRect()</code>.
 *  Subclasses can override this method to compute other values that are
 *  based on the current <code>scrollPosition</code> or <code>scrollRect</code>.</p>
 *
 *  @see #updateScrollRect()
 *
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @protected
 */
spark.layouts.supportClasses.LayoutBase.prototype.scrollPositionChanged = function() {
  var /** @type {spark.components.supportClasses.GroupBase} */ g = this.target;
  if (!g)
    return;
  this.updateScrollRect(g.width, g.height);
};


/**
 *  Called by the target at the end of its <code>updateDisplayList</code>
 *  to have the layout update its scrollRect.
 * 
 *  <p>If <code>clipAndEnableScrolling</code> is <code>true</code>, 
 *  the default implementation sets the origin of the target's <code>scrollRect</code> 
 *  to <code>verticalScrollPosition</code>, <code>horizontalScrollPosition</code>.
 *  It sets its size to the <code>width</code>, <code>height</code>
 *  parameters (the target's unscaled width and height).</p>
 * 
 *  <p>If <code>clipAndEnableScrolling</code> is <code>false</code>, 
 *  the default implementation sets the <code>scrollRect</code> to null.</p>
 *  
 *  @asparam width The target's width.
 *
 *  @asparam height The target's height.
 * 
 *  @see #target
 *  @see flash.display.DisplayObject#scrollRect
 *  @see #updateDisplayList()
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 * @param {number} w
 * @param {number} h
 */
spark.layouts.supportClasses.LayoutBase.prototype.updateScrollRect = function(w, h) {
  
};


/**
 *  Delegation method that determines which item  
 *  to navigate to based on the current item in focus 
 *  and user input in terms of NavigationUnit. This method
 *  is used by subclasses of ListBase to handle 
 *  keyboard navigation. ListBase maps user input to
 *  NavigationUnit constants.
 * 
 *  <p>Subclasses can override this method to compute other 
 *  values that are based on the current index and key 
 *  stroke encountered. </p>
 * 
 *  @asparam currentIndex The current index of the item with focus.
 * 
 *  @asparam navigationUnit The NavigationUnit constant that determines
 *  which item to navigate to next.  
 * 
 *  @asparam arrowKeysWrapFocus If <code>true</code>, using arrow keys to 
 *  navigate within the component wraps when it hits either end.
 * 
 *  @asreturn The index of the next item to jump to. Returns -1
 *  when if the layout doesn't recognize the navigationUnit.  
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 * @param {number} currentIndex
 * @param {number} navigationUnit
 * @param {boolean} arrowKeysWrapFocus
 * @return {number}
 */
spark.layouts.supportClasses.LayoutBase.prototype.getNavigationDestinationIndex = function(currentIndex, navigationUnit, arrowKeysWrapFocus) {
  if (!this.target || this.target.numElements < 1)
    return -1;
  switch (navigationUnit) {
    case spark.core.NavigationUnit.HOME:
      return 0;
    case spark.core.NavigationUnit.END:
      return (this.target.numElements - 1) >> 0;
    default:
      return -1;
  }
};


/**
 *  Returns the bounds of the target's scroll rectangle in layout coordinates.
 * 
 *  Layout methods should not get the target's scroll rectangle directly.
 * 
 *  @asreturn The bounds of the target's scrollRect in layout coordinates, null
 *      if target or clipAndEnableScrolling is false. 
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @protected
 * @return {org.apache.royale.geom.Rectangle}
 */
spark.layouts.supportClasses.LayoutBase.prototype.getScrollRect = function() {
  var /** @type {spark.components.supportClasses.GroupBase} */ g = this.target;
  if (!g)
    return null;
  var /** @type {number} */ vsp = g.verticalScrollPosition;
  var /** @type {number} */ hsp = g.horizontalScrollPosition;
  return new org.apache.royale.geom.Rectangle(hsp, vsp, g.width, g.height);
};


/**
 *  Returns the specified element's layout bounds as a Rectangle or null
 *  if the index is invalid, the corresponding element is null,
 *  <code>includeInLayout=false</code>, 
 *  or if this layout's <code>target</code> property is null.
 *   
 *  <p>Layout subclasses that support <code>useVirtualLayout=true</code> must
 *  override this method to compute a potentially approximate value for
 *  elements that are not in view.</p>
 * 
 *  @asparam index Index of the layout element.
 * 
 *  @asreturn The specified element's layout bounds.
 *
 *  @see mx.core.ILayoutElement#getLayoutBoundsX()
 *  @see mx.core.ILayoutElement#getLayoutBoundsY()
 *  @see mx.core.ILayoutElement#getLayoutBoundsWidth()
 *  @see mx.core.ILayoutElement#getLayoutBoundsHeight()
 *   
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 * @param {number} index
 * @return {org.apache.royale.geom.Rectangle}
 */
spark.layouts.supportClasses.LayoutBase.prototype.getElementBounds = function(index) {
  var /** @type {spark.components.supportClasses.GroupBase} */ g = this.target;
  if (!g)
    return null;
  var /** @type {number} */ n = g.numElements;
  if ((index < 0) || (index >= n))
    return null;
  var /** @type {mx.core.ILayoutElement} */ elt = org.apache.royale.utils.Language.as(g.getElementAt(index), mx.core.ILayoutElement);
  if (!elt || !elt.includeInLayout)
    return null;
  var /** @type {number} */ eltX = elt.getLayoutBoundsX();
  var /** @type {number} */ eltY = elt.getLayoutBoundsY();
  var /** @type {number} */ eltW = elt.getLayoutBoundsWidth();
  var /** @type {number} */ eltH = elt.getLayoutBoundsHeight();
  return new org.apache.royale.geom.Rectangle(eltX, eltY, eltW, eltH);
};


/**
 *  @asprivate 
 *  Given any descendant element of the target, return its bounds in the 
 *  target's coordinate space.
 * @export
 * @param {mx.core.IVisualElement} element
 * @return {org.apache.royale.geom.Rectangle}
 */
spark.layouts.supportClasses.LayoutBase.prototype.http_$$www_adobe_com$2006$flex$mx$internal__getChildElementBounds = function(element) {
  if (!element)
    return new org.apache.royale.geom.Rectangle(0, 0, 0, 0);
  var /** @type {mx.core.UIComponent} */ parentUIC = org.apache.royale.utils.Language.as(element.parent, mx.core.UIComponent);
  if (parentUIC) {
    var /** @type {spark.components.supportClasses.GroupBase} */ g = this.target;
    var /** @type {org.apache.royale.geom.Point} */ posPointStart = new org.apache.royale.geom.Point(element.getLayoutBoundsX(), element.getLayoutBoundsY());
    var /** @type {org.apache.royale.geom.Point} */ sizePoint = new org.apache.royale.geom.Point(element.getLayoutBoundsWidth(), element.getLayoutBoundsHeight());
    var /** @type {org.apache.royale.geom.Point} */ posPoint = org.apache.royale.utils.PointUtils.localToGlobal(posPointStart, parentUIC);
    posPoint = org.apache.royale.utils.PointUtils.globalToLocal(posPoint, g);
    return new org.apache.royale.geom.Rectangle(posPoint.x, posPoint.y, sizePoint.x, sizePoint.y);
  }
  return new org.apache.royale.geom.Rectangle(0, 0, 0, 0);
};


/**
 *  @asprivate 
 *  Convert the localBounds of a descendant element into the target's coordinate system
 * @private
 * @param {mx.core.IVisualElement} element
 * @param {org.apache.royale.geom.Rectangle} elementLocalBounds
 * @return {org.apache.royale.geom.Rectangle}
 */
spark.layouts.supportClasses.LayoutBase.prototype.spark_layouts_supportClasses_LayoutBase_convertLocalToTarget = function(element, elementLocalBounds) {
  if (!element)
    return new org.apache.royale.geom.Rectangle(0, 0, 0, 0);
  var /** @type {mx.core.UIComponent} */ parentUIC = org.apache.royale.utils.Language.as(element.parent, mx.core.UIComponent);
  if (parentUIC) {
    var /** @type {spark.components.supportClasses.GroupBase} */ g = this.target;
    var /** @type {org.apache.royale.geom.Point} */ posPointStart = new org.apache.royale.geom.Point(element.getLayoutBoundsX() + elementLocalBounds.x, element.getLayoutBoundsY() + elementLocalBounds.y);
    var /** @type {org.apache.royale.geom.Point} */ posPoint = org.apache.royale.utils.PointUtils.localToGlobal(posPointStart, parentUIC);
    posPoint = org.apache.royale.utils.PointUtils.globalToLocal(posPoint, g);
    return new org.apache.royale.geom.Rectangle(posPoint.x, posPoint.y, elementLocalBounds.width, elementLocalBounds.height);
  }
  return new org.apache.royale.geom.Rectangle(0, 0, 0, 0);
};


/**
 *  @asprivate
 *  Return true if the specified element's layout bounds fall within the
 *  scrollRect, or if scrollRect is null.
 * @export
 * @param {mx.core.ILayoutElement} elt
 * @return {boolean}
 */
spark.layouts.supportClasses.LayoutBase.prototype.http_$$www_adobe_com$2006$flex$mx$internal__isElementVisible = function(elt) {
  if (!elt || !elt.includeInLayout)
    return false;
  var /** @type {spark.components.supportClasses.GroupBase} */ g = this.target;
  if (!g)
    return true;
  
/**
 * @const
 * @type {number}
 */
var vsp = g.verticalScrollPosition;
  
/**
 * @const
 * @type {number}
 */
var hsp = g.horizontalScrollPosition;
  
/**
 * @const
 * @type {number}
 */
var targetW = g.width;
  
/**
 * @const
 * @type {number}
 */
var targetH = g.height;
  
/**
 * @const
 * @type {number}
 */
var eltX = elt.getLayoutBoundsX();
  
/**
 * @const
 * @type {number}
 */
var eltY = elt.getLayoutBoundsY();
  
/**
 * @const
 * @type {number}
 */
var eltW = elt.getLayoutBoundsWidth();
  
/**
 * @const
 * @type {number}
 */
var eltH = elt.getLayoutBoundsHeight();
  return (eltX < (hsp + targetW)) && ((eltX + eltW) > hsp) && (eltY < (vsp + targetH)) && ((eltY + eltH) > vsp);
};


/**
 *  Returns the bounds of the first layout element that either spans or
 *  is to the left of the scrollRect's left edge.
 * 
 *  <p>This is a convenience method that is used by the default
 *  implementation of the <code>getHorizontalScrollPositionDelta()</code> method.
 *  Subclasses that rely on the default implementation of
 *  <code>getHorizontalScrollPositionDelta()</code> should override this method to
 *  provide an accurate bounding rectangle that has valid <code>left</code> and 
 *  <code>right</code> properties.</p>
 * 
 *  <p>By default this method returns a Rectangle with width=1, height=0, 
 *  whose left edge is one less than the left edge of the <code>scrollRect</code>, 
 *  and top=0.</p>
 * 
 *  @asparam scrollRect The target's scrollRect.
 *
 *  @asreturn The bounds of the first element that spans or is to
 *  the left of the scrollRect's left edge.
 *  
 *  @see #getElementBoundsRightOfScrollRect()
 *  @see #getElementBoundsAboveScrollRect()
 *  @see #getElementBoundsBelowScrollRect()
 *  @see #getHorizontalScrollPositionDelta()
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @protected
 * @param {org.apache.royale.geom.Rectangle} scrollRect
 * @return {org.apache.royale.geom.Rectangle}
 */
spark.layouts.supportClasses.LayoutBase.prototype.getElementBoundsLeftOfScrollRect = function(scrollRect) {
  var /** @type {org.apache.royale.geom.Rectangle} */ bounds = new org.apache.royale.geom.Rectangle();
  bounds.left = scrollRect.left - 1;
  bounds.right = scrollRect.left;
  return bounds;
};


/**
 *  Returns the bounds of the first layout element that either spans or
 *  is to the right of the scrollRect's right edge.
 * 
 *  <p>This is a convenience method that is used by the default
 *  implementation of the <code>getHorizontalScrollPositionDelta()</code> method.
 *  Subclasses that rely on the default implementation of
 *  <code>getHorizontalScrollPositionDelta()</code> should override this method to
 *  provide an accurate bounding rectangle that has valid <code>left</code> and 
 *  <code>right</code> properties.</p>
 * 
 *  <p>By default this method returns a Rectangle with width=1, height=0, 
 *  whose right edge is one more than the right edge of the <code>scrollRect</code>, 
 *  and top=0.</p>
 * 
 *  @asparam scrollRect The target's scrollRect.
 *
 *  @asreturn The bounds of the first element that spans or is to
 *  the right of the scrollRect's right edge.
 *  
 *  @see #getElementBoundsLeftOfScrollRect()
 *  @see #getElementBoundsAboveScrollRect()
 *  @see #getElementBoundsBelowScrollRect()
 *  @see #getHorizontalScrollPositionDelta()
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @protected
 * @param {org.apache.royale.geom.Rectangle} scrollRect
 * @return {org.apache.royale.geom.Rectangle}
 */
spark.layouts.supportClasses.LayoutBase.prototype.getElementBoundsRightOfScrollRect = function(scrollRect) {
  var /** @type {org.apache.royale.geom.Rectangle} */ bounds = new org.apache.royale.geom.Rectangle();
  bounds.left = scrollRect.right;
  bounds.right = scrollRect.right + 1;
  return bounds;
};


/**
 *  Returns the bounds of the first layout element that either spans or
 *  is above the scrollRect's top edge.
 * 
 *  <p>This is a convenience method that is used by the default
 *  implementation of the <code>getVerticalScrollPositionDelta()</code> method.
 *  Subclasses that rely on the default implementation of
 *  <code>getVerticalScrollPositionDelta()</code> should override this method to
 *  provide an accurate bounding rectangle that has valid <code>top</code> and 
 *  <code>bottom</code> properties.</p>
 * 
 *  <p>By default this method returns a Rectangle with width=0, height=1, 
 *  whose top edge is one less than the top edge of the <code>scrollRect</code>, 
 *  and left=0.</p>
 * 
 *  <p>Subclasses should override this method to provide an accurate
 *  bounding rectangle that has valid <code>top</code> and 
 *  <code>bottom</code> properties.</p>
 * 
 *  @asparam scrollRect The target's scrollRect.
 *
 *  @asreturn The bounds of the first element that spans or is
 *  above the scrollRect's top edge.
 *  
 *  @see #getElementBoundsLeftOfScrollRect()
 *  @see #getElementBoundsRightOfScrollRect()
 *  @see #getElementBoundsBelowScrollRect()
 *  @see #getVerticalScrollPositionDelta()
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @protected
 * @param {org.apache.royale.geom.Rectangle} scrollRect
 * @return {org.apache.royale.geom.Rectangle}
 */
spark.layouts.supportClasses.LayoutBase.prototype.getElementBoundsAboveScrollRect = function(scrollRect) {
  var /** @type {org.apache.royale.geom.Rectangle} */ bounds = new org.apache.royale.geom.Rectangle();
  bounds.top = scrollRect.top - 1;
  bounds.bottom = scrollRect.top;
  return bounds;
};


/**
 *  Returns the bounds of the first layout element that either spans or
 *  is below the scrollRect's bottom edge.
 *
 *  <p>This is a convenience method that is used by the default
 *  implementation of the <code>getVerticalScrollPositionDelta()</code> method.
 *  Subclasses that rely on the default implementation of
 *  <code>getVerticalScrollPositionDelta()</code> should override this method to
 *  provide an accurate bounding rectangle that has valid <code>top</code> and 
 *  <code>bottom</code> properties.</p>
 *
 *  <p>By default this method returns a Rectangle with width=0, height=1, 
 *  whose bottom edge is one more than the bottom edge of the <code>scrollRect</code>, 
 *  and left=0.</p>
 *
 *  @asparam scrollRect The target's scrollRect.
 *
 *  @asreturn The bounds of the first element that spans or is
 *  below the scrollRect's bottom edge.
 *
 *  @see #getElementBoundsLeftOfScrollRect()
 *  @see #getElementBoundsRightOfScrollRect()
 *  @see #getElementBoundsAboveScrollRect()
 *  @see #getVerticalScrollPositionDelta()
 *
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @protected
 * @param {org.apache.royale.geom.Rectangle} scrollRect
 * @return {org.apache.royale.geom.Rectangle}
 */
spark.layouts.supportClasses.LayoutBase.prototype.getElementBoundsBelowScrollRect = function(scrollRect) {
  var /** @type {org.apache.royale.geom.Rectangle} */ bounds = new org.apache.royale.geom.Rectangle();
  bounds.top = scrollRect.bottom;
  bounds.bottom = scrollRect.bottom + 1;
  return bounds;
};


/**
 *  Returns the change to the horizontal scroll position to handle 
 *  different scrolling options. 
 *  These options are defined by the NavigationUnit class: <code>END</code>, <code>HOME</code>, 
 *  <code>LEFT</code>, <code>PAGE_LEFT</code>, <code>PAGE_RIGHT</code>, and <code>RIGHT</code>. 
 *      
 *  @asparam navigationUnit Takes the following values: 
 *  <ul>
 *  <li> 
 *  <code>END</code>
 *  Returns scroll delta that will right justify the scrollRect
 *  to the content area.
 *  </li>
 *  
 *  <li> 
 *  <code>HOME</code>
 *  Returns scroll delta that will left justify the scrollRect
 *  to the content area.
 *  </li>
 * 
 *  <li> 
 *  <code>LEFT</code>
 *  Returns scroll delta that will left justify the scrollRect
 *  with the first element that spans or is to the left of the
 *  scrollRect's left edge.
 *  </li>
 * 
 *  <li>
 *  <code>PAGE_LEFT</code>
 *  Returns scroll delta that will right justify the scrollRect
 *  with the first element that spans or is to the left of the
 *  scrollRect's left edge.
 *  </li>
 * 
 *  <li> 
 *  <code>PAGE_RIGHT</code>
 *  Returns scroll delta that will left justify the scrollRect
 *  with the first element that spans or is to the right of the
 *  scrollRect's right edge.
 *  </li>
 * 
 *  <li> 
 *  <code>RIGHT</code>
 *  Returns scroll delta that will right justify the scrollRect
 *  with the first element that spans or is to the right of the
 *  scrollRect's right edge.
 *  </li>
 *
 *  </ul>
 * 
 *  <p>The implementation calls <code>getElementBoundsLeftOfScrollRect()</code> and
 *  <code>getElementBoundsRightOfScrollRect()</code> to determine the bounds of
 *  the elements.  Layout classes usually override those methods instead of
 *  the <code>getHorizontalScrollPositionDelta()</code> method.</p>
 *
 *  @asreturn The change to the horizontal scroll position.
 * 
 *  @see spark.core.NavigationUnit
 *  @see #getElementBoundsLeftOfScrollRect()
 *  @see #getElementBoundsRightOfScrollRect()
 *  @see #getHorizontalScrollPositionDelta()
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 * @param {number} navigationUnit
 * @return {number}
 */
spark.layouts.supportClasses.LayoutBase.prototype.getHorizontalScrollPositionDelta = function(navigationUnit) {
  var /** @type {spark.components.supportClasses.GroupBase} */ g = this.target;
  if (!g)
    return 0;
  var /** @type {org.apache.royale.geom.Rectangle} */ scrollRect = this.getScrollRect();
  if (!scrollRect)
    return 0;
  if ((scrollRect.x == 0) && (scrollRect.width >= g.contentWidth))
    return 0;
  var /** @type {number} */ maxDelta = g.contentWidth - scrollRect.right;
  var /** @type {number} */ minDelta = -scrollRect.left;
  var /** @type {org.apache.royale.geom.Rectangle} */ getElementBounds;
  switch (navigationUnit) {
    case spark.core.NavigationUnit.LEFT:
    
    case spark.core.NavigationUnit.PAGE_LEFT:
      getElementBounds = this.getElementBoundsLeftOfScrollRect(scrollRect);
      break;
    case spark.core.NavigationUnit.RIGHT:
    
    case spark.core.NavigationUnit.PAGE_RIGHT:
      getElementBounds = this.getElementBoundsRightOfScrollRect(scrollRect);
      break;
    case spark.core.NavigationUnit.HOME:
      return minDelta;
    case spark.core.NavigationUnit.END:
      return maxDelta;
    default:
      return 0;
  }
  if (!getElementBounds)
    return 0;
  var /** @type {number} */ delta = 0;
  switch (navigationUnit) {
    case spark.core.NavigationUnit.LEFT:
      delta = Math.max(getElementBounds.left - scrollRect.left, -scrollRect.width);
      break;
    case spark.core.NavigationUnit.RIGHT:
      delta = Math.min(getElementBounds.right - scrollRect.right, scrollRect.width);
      break;
    case spark.core.NavigationUnit.PAGE_LEFT:
      delta = getElementBounds.right - scrollRect.right;
      if (delta >= 0)
        delta = Math.max(getElementBounds.left - scrollRect.left, -scrollRect.width);
      break;
    case spark.core.NavigationUnit.PAGE_RIGHT:
      delta = getElementBounds.left - scrollRect.left;
      if (delta <= 0)
        delta = Math.min(getElementBounds.right - scrollRect.right, scrollRect.width);
      break;
  }
  return Math.min(maxDelta, Math.max(minDelta, delta));
};


/**
 *  Returns the change to the vertical scroll position to handle 
 *  different scrolling options. 
 *  These options are defined by the NavigationUnit class:
 *  <code>DOWN</code>,  <code>END</code>, <code>HOME</code>, 
 *  <code>PAGE_DOWN</code>, <code>PAGE_UP</code>, and <code>UP</code>. 
 * 
 *  @asparam navigationUnit Takes the following values: 
 *  <ul>
 *  <li> 
 *  <code>DOWN</code>
 *  Returns scroll delta that will bottom justify the scrollRect
 *  with the first element that spans or is below the scrollRect's
 *  bottom edge.
 *  </li>
 * 
 *  <li> 
 *  <code>END</code>
 *  Returns scroll delta that will bottom justify the scrollRect
 *  to the content area.
 *  </li>
 *  
 *  <li> 
 *  <code>HOME</code>
 *  Returns scroll delta that will top justify the scrollRect
 *  to the content area.
 *  </li>
 * 
 *  <li> 
 *  <code>PAGE_DOWN</code>
 *  Returns scroll delta that will top justify the scrollRect
 *  with the first element that spans or is below the scrollRect's
 *  bottom edge.
 *  </li>
 * 
 *  <code>PAGE_UP</code>
 *  <li>
 *  Returns scroll delta that will bottom justify the scrollRect
 *  with the first element that spans or is above the scrollRect's
 *  top edge.
 *  </li>
 *
 *  <li> 
 *  <code>UP</code>
 *  Returns scroll delta that will top justify the scrollRect
 *  with the first element that spans or is above the scrollRect's
 *  top edge.
 *  </li>
 *
 *  </ul>
 * 
 *  <p>The implementation calls <code>getElementBoundsAboveScrollRect()</code> and
 *  <code>getElementBoundsBelowScrollRect()</code> to determine the bounds of
 *  the elements. Layout classes usually override those methods instead of
 *  the <code>getVerticalScrollPositionDelta()</code> method. </p>
 *
 *  @asreturn The change to the vertical scroll position.
 * 
 *  @see spark.core.NavigationUnit
 *  @see #getElementBoundsAboveScrollRect()
 *  @see #getElementBoundsBelowScrollRect()
 *  @see #getVerticalScrollPositionDelta()
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 * @param {number} navigationUnit
 * @return {number}
 */
spark.layouts.supportClasses.LayoutBase.prototype.getVerticalScrollPositionDelta = function(navigationUnit) {
  var /** @type {spark.components.supportClasses.GroupBase} */ g = this.target;
  if (!g)
    return 0;
  var /** @type {org.apache.royale.geom.Rectangle} */ scrollRect = this.getScrollRect();
  if (!scrollRect)
    return 0;
  if ((scrollRect.y == 0) && (scrollRect.height >= g.contentHeight))
    return 0;
  var /** @type {number} */ maxDelta = g.contentHeight - scrollRect.bottom;
  var /** @type {number} */ minDelta = -scrollRect.top;
  var /** @type {org.apache.royale.geom.Rectangle} */ getElementBounds;
  switch (navigationUnit) {
    case spark.core.NavigationUnit.UP:
    
    case spark.core.NavigationUnit.PAGE_UP:
      getElementBounds = this.getElementBoundsAboveScrollRect(scrollRect);
      break;
    case spark.core.NavigationUnit.DOWN:
    
    case spark.core.NavigationUnit.PAGE_DOWN:
      getElementBounds = this.getElementBoundsBelowScrollRect(scrollRect);
      break;
    case spark.core.NavigationUnit.HOME:
      return minDelta;
    case spark.core.NavigationUnit.END:
      return maxDelta;
    default:
      return 0;
  }
  if (!getElementBounds)
    return 0;
  var /** @type {number} */ delta = 0;
  switch (navigationUnit) {
    case spark.core.NavigationUnit.UP:
      delta = Math.max(getElementBounds.top - scrollRect.top, -scrollRect.height);
      break;
    case spark.core.NavigationUnit.DOWN:
      delta = Math.min(getElementBounds.bottom - scrollRect.bottom, scrollRect.height);
      break;
    case spark.core.NavigationUnit.PAGE_UP:
      delta = getElementBounds.bottom - scrollRect.bottom;
      if (delta >= 0)
        delta = Math.max(getElementBounds.top - scrollRect.top, -scrollRect.height);
      break;
    case spark.core.NavigationUnit.PAGE_DOWN:
      delta = getElementBounds.top - scrollRect.top;
      if (delta <= 0)
        delta = Math.min(getElementBounds.bottom - scrollRect.bottom, scrollRect.height);
      break;
  }
  return Math.min(maxDelta, Math.max(minDelta, delta));
};


/**
 *  Computes the <code>verticalScrollPosition</code> and 
 *  <code>horizontalScrollPosition</code> deltas needed to 
 *  scroll the element at the specified index into view.
 * 
 *  <p>This method attempts to minimize the change to <code>verticalScrollPosition</code>
 *  and <code>horizontalScrollPosition</code>.</p>
 * 
 *  <p>If <code>clipAndEnableScrolling</code> is <code>true</code> 
 *  and the element at the specified index is not
 *  entirely visible relative to the target's scroll rectangle, then 
 *  return the delta to be added to <code>horizontalScrollPosition</code> and
 *  <code>verticalScrollPosition</code> that scrolls the element completely 
 *  within the scroll rectangle's bounds.</p>
 * 
 *  @asparam index The index of the element to be scrolled into view.
 *
 *  @asreturn A Point that contains offsets to horizontalScrollPosition 
 *      and verticalScrollPosition that will scroll the specified
 *      element into view, or null if no change is needed. 
 *      If the specified element is partially visible and larger than the
 *      scroll rectangle, meaning it is already the only element visible, then
 *      return null.
 *      If the specified index is invalid, or target is null, then
 *      return null.
 *      If the element at the specified index is null or includeInLayout
 *      false, then return null.
 * 
 *  @see #clipAndEnableScrolling
 *  @see #verticalScrollPosition
 *  @see #horizontalScrollPosition
 *  @see #updateScrollRect()
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 * @param {number} index
 * @return {org.apache.royale.geom.Point}
 */
spark.layouts.supportClasses.LayoutBase.prototype.getScrollPositionDeltaToElement = function(index) {
  return this.http_$$www_adobe_com$2006$flex$mx$internal__getScrollPositionDeltaToElementHelper(index);
};


/**
 *  @asprivate 
 *  For the offset properties, a value of NaN means don't offset from that edge. A value
 *  of 0 means to put the element flush against that edge.
 * 
 *  @asparam topOffset Number of pixels to position the element below the top edge.
 *  @asparam bottomOffset Number of pixels to position the element above the bottom edge.
 *  @asparam leftOffset Number of pixels to position the element to the right of the left edge.
 *  @asparam rightOffset Number of pixels to position the element to the left of the right edge.
 * @export
 * @param {number} index
 * @param {number=} topOffset
 * @param {number=} bottomOffset
 * @param {number=} leftOffset
 * @param {number=} rightOffset
 * @return {org.apache.royale.geom.Point}
 */
spark.layouts.supportClasses.LayoutBase.prototype.http_$$www_adobe_com$2006$flex$mx$internal__getScrollPositionDeltaToElementHelper = function(index, topOffset, bottomOffset, leftOffset, rightOffset) {
  topOffset = typeof topOffset !== 'undefined' ? topOffset : NaN;
  bottomOffset = typeof bottomOffset !== 'undefined' ? bottomOffset : NaN;
  leftOffset = typeof leftOffset !== 'undefined' ? leftOffset : NaN;
  rightOffset = typeof rightOffset !== 'undefined' ? rightOffset : NaN;
  var /** @type {org.apache.royale.geom.Rectangle} */ elementR = this.getElementBounds(index);
  return this.getScrollPositionDeltaToElementHelperHelper(elementR, null, true, topOffset, bottomOffset, leftOffset, rightOffset);
};


/**
 *  @asprivate 
 *  This takes an element rather than an index so it can be used for
 *  DataGrid which has rows and columns.
 * 
 *  For the offset properties, a value of NaN means don't offset from that edge. A value
 *  of 0 means to put the element flush against that edge.
 * 
 *  @asparam elementR The bounds of the element to position
 *  @asparam elementLocalBounds The bounds inside of the element to position
 *  @asparam entireElementVisible If true, position the entire element in the viewable area
 *  @asparam topOffset Number of pixels to position the element below the top edge.
 *  @asparam bottomOffset Number of pixels to position the element above the bottom edge.
 *  @asparam leftOffset Number of pixels to position the element to the right of the left edge.
 *  @asparam rightOffset Number of pixels to position the element to the left of the right edge.
 * @protected
 * @param {org.apache.royale.geom.Rectangle} elementR
 * @param {org.apache.royale.geom.Rectangle} elementLocalBounds
 * @param {boolean=} entireElementVisible
 * @param {number=} topOffset
 * @param {number=} bottomOffset
 * @param {number=} leftOffset
 * @param {number=} rightOffset
 * @return {org.apache.royale.geom.Point}
 */
spark.layouts.supportClasses.LayoutBase.prototype.getScrollPositionDeltaToElementHelperHelper = function(elementR, elementLocalBounds, entireElementVisible, topOffset, bottomOffset, leftOffset, rightOffset) {
  entireElementVisible = typeof entireElementVisible !== 'undefined' ? entireElementVisible : true;
  topOffset = typeof topOffset !== 'undefined' ? topOffset : NaN;
  bottomOffset = typeof bottomOffset !== 'undefined' ? bottomOffset : NaN;
  leftOffset = typeof leftOffset !== 'undefined' ? leftOffset : NaN;
  rightOffset = typeof rightOffset !== 'undefined' ? rightOffset : NaN;
  if (!elementR)
    return null;
  var /** @type {org.apache.royale.geom.Rectangle} */ scrollR = this.getScrollRect();
  if (!scrollR)
    return null;
  if (isNaN(topOffset) && isNaN(bottomOffset) && isNaN(leftOffset) && isNaN(rightOffset) && (scrollR.containsRect(elementR) || (!elementLocalBounds && elementR.containsRect(scrollR))))
    return null;
  var /** @type {number} */ dx = 0;
  var /** @type {number} */ dy = 0;
  if (entireElementVisible) {
    var /** @type {number} */ dxl = elementR.left - scrollR.left;
    var /** @type {number} */ dxr = elementR.right - scrollR.right;
    var /** @type {number} */ dyt = elementR.top - scrollR.top;
    var /** @type {number} */ dyb = elementR.bottom - scrollR.bottom;
    dx = (Math.abs(dxl) < Math.abs(dxr)) ? dxl : dxr;
    dy = (Math.abs(dyt) < Math.abs(dyb)) ? dyt : dyb;
    if (!isNaN(topOffset))
      dy = dyt + topOffset;
    else if (!isNaN(bottomOffset))
      dy = dyb - bottomOffset;
    if (!isNaN(leftOffset))
      dx = dxl + leftOffset;
    else if (!isNaN(rightOffset))
      dx = dxr - rightOffset;
    if ((elementR.left >= scrollR.left) && (elementR.right <= scrollR.right))
      dx = 0;
    else if ((elementR.bottom <= scrollR.bottom) && (elementR.top >= scrollR.top))
      dy = 0;
    if ((elementR.left <= scrollR.left) && (elementR.right >= scrollR.right))
      dx = 0;
    else if ((elementR.bottom >= scrollR.bottom) && (elementR.top <= scrollR.top))
      dy = 0;
  }
  if (elementLocalBounds) {
    if (elementR.width > scrollR.width || !entireElementVisible) {
      if (elementLocalBounds.left < scrollR.left)
        dx = elementLocalBounds.left - scrollR.left;
      else if (elementLocalBounds.right > scrollR.right)
        dx = elementLocalBounds.right - scrollR.right;
    }
    if (elementR.height > scrollR.height || !entireElementVisible) {
      if (elementLocalBounds.bottom > scrollR.bottom)
        dy = elementLocalBounds.bottom - scrollR.bottom;
      else if (elementLocalBounds.top <= scrollR.top)
        dy = elementLocalBounds.top - scrollR.top;
    }
  }
  return new org.apache.royale.geom.Point(dx, dy);
};


/**
 *  @asprivate
 * @export
 * @param {mx.core.IVisualElement} element
 * @param {org.apache.royale.geom.Rectangle=} elementLocalBounds
 * @param {boolean=} entireElementVisible
 * @param {number=} topOffset
 * @param {number=} bottomOffset
 * @param {number=} leftOffset
 * @param {number=} rightOffset
 * @return {org.apache.royale.geom.Point}
 */
spark.layouts.supportClasses.LayoutBase.prototype.http_$$www_adobe_com$2006$flex$mx$internal__getScrollPositionDeltaToAnyElement = function(element, elementLocalBounds, entireElementVisible, topOffset, bottomOffset, leftOffset, rightOffset) {
  elementLocalBounds = typeof elementLocalBounds !== 'undefined' ? elementLocalBounds : null;
  entireElementVisible = typeof entireElementVisible !== 'undefined' ? entireElementVisible : true;
  topOffset = typeof topOffset !== 'undefined' ? topOffset : NaN;
  bottomOffset = typeof bottomOffset !== 'undefined' ? bottomOffset : NaN;
  leftOffset = typeof leftOffset !== 'undefined' ? leftOffset : NaN;
  rightOffset = typeof rightOffset !== 'undefined' ? rightOffset : NaN;
  var /** @type {org.apache.royale.geom.Rectangle} */ elementR = this.http_$$www_adobe_com$2006$flex$mx$internal__getChildElementBounds(element);
  if (elementLocalBounds)
    elementLocalBounds = this.spark_layouts_supportClasses_LayoutBase_convertLocalToTarget(element, elementLocalBounds);
  return this.getScrollPositionDeltaToElementHelperHelper(elementR, elementLocalBounds, entireElementVisible, topOffset, bottomOffset, leftOffset, rightOffset);
};


/**
 *  @asprivate
 * 
 *  Given an x\y position and a compare point 
 *  (topLeft/topRight/bottomRight/bottomLeft/center), returns the element 
 *  who's compare point is closest to the position. 
 *  For example, the position might be in the bounds of element A, but 
 *  closer to the topLeft corner of element B than to the topLeft corner 
 *  of element A. 
 *  In which case, this function would return the index for element B. 
 * @export
 * @param {org.apache.royale.geom.Point} position
 * @param {string=} elementComparePoint
 * @return {number}
 */
spark.layouts.supportClasses.LayoutBase.prototype.http_$$www_adobe_com$2006$flex$mx$internal__getElementNearestScrollPosition = function(position, elementComparePoint) {
  elementComparePoint = typeof elementComparePoint !== 'undefined' ? elementComparePoint : "center";
  var /** @type {number} */ i = 0;
  var /** @type {number} */ dist = 0;
  var /** @type {number} */ num = this.target.numElements;
  var /** @type {number} */ minDistance = Number.MAX_VALUE;
  var /** @type {number} */ minDistanceElement = -1;
  //var /** @type {number} */ i = 0;
  var /** @type {org.apache.royale.geom.Rectangle} */ rect;
  //var /** @type {number} */ dist = 0;
  for (i = 0; i < num; i++) {
    rect = this.getElementBounds(i);
    if (rect != null) {
      var /** @type {org.apache.royale.geom.Point} */ elementPoint = null;
      switch (elementComparePoint) {
        case "topLeft":
          elementPoint = rect.topLeft;
          break;
        case "bottomRight":
          elementPoint = rect.bottomRight;
          break;
        case "bottomLeft":
          elementPoint = new org.apache.royale.geom.Point(rect.left, rect.bottom);
          break;
        case "topRight":
          elementPoint = new org.apache.royale.geom.Point(rect.right, rect.top);
          break;
        case "center":
          elementPoint = new org.apache.royale.geom.Point(rect.left + rect.width / 2, rect.top + rect.height / 2);
          break;
      }
      dist = (org.apache.royale.geom.Point.distance(position, elementPoint)) >> 0;
      if (dist < minDistance) {
        minDistance = dist;
        minDistanceElement = i;
      }
    }
  }
  return minDistanceElement;
};


/**
 * @private
 * @type {org.apache.royale.geom.Point}
 */
spark.layouts.supportClasses.LayoutBase.prototype.spark_layouts_supportClasses_LayoutBase__dragScrollDelta;


/**
 * @type {number}
 */
spark.layouts.supportClasses.LayoutBase.prototype.http_$$www_adobe_com$2006$flex$mx$internal__dragScrollRegionSizeHorizontal = 20;


/**
 * @type {number}
 */
spark.layouts.supportClasses.LayoutBase.prototype.http_$$www_adobe_com$2006$flex$mx$internal__dragScrollRegionSizeVertical = 20;


/**
 * @type {number}
 */
spark.layouts.supportClasses.LayoutBase.prototype.http_$$www_adobe_com$2006$flex$mx$internal__dragScrollSpeed = 5;


/**
 * @type {number}
 */
spark.layouts.supportClasses.LayoutBase.prototype.http_$$www_adobe_com$2006$flex$mx$internal__dragScrollInitialDelay = 250;


/**
 * @type {number}
 */
spark.layouts.supportClasses.LayoutBase.prototype.http_$$www_adobe_com$2006$flex$mx$internal__dragScrollInterval = 32;


/**
 * @type {boolean}
 */
spark.layouts.supportClasses.LayoutBase.prototype.http_$$www_adobe_com$2006$flex$mx$internal__dragScrollHidesIndicator = false;


/**
 *  Sizes, positions and parents the drop indicator based on the specified
 *  drop location. Use the <code>calculateDropLocation()</code> method
 *  to obtain the DropLocation object.
 *
 *  <p>Starts/stops drag-scrolling when necessary conditions are met.</p>
 * 
 *  @asparam dropLocation Specifies the location where to show the drop indicator.
 *  Drop location is obtained through the <code>computeDropLocation()</code> method.
 *
 *  @see #dropIndicator 
 *  @see #hideDropIndicator()
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 * @param {spark.layouts.supportClasses.DropLocation} dropLocation
 */
spark.layouts.supportClasses.LayoutBase.prototype.showDropIndicator = function(dropLocation) {
  if (!this.spark_layouts_supportClasses_LayoutBase__dropIndicator)
    return;
  this.spark_layouts_supportClasses_LayoutBase__dropIndicator.visible = false;
  var /** @type {org.apache.royale.geom.Rectangle} */ bounds = this.calculateDropIndicatorBounds(dropLocation);
  if (!bounds)
    return;
  if (org.apache.royale.utils.Language.is(this.spark_layouts_supportClasses_LayoutBase__dropIndicator, mx.core.ILayoutElement)) {
    var /** @type {mx.core.ILayoutElement} */ element = org.apache.royale.utils.Language.as(this.spark_layouts_supportClasses_LayoutBase__dropIndicator, mx.core.ILayoutElement, true);
    element.setLayoutBoundsSize(bounds.width, bounds.height);
    element.setLayoutBoundsPosition(bounds.x, bounds.y);
  } else {
    this.spark_layouts_supportClasses_LayoutBase__dropIndicator.width = bounds.width;
    this.spark_layouts_supportClasses_LayoutBase__dropIndicator.height = bounds.height;
    this.spark_layouts_supportClasses_LayoutBase__dropIndicator.x = bounds.x;
    this.spark_layouts_supportClasses_LayoutBase__dropIndicator.y = bounds.y;
  }
  this.spark_layouts_supportClasses_LayoutBase__dropIndicator.visible = true;
};


/**
 *  Hides the previously shown drop indicator, 
 *  created by the <code>showDropIndicator()</code> method,
 *  removes it from the display list and also stops the drag scrolling.
 *
 *  @see #showDropIndicator()
 *  @see #dropIndicator
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 */
spark.layouts.supportClasses.LayoutBase.prototype.hideDropIndicator = function() {
  if (this.spark_layouts_supportClasses_LayoutBase__dropIndicator)
    this.spark_layouts_supportClasses_LayoutBase__dropIndicator.visible = false;
};


/**
 *  Returns the index where a new item should be inserted if
 *  the user releases the mouse at the specified coordinates
 *  while completing a drag and drop gesture.
 * 
 *  Called by the <code>calculatedDropLocation()</code> method.
 *
 *  @asparam x The x coordinate of the drag and drop gesture, in 
 *  local coordinates.
 * 
 *  @asparam y The y coordinate of the drag and drop gesture, in  
 *  the drop target's local coordinates.
 *
 *  @asreturn The drop index or -1 if the drop operation is not available
 *  at the specified coordinates.
 * 
 *  @see #calculateDropLocation()
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @protected
 * @param {number} x
 * @param {number} y
 * @return {number}
 */
spark.layouts.supportClasses.LayoutBase.prototype.calculateDropIndex = function(x, y) {
  return this.target.numElements;
};


/**
 *  Calculates the bounds for the drop indicator that provides visual feedback
 *  to the user of where the items will be inserted at the end of a drag and drop
 *  gesture.
 * 
 *  Called by the <code>showDropIndicator()</code> method.
 * 
 *  @asparam dropLocation A valid DropLocation object previously returned 
 *  by the <code>calculateDropLocation()</code> method.
 * 
 *  @asreturn The bounds for the drop indicator or null.
 * 
 *  @see spark.layouts.supportClasses.DropLocation
 *  @see #calculateDropIndex()
 *  @see #calculateDragScrollDelta()
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @protected
 * @param {spark.layouts.supportClasses.DropLocation} dropLocation
 * @return {org.apache.royale.geom.Rectangle}
 */
spark.layouts.supportClasses.LayoutBase.prototype.calculateDropIndicatorBounds = function(dropLocation) {
  return null;
};


/**
 *  @asprivate
 *  Work-around the Player globalToLocal and scrollRect changing before
 *  a frame is updated. 
 * @private
 * @param {number} x
 * @param {number} y
 * @return {org.apache.royale.geom.Point}
 */
spark.layouts.supportClasses.LayoutBase.prototype.spark_layouts_supportClasses_LayoutBase_globalToLocal = function(x, y) {
  var /** @type {spark.components.supportClasses.GroupBase} */ layoutTarget = this.target;
  var /** @type {org.apache.royale.core.UIBase} */ parent = org.apache.royale.utils.Language.as(layoutTarget.parent, org.apache.royale.core.UIBase);
  var /** @type {org.apache.royale.geom.Point} */ local = org.apache.royale.utils.PointUtils.globalToLocal(new org.apache.royale.geom.Point(x, y), parent);
  local.x -= layoutTarget.x;
  local.y -= layoutTarget.y;
  var /** @type {org.apache.royale.geom.Rectangle} */ scrollRect = this.getScrollRect();
  if (scrollRect) {
    local.x += scrollRect.x;
    local.y += scrollRect.y;
  }
  return local;
};


/**
 * @private
 * @type {org.apache.royale.events.EventDispatcher}
 */
spark.layouts.supportClasses.LayoutBase.prototype.spark_layouts_supportClasses_LayoutBase_ed;


/**
 * @export
 * @param {string} type
 * @return {boolean}
 */
spark.layouts.supportClasses.LayoutBase.prototype.hasEventListener = function(type) {
  return this.spark_layouts_supportClasses_LayoutBase_ed.hasEventListener(type);
};


/**
 * @export
 * @param {Object} event
 * @return {boolean}
 */
spark.layouts.supportClasses.LayoutBase.prototype.dispatchEvent = function(event) {
  return this.spark_layouts_supportClasses_LayoutBase_ed.dispatchEvent(event);
};


/**
 * @export
 * @param {string} type
 * @param {Function} handler
 * @param {boolean=} opt_capture
 * @param {Object=} opt_handlerScope
 */
spark.layouts.supportClasses.LayoutBase.prototype.addEventListener = function(type, handler, opt_capture, opt_handlerScope) {
  opt_capture = typeof opt_capture !== 'undefined' ? opt_capture : false;
  opt_handlerScope = typeof opt_handlerScope !== 'undefined' ? opt_handlerScope : null;
  this.spark_layouts_supportClasses_LayoutBase_ed.addEventListener(type, handler, opt_capture, opt_handlerScope);
};


/**
 * @export
 * @param {string} type
 * @param {Function} handler
 * @param {boolean=} opt_capture
 * @param {Object=} opt_handlerScope
 */
spark.layouts.supportClasses.LayoutBase.prototype.removeEventListener = function(type, handler, opt_capture, opt_handlerScope) {
  opt_capture = typeof opt_capture !== 'undefined' ? opt_capture : false;
  opt_handlerScope = typeof opt_handlerScope !== 'undefined' ? opt_handlerScope : null;
  this.spark_layouts_supportClasses_LayoutBase_ed.removeEventListener(type, handler, opt_capture, opt_handlerScope);
};


/**
 * @export
 * @override
 */
spark.layouts.supportClasses.LayoutBase.prototype.layout = function() {
  var /** @type {number} */ n = this.layoutView.numElements;
  if (n == 0)
    return false;
  var /** @type {number} */ w = this.target.width;
  var /** @type {number} */ h = this.target.height;
  if (this.isHeightSizedToContent())
    h = this.target.measuredHeight;
  if (this.isWidthSizedToContent())
    w = this.target.measuredWidth;
  this.updateDisplayList(w, h);
  if (this.isWidthSizedToContent() && this.isHeightSizedToContent()) {
    this.target.setActualSize(this.target.getExplicitOrMeasuredWidth(), this.target.getExplicitOrMeasuredHeight());
  }
  else if (this.isWidthSizedToContent())
    this.target.setWidth(this.target.getExplicitOrMeasuredWidth());
  else if (this.isHeightSizedToContent())
    this.target.setHeight(this.target.getExplicitOrMeasuredHeight());
  return true;
};


/**
 * @export
 * @return {boolean}
 */
spark.layouts.supportClasses.LayoutBase.prototype.isHeightSizedToContent = function() {
  return this.target.isHeightSizedToContent();
};


/**
 * @export
 * @return {boolean}
 */
spark.layouts.supportClasses.LayoutBase.prototype.isWidthSizedToContent = function() {
  if (org.apache.royale.utils.Language.is(this.target.parent, spark.components.Group)) {
    var /** @type {spark.components.Group} */ parentGroup = org.apache.royale.utils.Language.as(this.target.parent, spark.components.Group);
    if (org.apache.royale.utils.Language.is(parentGroup.layout, spark.layouts.VerticalLayout)) {
      var /** @type {spark.layouts.VerticalLayout} */ parentLayout = org.apache.royale.utils.Language.as(parentGroup.layout, spark.layouts.VerticalLayout);
      if (parentLayout.horizontalAlign == spark.layouts.HorizontalAlign.JUSTIFY)
        return false;
    }
  }
  return this.target.isWidthSizedToContent();
};


spark.layouts.supportClasses.LayoutBase.prototype.set__strand = function(value) {
  this.spark_layouts_supportClasses_LayoutBase__target = org.apache.royale.utils.Language.as(value, spark.components.supportClasses.GroupBase);
  spark.layouts.supportClasses.LayoutBase.superClass_.set__strand.apply(this, [ value] );
};


spark.layouts.supportClasses.LayoutBase.prototype.get__target = function() {
  return this.spark_layouts_supportClasses_LayoutBase__target;
};


spark.layouts.supportClasses.LayoutBase.prototype.set__target = function(value) {
  if (this.spark_layouts_supportClasses_LayoutBase__target == value)
    return;
  this.clearVirtualLayoutCache();
  this.spark_layouts_supportClasses_LayoutBase__target = value;
};


spark.layouts.supportClasses.LayoutBase.prototype.get__useVirtualLayout = function() {
  return this.spark_layouts_supportClasses_LayoutBase__useVirtualLayout;
};


spark.layouts.supportClasses.LayoutBase.prototype.set__useVirtualLayout = function(value) {
  if (this.spark_layouts_supportClasses_LayoutBase__useVirtualLayout == value)
    return;
  this.dispatchEvent(new org.apache.royale.events.Event("useVirtualLayoutChanged"));
  if (this.spark_layouts_supportClasses_LayoutBase__useVirtualLayout && !value)
    this.clearVirtualLayoutCache();
  this.spark_layouts_supportClasses_LayoutBase__useVirtualLayout = value;
};


spark.layouts.supportClasses.LayoutBase.prototype.http_$$www_adobe_com$2006$flex$mx$internal__get__virtualLayoutSupported = function() {
  return true;
};


spark.layouts.supportClasses.LayoutBase.prototype.get__horizontalScrollPosition = function() {
  return this.spark_layouts_supportClasses_LayoutBase__horizontalScrollPosition;
};


spark.layouts.supportClasses.LayoutBase.prototype.bindable__set__horizontalScrollPosition_spark_layouts_supportClasses_LayoutBase = function(value) {
  if (value == this.spark_layouts_supportClasses_LayoutBase__horizontalScrollPosition)
    return;
  this.spark_layouts_supportClasses_LayoutBase__horizontalScrollPosition = value;
  this.scrollPositionChanged();
};


spark.layouts.supportClasses.LayoutBase.prototype.set__horizontalScrollPosition = function(value) {
var oldValue = this.get__horizontalScrollPosition();
if (oldValue != value) {
this.bindable__set__horizontalScrollPosition_spark_layouts_supportClasses_LayoutBase(value);
    this.dispatchEvent(org.apache.royale.events.ValueChangeEvent.createUpdateEvent(
         this, "horizontalScrollPosition", oldValue, value));
}
};


spark.layouts.supportClasses.LayoutBase.prototype.get__verticalScrollPosition = function() {
  return this.spark_layouts_supportClasses_LayoutBase__verticalScrollPosition;
};


spark.layouts.supportClasses.LayoutBase.prototype.bindable__set__verticalScrollPosition_spark_layouts_supportClasses_LayoutBase = function(value) {
  if (value == this.spark_layouts_supportClasses_LayoutBase__verticalScrollPosition)
    return;
  this.spark_layouts_supportClasses_LayoutBase__verticalScrollPosition = value;
  this.scrollPositionChanged();
};


spark.layouts.supportClasses.LayoutBase.prototype.set__verticalScrollPosition = function(value) {
var oldValue = this.get__verticalScrollPosition();
if (oldValue != value) {
this.bindable__set__verticalScrollPosition_spark_layouts_supportClasses_LayoutBase(value);
    this.dispatchEvent(org.apache.royale.events.ValueChangeEvent.createUpdateEvent(
         this, "verticalScrollPosition", oldValue, value));
}
};


spark.layouts.supportClasses.LayoutBase.prototype.get__clipAndEnableScrolling = function() {
  return this.spark_layouts_supportClasses_LayoutBase__clipAndEnableScrolling;
};


spark.layouts.supportClasses.LayoutBase.prototype.set__clipAndEnableScrolling = function(value) {
  if (value == this.spark_layouts_supportClasses_LayoutBase__clipAndEnableScrolling)
    return;
  this.spark_layouts_supportClasses_LayoutBase__clipAndEnableScrolling = value;
  var /** @type {spark.components.supportClasses.GroupBase} */ g = this.target;
  if (g)
    this.updateScrollRect(g.width, g.height);
};


spark.layouts.supportClasses.LayoutBase.prototype.get__typicalLayoutElement = function() {
  if (!this.spark_layouts_supportClasses_LayoutBase__typicalLayoutElement && this.target && (this.target.numElements > 0))
    this.spark_layouts_supportClasses_LayoutBase__typicalLayoutElement = org.apache.royale.utils.Language.as(this.target.getElementAt(0), mx.core.ILayoutElement);
  return this.spark_layouts_supportClasses_LayoutBase__typicalLayoutElement;
};


spark.layouts.supportClasses.LayoutBase.prototype.set__typicalLayoutElement = function(value) {
  if (this.spark_layouts_supportClasses_LayoutBase__typicalLayoutElement == value)
    return;
  this.spark_layouts_supportClasses_LayoutBase__typicalLayoutElement = value;
};


spark.layouts.supportClasses.LayoutBase.prototype.get__dropIndicator = function() {
  return this.spark_layouts_supportClasses_LayoutBase__dropIndicator;
};


spark.layouts.supportClasses.LayoutBase.prototype.set__dropIndicator = function(value) {
  this.spark_layouts_supportClasses_LayoutBase__dropIndicator = value;
};


Object.defineProperties(spark.layouts.supportClasses.LayoutBase.prototype, /** @lends {spark.layouts.supportClasses.LayoutBase.prototype} */ {
/**
  * @export
  * @type {org.apache.royale.core.IStrand} */
strand: {
set: spark.layouts.supportClasses.LayoutBase.prototype.set__strand},
/**
  * @export
  * @type {spark.components.supportClasses.GroupBase} */
target: {
get: spark.layouts.supportClasses.LayoutBase.prototype.get__target,
set: spark.layouts.supportClasses.LayoutBase.prototype.set__target},
/**
  * @export
  * @type {boolean} */
useVirtualLayout: {
get: spark.layouts.supportClasses.LayoutBase.prototype.get__useVirtualLayout,
set: spark.layouts.supportClasses.LayoutBase.prototype.set__useVirtualLayout},
/**
  * @export
  * @type {boolean} */
http_$$www_adobe_com$2006$flex$mx$internal__virtualLayoutSupported: {
get: spark.layouts.supportClasses.LayoutBase.prototype.http_$$www_adobe_com$2006$flex$mx$internal__get__virtualLayoutSupported},
/**
  * @export
  * @type {number} */
horizontalScrollPosition: {
get: spark.layouts.supportClasses.LayoutBase.prototype.get__horizontalScrollPosition,
set: spark.layouts.supportClasses.LayoutBase.prototype.set__horizontalScrollPosition},
/**
  * @export
  * @type {number} */
verticalScrollPosition: {
get: spark.layouts.supportClasses.LayoutBase.prototype.get__verticalScrollPosition,
set: spark.layouts.supportClasses.LayoutBase.prototype.set__verticalScrollPosition},
/**
  * @export
  * @type {boolean} */
clipAndEnableScrolling: {
get: spark.layouts.supportClasses.LayoutBase.prototype.get__clipAndEnableScrolling,
set: spark.layouts.supportClasses.LayoutBase.prototype.set__clipAndEnableScrolling},
/**
  * @export
  * @type {mx.core.ILayoutElement} */
typicalLayoutElement: {
get: spark.layouts.supportClasses.LayoutBase.prototype.get__typicalLayoutElement,
set: spark.layouts.supportClasses.LayoutBase.prototype.set__typicalLayoutElement},
/**
  * @export
  * @type {org.apache.royale.core.UIBase} */
dropIndicator: {
get: spark.layouts.supportClasses.LayoutBase.prototype.get__dropIndicator,
set: spark.layouts.supportClasses.LayoutBase.prototype.set__dropIndicator}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
spark.layouts.supportClasses.LayoutBase.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'LayoutBase', qName: 'spark.layouts.supportClasses.LayoutBase', kind: 'class' }], interfaces: [org.apache.royale.events.IEventDispatcher] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
spark.layouts.supportClasses.LayoutBase.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        'http://www.adobe.com/2006/flex/mx/internal::dragScrollRegionSizeHorizontal': { type: 'Number', get_set: function (/** spark.layouts.supportClasses.LayoutBase */ inst, /** * */ v) {return v !== undefined ? inst.http_$$www_adobe_com$2006$flex$mx$internal__dragScrollRegionSizeHorizontal = v : inst.http_$$www_adobe_com$2006$flex$mx$internal__dragScrollRegionSizeHorizontal;}},
        'http://www.adobe.com/2006/flex/mx/internal::dragScrollRegionSizeVertical': { type: 'Number', get_set: function (/** spark.layouts.supportClasses.LayoutBase */ inst, /** * */ v) {return v !== undefined ? inst.http_$$www_adobe_com$2006$flex$mx$internal__dragScrollRegionSizeVertical = v : inst.http_$$www_adobe_com$2006$flex$mx$internal__dragScrollRegionSizeVertical;}},
        'http://www.adobe.com/2006/flex/mx/internal::dragScrollSpeed': { type: 'Number', get_set: function (/** spark.layouts.supportClasses.LayoutBase */ inst, /** * */ v) {return v !== undefined ? inst.http_$$www_adobe_com$2006$flex$mx$internal__dragScrollSpeed = v : inst.http_$$www_adobe_com$2006$flex$mx$internal__dragScrollSpeed;}},
        'http://www.adobe.com/2006/flex/mx/internal::dragScrollInitialDelay': { type: 'int', get_set: function (/** spark.layouts.supportClasses.LayoutBase */ inst, /** * */ v) {return v !== undefined ? inst.http_$$www_adobe_com$2006$flex$mx$internal__dragScrollInitialDelay = v : inst.http_$$www_adobe_com$2006$flex$mx$internal__dragScrollInitialDelay;}},
        'http://www.adobe.com/2006/flex/mx/internal::dragScrollInterval': { type: 'int', get_set: function (/** spark.layouts.supportClasses.LayoutBase */ inst, /** * */ v) {return v !== undefined ? inst.http_$$www_adobe_com$2006$flex$mx$internal__dragScrollInterval = v : inst.http_$$www_adobe_com$2006$flex$mx$internal__dragScrollInterval;}},
        'http://www.adobe.com/2006/flex/mx/internal::dragScrollHidesIndicator': { type: 'Boolean', get_set: function (/** spark.layouts.supportClasses.LayoutBase */ inst, /** * */ v) {return v !== undefined ? inst.http_$$www_adobe_com$2006$flex$mx$internal__dragScrollHidesIndicator = v : inst.http_$$www_adobe_com$2006$flex$mx$internal__dragScrollHidesIndicator;}}
      };
    },
    accessors: function () {
      return {
        'strand': { type: 'org.apache.royale.core.IStrand', access: 'writeonly', declaredBy: 'spark.layouts.supportClasses.LayoutBase'},
        'target': { type: 'spark.components.supportClasses.GroupBase', access: 'readwrite', declaredBy: 'spark.layouts.supportClasses.LayoutBase'},
        'useVirtualLayout': { type: 'Boolean', access: 'readwrite', declaredBy: 'spark.layouts.supportClasses.LayoutBase'},
        'http://www.adobe.com/2006/flex/mx/internal::virtualLayoutSupported': { type: 'Boolean', access: 'readonly', declaredBy: 'spark.layouts.supportClasses.LayoutBase'},
        'horizontalScrollPosition': { type: 'Number', access: 'readwrite', declaredBy: 'spark.layouts.supportClasses.LayoutBase', metadata: function () { return [ { name: 'Bindable' } ]; }},
        'verticalScrollPosition': { type: 'Number', access: 'readwrite', declaredBy: 'spark.layouts.supportClasses.LayoutBase', metadata: function () { return [ { name: 'Bindable' } ]; }},
        'clipAndEnableScrolling': { type: 'Boolean', access: 'readwrite', declaredBy: 'spark.layouts.supportClasses.LayoutBase'},
        'typicalLayoutElement': { type: 'mx.core.ILayoutElement', access: 'readwrite', declaredBy: 'spark.layouts.supportClasses.LayoutBase'},
        'dropIndicator': { type: 'org.apache.royale.core.UIBase', access: 'readwrite', declaredBy: 'spark.layouts.supportClasses.LayoutBase'}
      };
    },
    methods: function () {
      return {
        'LayoutBase': { type: '', declaredBy: 'spark.layouts.supportClasses.LayoutBase'},
        'clearVirtualLayoutCache': { type: 'void', declaredBy: 'spark.layouts.supportClasses.LayoutBase'},
        'measure': { type: 'void', declaredBy: 'spark.layouts.supportClasses.LayoutBase'},
        'updateDisplayList': { type: 'void', declaredBy: 'spark.layouts.supportClasses.LayoutBase', parameters: function () { return [ 'Number', false ,'Number', false ]; }},
        'elementAdded': { type: 'void', declaredBy: 'spark.layouts.supportClasses.LayoutBase', parameters: function () { return [ 'int', false ]; }},
        'elementRemoved': { type: 'void', declaredBy: 'spark.layouts.supportClasses.LayoutBase', parameters: function () { return [ 'int', false ]; }},
        'updateScrollRect': { type: 'void', declaredBy: 'spark.layouts.supportClasses.LayoutBase', parameters: function () { return [ 'Number', false ,'Number', false ]; }},
        'getNavigationDestinationIndex': { type: 'int', declaredBy: 'spark.layouts.supportClasses.LayoutBase', parameters: function () { return [ 'int', false ,'uint', false ,'Boolean', false ]; }},
        'getElementBounds': { type: 'org.apache.royale.geom.Rectangle', declaredBy: 'spark.layouts.supportClasses.LayoutBase', parameters: function () { return [ 'int', false ]; }},
        'http://www.adobe.com/2006/flex/mx/internal::getChildElementBounds': { type: 'org.apache.royale.geom.Rectangle', declaredBy: 'spark.layouts.supportClasses.LayoutBase', parameters: function () { return [ 'mx.core.IVisualElement', false ]; }},
        'http://www.adobe.com/2006/flex/mx/internal::isElementVisible': { type: 'Boolean', declaredBy: 'spark.layouts.supportClasses.LayoutBase', parameters: function () { return [ 'mx.core.ILayoutElement', false ]; }},
        'getHorizontalScrollPositionDelta': { type: 'Number', declaredBy: 'spark.layouts.supportClasses.LayoutBase', parameters: function () { return [ 'uint', false ]; }},
        'getVerticalScrollPositionDelta': { type: 'Number', declaredBy: 'spark.layouts.supportClasses.LayoutBase', parameters: function () { return [ 'uint', false ]; }},
        'getScrollPositionDeltaToElement': { type: 'org.apache.royale.geom.Point', declaredBy: 'spark.layouts.supportClasses.LayoutBase', parameters: function () { return [ 'int', false ]; }},
        'http://www.adobe.com/2006/flex/mx/internal::getScrollPositionDeltaToElementHelper': { type: 'org.apache.royale.geom.Point', declaredBy: 'spark.layouts.supportClasses.LayoutBase', parameters: function () { return [ 'int', false ,'Number', true ,'Number', true ,'Number', true ,'Number', true ]; }},
        'http://www.adobe.com/2006/flex/mx/internal::getScrollPositionDeltaToAnyElement': { type: 'org.apache.royale.geom.Point', declaredBy: 'spark.layouts.supportClasses.LayoutBase', parameters: function () { return [ 'mx.core.IVisualElement', false ,'org.apache.royale.geom.Rectangle', true ,'Boolean', true ,'Number', true ,'Number', true ,'Number', true ,'Number', true ]; }},
        'http://www.adobe.com/2006/flex/mx/internal::getElementNearestScrollPosition': { type: 'int', declaredBy: 'spark.layouts.supportClasses.LayoutBase', parameters: function () { return [ 'org.apache.royale.geom.Point', false ,'String', true ]; }},
        'showDropIndicator': { type: 'void', declaredBy: 'spark.layouts.supportClasses.LayoutBase', parameters: function () { return [ 'spark.layouts.supportClasses.DropLocation', false ]; }},
        'hideDropIndicator': { type: 'void', declaredBy: 'spark.layouts.supportClasses.LayoutBase'},
        'hasEventListener': { type: 'Boolean', declaredBy: 'spark.layouts.supportClasses.LayoutBase', parameters: function () { return [ 'String', false ]; }},
        'dispatchEvent': { type: 'Boolean', declaredBy: 'spark.layouts.supportClasses.LayoutBase', parameters: function () { return [ 'Object', false ]; }},
        'addEventListener': { type: 'void', declaredBy: 'spark.layouts.supportClasses.LayoutBase', parameters: function () { return [ 'String', false ,'Function', false ,'Boolean', true ,'Object', true ]; }},
        'removeEventListener': { type: 'void', declaredBy: 'spark.layouts.supportClasses.LayoutBase', parameters: function () { return [ 'String', false ,'Function', false ,'Boolean', true ,'Object', true ]; }},
        'layout': { type: 'Boolean', declaredBy: 'spark.layouts.supportClasses.LayoutBase'},
        'isHeightSizedToContent': { type: 'Boolean', declaredBy: 'spark.layouts.supportClasses.LayoutBase'},
        'isWidthSizedToContent': { type: 'Boolean', declaredBy: 'spark.layouts.supportClasses.LayoutBase'}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
spark.layouts.supportClasses.LayoutBase.prototype.ROYALE_COMPILE_FLAGS = 10;

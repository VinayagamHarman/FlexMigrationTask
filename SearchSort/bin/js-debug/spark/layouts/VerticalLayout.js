/**
 * Generated by Apache Royale Compiler from spark/layouts/VerticalLayout.as
 * spark.layouts.VerticalLayout
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('spark.layouts.VerticalLayout');
/* Royale Dependency List: mx.containers.utilityClasses.Flex,mx.core.ILayoutElement,mx.core.IVisualElement,mx.core.mx_internal,mx.events.PropertyChangeEvent,org.apache.royale.events.Event,org.apache.royale.geom.Point,org.apache.royale.geom.Rectangle,spark.components.supportClasses.GroupBase,spark.core.NavigationUnit,spark.layouts.HorizontalAlign,spark.layouts.VerticalAlign,spark.layouts.supportClasses.DropLocation,spark.layouts.supportClasses.LayoutElementHelper,spark.layouts.supportClasses.LinearLayoutVector,org.apache.royale.utils.Language,XML*/
goog.provide('spark.layouts.VerticalLayout.LayoutElementFlexChildInfo');
goog.provide('spark.layouts.VerticalLayout.SizesAndLimit');

goog.require('mx.containers.utilityClasses.FlexChildInfo');
goog.require('spark.layouts.supportClasses.LayoutBase');
goog.require('spark.core.IGapLayout');



/**
 *  Constructor. 
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @constructor
 * @extends {spark.layouts.supportClasses.LayoutBase}
 * @implements {spark.core.IGapLayout}
 */
spark.layouts.VerticalLayout = function() {
  
  this.spark_layouts_VerticalLayout__horizontalAlign = spark.layouts.HorizontalAlign.LEFT;
  this.spark_layouts_VerticalLayout__verticalAlign = spark.layouts.VerticalAlign.TOP;
  spark.layouts.VerticalLayout.base(this, 'constructor');
  this.http_$$www_adobe_com$2006$flex$mx$internal__dragScrollRegionSizeHorizontal = 0;
};
goog.inherits(spark.layouts.VerticalLayout, spark.layouts.supportClasses.LayoutBase);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('spark.layouts.VerticalLayout', spark.layouts.VerticalLayout);


/**
 * @private
 * @type {spark.layouts.supportClasses.LinearLayoutVector}
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout_llv;


/**
 * @private
 * @param {mx.core.ILayoutElement} layoutElement
 * @param {number} width
 * @return {number}
 */
spark.layouts.VerticalLayout.calculatePercentWidth = function(layoutElement, width) {
  var /** @type {number} */ percentWidth;
  percentWidth = spark.layouts.supportClasses.LayoutElementHelper.pinBetween(Math.min(Math.round(layoutElement.percentWidth * 0.01 * width), width), layoutElement.getMinBoundsWidth(), layoutElement.getMaxBoundsWidth());
  return percentWidth;
};


/**
 * @private
 * @param {mx.core.ILayoutElement} layoutElement
 * @param {number} width
 * @param {string} horizontalAlign
 * @param {number} restrictedWidth
 * @param {number} height
 * @param {boolean} variableRowHeight
 * @param {number} rowHeight
 */
spark.layouts.VerticalLayout.sizeLayoutElement = function(layoutElement, width, horizontalAlign, restrictedWidth, height, variableRowHeight, rowHeight) {
  var /** @type {number} */ newWidth = NaN;
  if (horizontalAlign == spark.layouts.HorizontalAlign.JUSTIFY || horizontalAlign == spark.layouts.HorizontalAlign.CONTENT_JUSTIFY) {
    newWidth = restrictedWidth;
  } else {
    if (!isNaN(layoutElement.percentWidth))
      newWidth = spark.layouts.VerticalLayout.calculatePercentWidth(layoutElement, width);
  }
  if (variableRowHeight)
    layoutElement.setLayoutBoundsSize(newWidth, height);
  else
    layoutElement.setLayoutBoundsSize(newWidth, rowHeight);
};


/**
 * @private
 * @type {number}
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout__gap = 6;


/**
 * @private
 * @type {number}
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout__rowCount = -1;


/**
 *  @asprivate
 * 
 *  Sets the <code>rowCount</code> property and dispatches a
 *  PropertyChangeEvent.
 * @export
 * @param {number} value
 */
spark.layouts.VerticalLayout.prototype.http_$$www_adobe_com$2006$flex$mx$internal__setRowCount = function(value) {
  if (this.spark_layouts_VerticalLayout__rowCount == value)
    return;
  var /** @type {number} */ oldValue = this.spark_layouts_VerticalLayout__rowCount;
  this.spark_layouts_VerticalLayout__rowCount = value;
  this.dispatchEvent(mx.events.PropertyChangeEvent.createUpdateEvent(this, "rowCount", oldValue, value));
};


/**
 * @private
 * @type {string}
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout__horizontalAlign;


/**
 * @private
 * @type {string}
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout__verticalAlign;


/**
 * @private
 * @type {number}
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout__padding = 0;


/**
 * @private
 * @type {number}
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout__paddingLeft = 0;


/**
 * @private
 * @type {number}
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout__paddingRight = 0;


/**
 * @private
 * @type {number}
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout__paddingTop = 0;


/**
 * @private
 * @type {number}
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout__paddingBottom = 0;


/**
 * @private
 * @type {number}
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout__requestedMaxRowCount = -1;


/**
 * @private
 * @type {number}
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout__requestedMinRowCount = -1;


/**
 * @private
 * @type {number}
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout__requestedRowCount = -1;


/**
 * @private
 * @type {number}
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout__rowHeight;


/**
 * @private
 * @type {boolean}
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout__variableRowHeight = true;


/**
 * @private
 * @type {number}
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout__firstIndexInView = -1;


/**
 * @private
 * @type {number}
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout__lastIndexInView = -1;


/**
 *  Sets the <code>firstIndexInView</code> and <code>lastIndexInView</code>
 *  properties and dispatches a <code>"indexInViewChanged"</code>
 *  event.  
 * 
 *  @asparam firstIndex The new value for firstIndexInView.
 *  @asparam lastIndex The new value for lastIndexInView.
 * 
 *  @see firstIndexInView
 *  @see lastIndexInview
 *  
 *  @asprivate
 * @export
 * @param {number} firstIndex
 * @param {number} lastIndex
 */
spark.layouts.VerticalLayout.prototype.http_$$www_adobe_com$2006$flex$mx$internal__setIndexInView = function(firstIndex, lastIndex) {
  if ((this.spark_layouts_VerticalLayout__firstIndexInView == firstIndex) && (this.spark_layouts_VerticalLayout__lastIndexInView == lastIndex))
    return;
  this.spark_layouts_VerticalLayout__firstIndexInView = firstIndex;
  this.spark_layouts_VerticalLayout__lastIndexInView = lastIndex;
  this.dispatchEvent(new org.apache.royale.events.Event("indexInViewChanged"));
};


/**
 * @asprivate
 * @export
 * @override
 */
spark.layouts.VerticalLayout.prototype.clearVirtualLayoutCache = function() {
  this.spark_layouts_VerticalLayout_llv = null;
  var /** @type {spark.components.supportClasses.GroupBase} */ g = org.apache.royale.utils.Language.as(this.target, spark.components.supportClasses.GroupBase, true);
  if (!g)
    return;
};


/**
 *  @asprivate
 * @export
 * @override
 */
spark.layouts.VerticalLayout.prototype.getElementBounds = function(index) {
  if (!this.useVirtualLayout)
    return spark.layouts.VerticalLayout.superClass_.getElementBounds.apply(this, [ index] );
  var /** @type {spark.components.supportClasses.GroupBase} */ g = org.apache.royale.utils.Language.as(this.target, spark.components.supportClasses.GroupBase, true);
  if (!g || (index < 0) || (index >= g.numElements) || !this.spark_layouts_VerticalLayout_llv)
    return null;
  this.spark_layouts_VerticalLayout_updateLLV(g);
  return this.spark_layouts_VerticalLayout_llv.getBounds((index) >>> 0);
};


/**
 *  Returns 1.0 if the specified index is completely in view, 0.0 if
 *  it's not, or a value between 0.0 and 1.0 that represents the percentage 
 *  of the if the index that is partially in view.
 * 
 *  <p>An index is "in view" if the corresponding non-null layout element is 
 *  within the vertical limits of the container's <code>scrollRect</code>
 *  and included in the layout.</p>
 *  
 *  <p>If the specified index is partially within the view, the 
 *  returned value is the percentage of the corresponding
 *  layout element that's visible.</p>
 *
 *  @asparam index The index of the row.
 * 
 *  @asreturn The percentage of the specified element that's in view.
 *  Returns 0.0 if the specified index is invalid or if it corresponds to
 *  null element, or a ILayoutElement for which 
 *  the <code>includeInLayout</code> property is <code>false</code>.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 * @param {number} index
 * @return {number}
 */
spark.layouts.VerticalLayout.prototype.fractionOfElementInView = function(index) {
  var /** @type {spark.components.supportClasses.GroupBase} */ g = org.apache.royale.utils.Language.as(this.target, spark.components.supportClasses.GroupBase, true);
  if (!g)
    return 0.0;
  if ((index < 0) || (index >= g.numElements))
    return 0.0;
  if (!this.clipAndEnableScrolling)
    return 1.0;
  var /** @type {number} */ r0 = this.firstIndexInView;
  var /** @type {number} */ r1 = this.lastIndexInView;
  if ((r0 == -1) || (r1 == -1) || (index < r0) || (index > r1))
    return 0.0;
  if ((index > r0) && (index < r1))
    return 1.0;
  var /** @type {number} */ eltY;
  var /** @type {number} */ eltHeight;
  if (this.useVirtualLayout) {
    if (!this.spark_layouts_VerticalLayout_llv)
      return 0.0;
    eltY = this.spark_layouts_VerticalLayout_llv.start((index) >>> 0);
    eltHeight = this.spark_layouts_VerticalLayout_llv.getMajorSize((index) >>> 0);
  } else {
    var /** @type {mx.core.ILayoutElement} */ elt = org.apache.royale.utils.Language.as(g.getElementAt(index), mx.core.ILayoutElement);
    if (!elt || !elt.includeInLayout)
      return 0.0;
    eltY = elt.getLayoutBoundsY();
    eltHeight = elt.getLayoutBoundsHeight();
  }
  var /** @type {number} */ y0 = g.verticalScrollPosition;
  var /** @type {number} */ y1 = y0 + g.height;
  var /** @type {number} */ iy0 = eltY;
  var /** @type {number} */ iy1 = iy0 + eltHeight;
  if (iy0 >= iy1)
    return 1.0;
  if ((iy0 >= y0) && (iy1 <= y1))
    return 1.0;
  return (Math.min(y1, iy1) - Math.max(y0, iy0)) / (iy1 - iy0);
};


/**
 *  @asprivate
 * 
 *  Binary search for the first layout element that contains y.  
 * 
 *  This function considers both the element's actual bounds and 
 *  the gap that follows it to be part of the element.  The search 
 *  covers index i0 through i1 (inclusive).
 *  
 *  This function is intended for variable height elements.
 * 
 *  Returns the index of the element that contains y, or -1.
 * @private
 * @param {number} y
 * @param {number} gap
 * @param {spark.components.supportClasses.GroupBase} g
 * @param {number} i0
 * @param {number} i1
 * @return {number}
 */
spark.layouts.VerticalLayout.findIndexAt = function(y, gap, g, i0, i1) {
  var /** @type {number} */ index = ((i0 + i1) / 2) >> 0;
  var /** @type {mx.core.ILayoutElement} */ element = org.apache.royale.utils.Language.as(org.apache.royale.utils.Language.as(g.getElementAt(index), mx.core.ILayoutElement), mx.core.ILayoutElement);
  var /** @type {number} */ elementY = element.getLayoutBoundsY();
  var /** @type {number} */ elementHeight = element.getLayoutBoundsHeight();
  if ((y >= elementY) && (y < elementY + elementHeight + gap))
    return index;
  else if (i0 == i1)
    return -1;
  else if (y < elementY)
    return spark.layouts.VerticalLayout.findIndexAt(y, gap, g, i0, (Math.max(i0, index - 1)) >> 0);
  else
    return spark.layouts.VerticalLayout.findIndexAt(y, gap, g, (Math.min(index + 1, i1)) >> 0, i1);
};


/**
 *  @asprivate
 * 
 *  Returns the index of the first non-null includeInLayout element, 
 *  beginning with the element at index i.  
 * 
 *  Returns -1 if no such element can be found.
 * @private
 * @param {spark.components.supportClasses.GroupBase} g
 * @param {number} i
 * @param {number} dir
 * @return {number}
 */
spark.layouts.VerticalLayout.findLayoutElementIndex = function(g, i, dir) {
  var /** @type {number} */ n = g.numElements;
  while ((i >= 0) && (i < n)) {
    var /** @type {mx.core.ILayoutElement} */ element = org.apache.royale.utils.Language.as(g.getElementAt(i), mx.core.ILayoutElement);
    if (element && element.includeInLayout) {
      return i;
    }
    i += dir;
  }
  return -1;
};


/**
 *  @asprivate
 * 
 *  Updates the first,lastIndexInView properties per the new
 *  scroll position.
 *  
 *  @see setIndexInView
 * @protected
 * @override
 */
spark.layouts.VerticalLayout.prototype.scrollPositionChanged = function() {
  var /** @type {number} */ i0 = 0;
  var /** @type {number} */ i1 = 0;
  spark.layouts.VerticalLayout.superClass_.scrollPositionChanged.apply(this);
  var /** @type {spark.components.supportClasses.GroupBase} */ g = this.target;
  if (!g)
    return;
  var /** @type {number} */ n = (g.numElements - 1) >> 0;
  if (n < 0) {
    this.http_$$www_adobe_com$2006$flex$mx$internal__setIndexInView(-1, -1);
    return;
  }
  var /** @type {org.apache.royale.geom.Rectangle} */ scrollR = this.getScrollRect();
  if (!scrollR) {
    this.http_$$www_adobe_com$2006$flex$mx$internal__setIndexInView(0, n);
    return;
  }
  var /** @type {number} */ y0 = scrollR.top;
  var /** @type {number} */ y1 = scrollR.bottom - .0001;
  if (y1 <= y0) {
    this.http_$$www_adobe_com$2006$flex$mx$internal__setIndexInView(-1, -1);
    return;
  }
  if (this.useVirtualLayout && !this.spark_layouts_VerticalLayout_llv) {
    this.http_$$www_adobe_com$2006$flex$mx$internal__setIndexInView(-1, -1);
    return;
  }
  //var /** @type {number} */ i0 = 0;
  //var /** @type {number} */ i1 = 0;
  if (this.useVirtualLayout) {
    i0 = this.spark_layouts_VerticalLayout_llv.indexOf(y0);
    i1 = this.spark_layouts_VerticalLayout_llv.indexOf(y1);
  } else {
    i0 = spark.layouts.VerticalLayout.findIndexAt(y0 + this.gap, this.gap, g, 0, n);
    i1 = spark.layouts.VerticalLayout.findIndexAt(y1, this.gap, g, 0, n);
  }
  if (i0 == -1) {
    var /** @type {number} */ index0 = spark.layouts.VerticalLayout.findLayoutElementIndex(g, 0, 1);
    if (index0 != -1) {
      var /** @type {mx.core.ILayoutElement} */ element0 = org.apache.royale.utils.Language.as(g.getElementAt(index0), mx.core.ILayoutElement);
      var /** @type {number} */ element0Y = element0.getLayoutBoundsY();
      var /** @type {number} */ elementHeight = element0.getLayoutBoundsHeight();
      if ((element0Y < y1) && ((element0Y + elementHeight) > y0))
        i0 = index0;
    }
  }
  if (i1 == -1) {
    var /** @type {number} */ index1 = spark.layouts.VerticalLayout.findLayoutElementIndex(g, n, -1);
    if (index1 != -1) {
      var /** @type {mx.core.ILayoutElement} */ element1 = org.apache.royale.utils.Language.as(g.getElementAt(index1), mx.core.ILayoutElement);
      var /** @type {number} */ element1Y = element1.getLayoutBoundsY();
      var /** @type {number} */ element1Height = element1.getLayoutBoundsHeight();
      if ((element1Y < y1) && ((element1Y + element1Height) > y0))
        i1 = index1;
    }
  }
  if (this.useVirtualLayout) {
    var /** @type {mx.core.ILayoutElement} */ firstElement = org.apache.royale.utils.Language.as(g.getElementAt(this.spark_layouts_VerticalLayout__firstIndexInView), mx.core.ILayoutElement);
    var /** @type {mx.core.ILayoutElement} */ lastElement = org.apache.royale.utils.Language.as(g.getElementAt(this.spark_layouts_VerticalLayout__lastIndexInView), mx.core.ILayoutElement);
    var /** @type {org.apache.royale.geom.Rectangle} */ scrollRect = this.getScrollRect();
  }
  this.http_$$www_adobe_com$2006$flex$mx$internal__setIndexInView(i0, i1);
};


/**
 *  @asprivate
 * 
 *  Returns the actual position/size Rectangle of the first partially 
 *  visible or not-visible, non-null includeInLayout element, beginning
 *  with the element at index i, searching in direction dir (dir must
 *  be +1 or -1).   The last argument is the GroupBase scrollRect, it's
 *  guaranteed to be non-null.
 * 
 *  Returns null if no such element can be found.
 * @private
 * @param {spark.components.supportClasses.GroupBase} g
 * @param {number} i
 * @param {number} dir
 * @param {org.apache.royale.geom.Rectangle} r
 * @return {org.apache.royale.geom.Rectangle}
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout_findLayoutElementBounds = function(g, i, dir, r) {
  var /** @type {number} */ n = g.numElements;
  if (this.fractionOfElementInView(i) >= 1) {
    i += dir;
    if (i < 0)
      return new org.apache.royale.geom.Rectangle(0, 0, 0, this.paddingTop);
    if (i >= n)
      return new org.apache.royale.geom.Rectangle(0, this.getElementBounds((n - 1) >> 0).bottom, 0, this.paddingBottom);
  }
  while ((i >= 0) && (i < n)) {
    var /** @type {org.apache.royale.geom.Rectangle} */ elementR = this.getElementBounds(i);
    if (elementR) {
      var /** @type {boolean} */ overlapsTop = (dir == -1) && (elementR.top == r.top) && (elementR.bottom >= r.bottom);
      var /** @type {boolean} */ overlapsBottom = (dir == +1) && (elementR.bottom == r.bottom) && (elementR.top <= r.top);
      if (!(overlapsTop || overlapsBottom))
        return elementR;
    }
    i += dir;
  }
  return null;
};


/**
 *  @asprivate 
 * @protected
 * @override
 */
spark.layouts.VerticalLayout.prototype.getElementBoundsAboveScrollRect = function(scrollRect) {
  return this.spark_layouts_VerticalLayout_findLayoutElementBounds(this.target, this.firstIndexInView, -1, scrollRect);
};


/**
 *  @asprivate 
 * @protected
 * @override
 */
spark.layouts.VerticalLayout.prototype.getElementBoundsBelowScrollRect = function(scrollRect) {
  return this.spark_layouts_VerticalLayout_findLayoutElementBounds(this.target, this.lastIndexInView, 1, scrollRect);
};


/**
 *  @asprivate
 *  Fills in the result with preferred and min sizes of the element.
 * @private
 * @param {mx.core.ILayoutElement} element
 * @param {boolean} justify
 * @param {spark.layouts.VerticalLayout.SizesAndLimit} result
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout_getElementWidth = function(element, justify, result) {
  var /** @type {number} */ elementPreferredWidth = Math.ceil(element.getPreferredBoundsWidth());
  var /** @type {boolean} */ flexibleWidth = !isNaN(element.percentWidth) || justify;
  var /** @type {number} */ elementMinWidth = flexibleWidth ? Math.ceil(element.getMinBoundsWidth()) : elementPreferredWidth;
  result.preferredSize = elementPreferredWidth;
  result.minSize = elementMinWidth;
};


/**
 *  @asprivate
 *  Fills in the result with preferred and min sizes of the element.
 * @private
 * @param {mx.core.ILayoutElement} element
 * @param {number} fixedRowHeight
 * @param {spark.layouts.VerticalLayout.SizesAndLimit} result
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout_getElementHeight = function(element, fixedRowHeight, result) {
  var /** @type {number} */ elementPreferredHeight = isNaN(fixedRowHeight) ? Math.ceil(element.getPreferredBoundsHeight()) : fixedRowHeight;
  var /** @type {boolean} */ flexibleHeight = !isNaN(element.percentHeight);
  var /** @type {number} */ elementMinHeight = flexibleHeight ? Math.ceil(element.getMinBoundsHeight()) : elementPreferredHeight;
  result.preferredSize = elementPreferredHeight;
  result.minSize = elementMinHeight;
};


/**
 *  @asprivate
 *  @asreturn rows to measure based on elements in layout and any requested/min/max rowCount settings. 
 * @export
 * @param {number} numElementsInLayout
 * @return {number}
 */
spark.layouts.VerticalLayout.prototype.http_$$www_adobe_com$2006$flex$mx$internal__getRowsToMeasure = function(numElementsInLayout) {
  var /** @type {number} */ rowsToMeasure = 0;
  //var /** @type {number} */ rowsToMeasure = 0;
  if (this.requestedRowCount != -1)
    rowsToMeasure = this.requestedRowCount; else {
    rowsToMeasure = numElementsInLayout;
    if (this.requestedMaxRowCount != -1)
      rowsToMeasure = (Math.min(this.requestedMaxRowCount, rowsToMeasure)) >> 0;
    if (this.requestedMinRowCount != -1)
      rowsToMeasure = (Math.max(this.requestedMinRowCount, rowsToMeasure)) >> 0;
  }
  return rowsToMeasure;
};


/**
 *  @asprivate
 * 
 *  Compute exact values for measuredWidth,Height and measuredMinWidth,Height.
 * 
 *  Measure each of the layout elements.  If requestedRowCount >= 0 we 
 *  consider the height and width of as many layout elements, padding with 
 *  typicalLayoutElement if needed, starting with index 0. We then only 
 *  consider the width of the elements remaining.
 * 
 *  If requestedRowCount is -1, we measure all of the layout elements.
 * @private
 * @param {spark.components.supportClasses.GroupBase} layoutTarget
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout_measureReal = function(layoutTarget) {
  var /** @type {spark.layouts.VerticalLayout.SizesAndLimit} */ size = new spark.layouts.VerticalLayout.SizesAndLimit();
  var /** @type {boolean} */ justify = this.horizontalAlign == spark.layouts.HorizontalAlign.JUSTIFY;
  var /** @type {number} */ numElements = layoutTarget.numElements;
  var /** @type {number} */ numElementsInLayout = numElements;
  var /** @type {number} */ requestedRowCount = this.requestedRowCount;
  var /** @type {number} */ rowsMeasured = 0;
  var /** @type {number} */ preferredHeight = 0;
  var /** @type {number} */ preferredWidth = 0;
  var /** @type {number} */ minHeight = 0;
  var /** @type {number} */ minWidth = 0;
  var /** @type {number} */ fixedRowHeight = NaN;
  if (!this.variableRowHeight)
    fixedRowHeight = this.rowHeight;
  var /** @type {number} */ rowsToMeasure = this.http_$$www_adobe_com$2006$flex$mx$internal__getRowsToMeasure(numElementsInLayout);
  var /** @type {mx.core.ILayoutElement} */ element;
  for (var /** @type {number} */ i = 0; i < numElements; i++) {
    element = org.apache.royale.utils.Language.as(layoutTarget.getElementAt(i), mx.core.ILayoutElement);
    if (!element || !element.includeInLayout) {
      numElementsInLayout--;
      continue;
    }
    if (rowsMeasured < rowsToMeasure) {
      this.spark_layouts_VerticalLayout_getElementHeight(element, fixedRowHeight, size);
      preferredHeight += size.preferredSize;
      minHeight += size.minSize;
      rowsMeasured++;
    }
    this.spark_layouts_VerticalLayout_getElementWidth(element, justify, size);
    preferredWidth = Math.max(preferredWidth, size.preferredSize);
    minWidth = Math.max(minWidth, size.minSize);
  }
  rowsToMeasure = this.http_$$www_adobe_com$2006$flex$mx$internal__getRowsToMeasure(numElementsInLayout);
  if (rowsMeasured < rowsToMeasure) {
    element = this.typicalLayoutElement;
    if (element) {
      this.spark_layouts_VerticalLayout_getElementHeight(element, fixedRowHeight, size);
      preferredHeight += size.preferredSize * (rowsToMeasure - rowsMeasured);
      minHeight += size.minSize * (rowsToMeasure - rowsMeasured);
      this.spark_layouts_VerticalLayout_getElementWidth(element, justify, size);
      preferredWidth = Math.max(preferredWidth, size.preferredSize);
      minWidth = Math.max(minWidth, size.minSize);
      rowsMeasured = rowsToMeasure;
    }
  }
  if (rowsMeasured > 1) {
    var /** @type {number} */ vgap = this.gap * (rowsMeasured - 1);
    preferredHeight += vgap;
    minHeight += vgap;
  }
  var /** @type {number} */ hPadding = this.paddingLeft + this.paddingRight;
  var /** @type {number} */ vPadding = this.paddingTop + this.paddingBottom;
  layoutTarget.measuredHeight = preferredHeight + vPadding;
  layoutTarget.measuredWidth = preferredWidth + hPadding;
  layoutTarget.measuredMinHeight = minHeight + vPadding;
  layoutTarget.measuredMinWidth = minWidth + hPadding;
};


/**
 *  @asprivate
 *  Syncs the LinearLayoutVector llv with typicalLayoutElement and
 *  the target's numElements.  Calling this function accounts
 *  for the possibility that the typicalLayoutElement has changed, or
 *  something that its preferred size depends on has changed.
 * @private
 * @param {spark.components.supportClasses.GroupBase} layoutTarget
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout_updateLLV = function(layoutTarget) {
  if (!this.spark_layouts_VerticalLayout_llv) {
    this.spark_layouts_VerticalLayout_llv = new spark.layouts.supportClasses.LinearLayoutVector();
    this.spark_layouts_VerticalLayout_llv.defaultMinorSize = 71;
    this.spark_layouts_VerticalLayout_llv.defaultMajorSize = 22;
  }
  var /** @type {mx.core.ILayoutElement} */ typicalElt = this.typicalLayoutElement;
  if (typicalElt) {
    var /** @type {number} */ typicalWidth = typicalElt.getPreferredBoundsWidth();
    var /** @type {number} */ typicalHeight = typicalElt.getPreferredBoundsHeight();
    this.spark_layouts_VerticalLayout_llv.defaultMinorSize = typicalWidth;
    this.spark_layouts_VerticalLayout_llv.defaultMajorSize = typicalHeight;
  }
  if (!isNaN(this.spark_layouts_VerticalLayout__rowHeight))
    this.spark_layouts_VerticalLayout_llv.defaultMajorSize = this.spark_layouts_VerticalLayout__rowHeight;
  if (layoutTarget)
    this.spark_layouts_VerticalLayout_llv.length = (layoutTarget.numElements) >>> 0;
  this.spark_layouts_VerticalLayout_llv.gap = this.gap;
  this.spark_layouts_VerticalLayout_llv.majorAxisOffset = this.paddingTop;
};


/**
 *  @asprivate
 * @export
 * @override
 */
spark.layouts.VerticalLayout.prototype.elementAdded = function(index) {
  if (this.spark_layouts_VerticalLayout_llv && (index >= 0) && this.useVirtualLayout)
    this.spark_layouts_VerticalLayout_llv.insert((index) >>> 0);
};


/**
 *  @asprivate
 * @export
 * @override
 */
spark.layouts.VerticalLayout.prototype.elementRemoved = function(index) {
  if (this.spark_layouts_VerticalLayout_llv && (index >= 0) && this.useVirtualLayout)
    this.spark_layouts_VerticalLayout_llv.remove((index) >>> 0);
};


/**
 *  @asprivate
 * 
 *  Compute potentially approximate values for measuredWidth,Height and 
 *  measuredMinWidth,Height.
 * 
 *  This method does not get layout elements from the target except
 *  as a side effect of calling typicalLayoutElement.
 * 
 *  If variableRowHeight="false" then all dimensions are based on 
 *  typicalLayoutElement and the sizes already cached in llv.  The 
 *  llv's defaultMajorSize, minorSize, and minMinorSize 
 *  are based on typicalLayoutElement.
 * @private
 * @param {spark.components.supportClasses.GroupBase} layoutTarget
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout_measureVirtual = function(layoutTarget) {
  var /** @type {number} */ eltCount = layoutTarget.numElements;
  var /** @type {number} */ measuredEltCount = this.http_$$www_adobe_com$2006$flex$mx$internal__getRowsToMeasure(eltCount);
  var /** @type {number} */ hPadding = this.paddingLeft + this.paddingRight;
  var /** @type {number} */ vPadding = this.paddingTop + this.paddingBottom;
  if (measuredEltCount <= 0) {
    layoutTarget.measuredWidth = layoutTarget.measuredMinWidth = hPadding;
    layoutTarget.measuredHeight = layoutTarget.measuredMinHeight = vPadding;
    return;
  }
  this.spark_layouts_VerticalLayout_updateLLV(layoutTarget);
  if (this.variableRowHeight) {
    var /** @type {number} */ oldLength = -1;
    if (measuredEltCount > this.spark_layouts_VerticalLayout_llv.length) {
      oldLength = (this.spark_layouts_VerticalLayout_llv.length) >> 0;
      this.spark_layouts_VerticalLayout_llv.length = (measuredEltCount) >>> 0;
    }
    var /** @type {number} */ measuredHeight = this.spark_layouts_VerticalLayout_llv.end((measuredEltCount - 1) >>> 0) + this.paddingBottom;
    layoutTarget.measuredHeight = measuredHeight;
    if (oldLength != -1)
      this.spark_layouts_VerticalLayout_llv.length = (oldLength) >>> 0;
  } else {
    var /** @type {number} */ vgap = (measuredEltCount > 1) ? (measuredEltCount - 1) * this.gap : 0;
    layoutTarget.measuredHeight = (measuredEltCount * this.rowHeight) + vgap + vPadding;
  }
  layoutTarget.measuredWidth = this.spark_layouts_VerticalLayout_llv.minorSize + hPadding;
  layoutTarget.measuredMinWidth = (this.horizontalAlign == spark.layouts.HorizontalAlign.JUSTIFY) ? this.spark_layouts_VerticalLayout_llv.minMinorSize + hPadding : layoutTarget.measuredWidth;
  layoutTarget.measuredMinHeight = layoutTarget.measuredHeight;
};


/**
 *  @asprivate
 * 
 *  If requestedRowCount is specified then as many layout elements
 *  or "rows" are measured, starting with element 0, otherwise all of the 
 *  layout elements are measured.
 *  
 *  If requestedRowCount is specified and is greater than the
 *  number of layout elements, then the typicalLayoutElement is used
 *  in place of the missing layout elements.
 * 
 *  If variableRowHeight="true", then the layoutTarget's measuredHeight 
 *  is the sum of preferred heights of the layout elements, plus the sum of the
 *  gaps between elements, and its measuredWidth is the max of the elements' 
 *  preferred widths.
 * 
 *  If variableRowHeight="false", then the layoutTarget's measuredHeight 
 *  is rowHeight multiplied by the number or layout elements, plus the 
 *  sum of the gaps between elements.
 * 
 *  The layoutTarget's measuredMinHeight is the sum of the minHeights of 
 *  layout elements that have specified a value for the percentHeight
 *  property, and the preferredHeight of the elements that have not, 
 *  plus the sum of the gaps between elements.
 * 
 *  The difference reflects the fact that elements which specify 
 *  percentHeight are considered to be "flexible" and updateDisplayList 
 *  will give flexible components at least their minHeight.  
 * 
 *  Layout elements that aren't flexible always get their preferred height.
 * 
 *  The layoutTarget's measuredMinWidth is the max of the minWidths for 
 *  elements that have specified percentWidth (that are "flexible") and the 
 *  preferredWidth of the elements that have not.
 * 
 *  As before the difference is due to the fact that flexible items are only
 *  guaranteed their minWidth.
 * @export
 * @override
 */
spark.layouts.VerticalLayout.prototype.measure = function() {
  var /** @type {spark.components.supportClasses.GroupBase} */ layoutTarget = this.target;
  if (!layoutTarget)
    return;
  if (this.useVirtualLayout)
    this.spark_layouts_VerticalLayout_measureVirtual(layoutTarget);
  else
    this.spark_layouts_VerticalLayout_measureReal(layoutTarget);
  layoutTarget.measuredWidth = Math.ceil(layoutTarget.measuredWidth);
  layoutTarget.measuredHeight = Math.ceil(layoutTarget.measuredHeight);
  layoutTarget.measuredMinWidth = Math.ceil(layoutTarget.measuredMinWidth);
  layoutTarget.measuredMinHeight = Math.ceil(layoutTarget.measuredMinHeight);
};


/**
 *  @asprivate 
 * @export
 * @override
 */
spark.layouts.VerticalLayout.prototype.getNavigationDestinationIndex = function(currentIndex, navigationUnit, arrowKeysWrapFocus) {
  var /** @type {number} */ newIndex = 0;
  if (!this.target || this.target.numElements < 1)
    return -1;
  var /** @type {number} */ maxIndex = (this.target.numElements - 1) >> 0;
  if (currentIndex == -1) {
    if (navigationUnit == spark.core.NavigationUnit.UP)
      return (arrowKeysWrapFocus ? maxIndex : -1) >> 0;
    if (navigationUnit == spark.core.NavigationUnit.DOWN)
      return 0;
  }
  currentIndex = (Math.max(0, Math.min(maxIndex, currentIndex))) >> 0;
  //var /** @type {number} */ newIndex = 0;
  var /** @type {org.apache.royale.geom.Rectangle} */ bounds;
  var /** @type {number} */ y;
  switch (navigationUnit) {
    case spark.core.NavigationUnit.UP:
      if (arrowKeysWrapFocus && currentIndex == 0)
        newIndex = maxIndex;
      else
        newIndex = (currentIndex - 1) >> 0;
      break;
    case spark.core.NavigationUnit.DOWN:
      if (arrowKeysWrapFocus && currentIndex == maxIndex)
        newIndex = 0;
      else
        newIndex = (currentIndex + 1) >> 0;
      break;
    case spark.core.NavigationUnit.PAGE_UP:
      var /** @type {number} */ firstVisible = this.firstIndexInView;
      var /** @type {number} */ firstFullyVisible = firstVisible;
      if (this.fractionOfElementInView(firstFullyVisible) < 1)
        firstFullyVisible += 1;
      if (firstFullyVisible < currentIndex && currentIndex <= this.lastIndexInView)
        newIndex = firstFullyVisible; else {
        if (currentIndex == firstFullyVisible || currentIndex == firstVisible) {
          y = this.getVerticalScrollPositionDelta(spark.core.NavigationUnit.PAGE_UP) + this.getScrollRect().top;
        } else {
          y = this.getElementBounds(currentIndex).bottom - this.getScrollRect().height;
        }
        newIndex = (currentIndex - 1) >> 0;
        while (0 <= newIndex) {
          bounds = this.getElementBounds(newIndex);
          if (bounds && bounds.top < y) {
            newIndex = (Math.min(currentIndex - 1, newIndex + 1)) >> 0;
            break;
          }
          newIndex--;
        }
      }
      break;
    case spark.core.NavigationUnit.PAGE_DOWN:
      var /** @type {number} */ lastVisible = this.lastIndexInView;
      var /** @type {number} */ lastFullyVisible = lastVisible;
      if (this.fractionOfElementInView(lastFullyVisible) < 1)
        lastFullyVisible -= 1;
      if (this.firstIndexInView <= currentIndex && currentIndex < lastFullyVisible)
        newIndex = lastFullyVisible; else {
        if (currentIndex == lastFullyVisible || currentIndex == lastVisible) {
          y = this.getVerticalScrollPositionDelta(spark.core.NavigationUnit.PAGE_DOWN) + this.getScrollRect().bottom;
        } else {
          y = this.getElementBounds(currentIndex).top + this.getScrollRect().height;
        }
        newIndex = (currentIndex + 1) >> 0;
        while (newIndex <= maxIndex) {
          bounds = this.getElementBounds(newIndex);
          if (bounds && bounds.bottom > y) {
            newIndex = (Math.max(currentIndex + 1, newIndex - 1)) >> 0;
            break;
          }
          newIndex++;
        }
      }
      break;
    default:
      return spark.layouts.VerticalLayout.superClass_.getNavigationDestinationIndex.apply(this, [ currentIndex, navigationUnit, arrowKeysWrapFocus] );
  }
  return (Math.max(0, Math.min(maxIndex, newIndex))) >> 0;
};


/**
 *  @asprivate
 * 
 *  Used only for virtual layout.
 * @private
 * @param {mx.core.ILayoutElement} elt
 * @param {number} targetWidth
 * @param {number} containerWidth
 * @return {number}
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout_calculateElementWidth = function(elt, targetWidth, containerWidth) {
  var /** @type {number} */ percentWidth = elt.percentWidth;
  if (!isNaN(percentWidth)) {
    var /** @type {number} */ width = percentWidth * 0.01 * targetWidth;
    return Math.min(targetWidth, Math.min(elt.getMaxBoundsWidth(), Math.max(elt.getMinBoundsWidth(), width)));
  }
  switch (this.horizontalAlign) {
    case spark.layouts.HorizontalAlign.JUSTIFY:
      return targetWidth;
    case spark.layouts.HorizontalAlign.CONTENT_JUSTIFY:
      return Math.max(elt.getPreferredBoundsWidth(), containerWidth);
  }
  return NaN;
};


/**
 *  @asprivate
 * 
 *  Used only for virtual layout.
 * @private
 * @param {mx.core.ILayoutElement} elt
 * @param {number} eltWidth
 * @param {number} containerWidth
 * @return {number}
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout_calculateElementX = function(elt, eltWidth, containerWidth) {
  switch (this.horizontalAlign) {
    case spark.layouts.HorizontalAlign.CENTER:
      return Math.round((containerWidth - eltWidth) * 0.5);
    case spark.layouts.HorizontalAlign.RIGHT:
      return containerWidth - eltWidth;
  }
  return 0;
};


/**
 *  @asprivate
 * 
 *  Update the layout of the virtualized elements that overlap
 *  the scrollRect's vertical extent.
 *
 *  The height of each layout element will be its preferred height, and its
 *  y will be the bottom of the previous item, plus the gap.
 * 
 *  No support for percentHeight, includeInLayout=false, or null layoutElements,
 * 
 *  The width of each layout element will be set to its preferred width, unless
 *  one of the following is true:
 * 
 *  - If percentWidth is specified for this element, then its width will be the
 *  specified percentage of the target's actual (unscaled) width, clipped 
 *  the layout element's minimum and maximum width.
 * 
 *  - If horizontalAlign is "justify", then the element's width will
 *  be set to the target's actual (unscaled) width.
 * 
 *  - If horizontalAlign is "contentJustify", then the element's width
 *  will be set to the larger of the target's width and its content width.
 * 
 *  The X coordinate of each layout element will be set to 0 unless one of the
 *  following is true:
 * 
 *  - If horizontalAlign is "center" then x is set so that the element's preferred
 *  width is centered within the larger of the contentWidth, target width:
 *      x = (Math.max(contentWidth, target.width) - layoutElementWidth) * 0.5
 * 
 *  - If horizontalAlign is "right" the x is set so that the element's right
 *  edge is aligned with the the right edge of the content:
 *      x = (Math.max(contentWidth, target.width) - layoutElementWidth)
 * 
 *  Implementation note: unless horizontalAlign is either "justify" or 
 *  "left", the layout elements' x or width depends on the contentWidth.
 *  The contentWidth is a maximum and although it may be updated to 
 *  different value after all (viewable) elements have been laid out, it
 *  often does not change.  For that reason we use the current contentWidth
 *  for the initial layout and then, if it has changed, we loop through 
 *  the layout items again and fix up the x/width values.
 * @private
 * @param {number} targetWidth
 * @param {number} targetHeight
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout_updateDisplayListVirtual = function(targetWidth, targetHeight) {
  var /** @type {spark.components.supportClasses.GroupBase} */ layoutTarget = this.target;
  var /** @type {number} */ eltCount = layoutTarget.numElements;
  targetWidth = Math.max(0, targetWidth - this.paddingLeft - this.paddingRight);
  var /** @type {number} */ minVisibleY = layoutTarget.verticalScrollPosition;
  var /** @type {number} */ maxVisibleY = minVisibleY + targetHeight;
  var /** @type {number} */ contentHeight;
  var /** @type {number} */ paddedContentHeight;
  this.spark_layouts_VerticalLayout_updateLLV(layoutTarget);
  var /** @type {number} */ startIndex = this.spark_layouts_VerticalLayout_llv.indexOf(Math.max(0, minVisibleY + this.gap));
  if (startIndex == -1) {
    contentHeight = this.spark_layouts_VerticalLayout_llv.end((this.spark_layouts_VerticalLayout_llv.length - 1) >>> 0) - this.paddingTop;
    paddedContentHeight = Math.ceil(contentHeight + this.paddingTop + this.paddingBottom);
    layoutTarget.setContentSize(layoutTarget.contentWidth, paddedContentHeight);
    return;
  }
  var /** @type {number} */ fixedRowHeight = NaN;
  if (!this.variableRowHeight)
    fixedRowHeight = this.rowHeight;
  var /** @type {boolean} */ justifyWidths = this.horizontalAlign == spark.layouts.HorizontalAlign.JUSTIFY;
  var /** @type {number} */ eltWidth = justifyWidths ? targetWidth : NaN;
  var /** @type {number} */ eltHeight = NaN;
  var /** @type {number} */ contentWidth = justifyWidths ? Math.max(this.spark_layouts_VerticalLayout_llv.minMinorSize, targetWidth) : this.spark_layouts_VerticalLayout_llv.minorSize;
  var /** @type {number} */ containerWidth = Math.max(contentWidth, targetWidth);
  var /** @type {number} */ y = this.spark_layouts_VerticalLayout_llv.start((startIndex) >>> 0);
  var /** @type {number} */ index = startIndex;
  var /** @type {number} */ x0 = this.paddingLeft;
  for (; (y < maxVisibleY) && (index < eltCount); index++) {
    var /** @type {mx.core.ILayoutElement} */ elt = layoutTarget.getVirtualElementAt(index, eltWidth, eltHeight);
    var /** @type {number} */ w = this.spark_layouts_VerticalLayout_calculateElementWidth(elt, targetWidth, containerWidth);
    var /** @type {number} */ h = fixedRowHeight;
    elt.setLayoutBoundsSize(w, h);
    w = elt.getLayoutBoundsWidth();
    h = elt.getLayoutBoundsHeight();
    var /** @type {number} */ x = x0 + this.spark_layouts_VerticalLayout_calculateElementX(elt, w, containerWidth);
    elt.setLayoutBoundsPosition(x, y);
    this.spark_layouts_VerticalLayout_llv.cacheDimensions((index) >>> 0, elt);
    y += h + this.gap;
  }
  var /** @type {number} */ endIndex = (index - 1) >> 0;
  if (!justifyWidths && (this.spark_layouts_VerticalLayout_llv.minorSize != contentWidth)) {
    contentWidth = this.spark_layouts_VerticalLayout_llv.minorSize;
    containerWidth = Math.max(contentWidth, targetWidth);
    if (this.horizontalAlign != spark.layouts.HorizontalAlign.LEFT) {
      for (index = startIndex; index <= endIndex; index++) {
        elt = org.apache.royale.utils.Language.as(layoutTarget.getElementAt(index), mx.core.ILayoutElement);
        w = this.spark_layouts_VerticalLayout_calculateElementWidth(elt, targetWidth, containerWidth);
        elt.setLayoutBoundsSize(w, elt.getLayoutBoundsHeight());
        w = elt.getLayoutBoundsWidth();
        x = x0 + this.spark_layouts_VerticalLayout_calculateElementX(elt, w, containerWidth);
        elt.setLayoutBoundsPosition(x, elt.getLayoutBoundsY());
      }
    }
  }
  contentHeight = this.spark_layouts_VerticalLayout_llv.end((this.spark_layouts_VerticalLayout_llv.length - 1) >>> 0) - this.paddingTop;
  var /** @type {number} */ newTargetHeight = Math.max(0, layoutTarget.height - this.paddingTop - this.paddingBottom);
  if (contentHeight < newTargetHeight) {
    var /** @type {number} */ excessHeight = newTargetHeight - contentHeight;
    var /** @type {number} */ dy = 0;
    var /** @type {string} */ vAlign = this.verticalAlign;
    if (vAlign == spark.layouts.VerticalAlign.MIDDLE) {
      dy = Math.round(excessHeight / 2);
    } else if (vAlign == spark.layouts.VerticalAlign.BOTTOM) {
      dy = excessHeight;
    }
    if (dy > 0) {
      for (index = startIndex; index <= endIndex; index++) {
        elt = org.apache.royale.utils.Language.as(layoutTarget.getElementAt(index), mx.core.ILayoutElement);
        elt.setLayoutBoundsPosition(elt.getLayoutBoundsX(), dy + elt.getLayoutBoundsY());
      }
      contentHeight += dy;
    }
  }
  this.http_$$www_adobe_com$2006$flex$mx$internal__setRowCount((index - startIndex) >> 0);
  this.http_$$www_adobe_com$2006$flex$mx$internal__setIndexInView(startIndex, endIndex);
  var /** @type {number} */ paddedContentWidth = Math.ceil(contentWidth + this.paddingLeft + this.paddingRight);
  paddedContentHeight = Math.ceil(contentHeight + this.paddingTop + this.paddingBottom);
  layoutTarget.setContentSize(paddedContentWidth, paddedContentHeight);
};


/**
 *  @asprivate
 * @private
 * @param {number} targetWidth
 * @param {number} targetHeight
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout_updateDisplayListReal = function(targetWidth, targetHeight) {
  var /** @type {spark.components.supportClasses.GroupBase} */ layoutTarget = this.target;
  targetWidth = Math.max(0, targetWidth - this.paddingLeft - this.paddingRight);
  targetHeight = Math.max(0, targetHeight - this.paddingTop - this.paddingBottom);
  var /** @type {mx.core.ILayoutElement} */ layoutElement;
  var /** @type {number} */ count = layoutTarget.numElements;
  var /** @type {number} */ containerWidth = targetWidth;
  if (this.horizontalAlign == spark.layouts.HorizontalAlign.CONTENT_JUSTIFY || (this.clipAndEnableScrolling && (this.horizontalAlign == spark.layouts.HorizontalAlign.CENTER || this.horizontalAlign == spark.layouts.HorizontalAlign.RIGHT))) {
    for (var /** @type {number} */ i = 0; i < count; i++) {
      layoutElement = org.apache.royale.utils.Language.as(layoutTarget.getElementAt(i), mx.core.ILayoutElement);
      if (!layoutElement || !layoutElement.includeInLayout)
        continue;
      var /** @type {number} */ layoutElementWidth;
      if (!isNaN(layoutElement.percentWidth))
        layoutElementWidth = spark.layouts.VerticalLayout.calculatePercentWidth(layoutElement, targetWidth);
      else
        layoutElementWidth = layoutElement.getPreferredBoundsWidth();
      containerWidth = Math.max(containerWidth, Math.ceil(layoutElementWidth));
    }
  }
  var /** @type {number} */ excessHeight = this.spark_layouts_VerticalLayout_distributeHeight(targetWidth, targetHeight, containerWidth);
  var /** @type {number} */ hAlign = 0;
  if (this.horizontalAlign == spark.layouts.HorizontalAlign.CENTER)
    hAlign = .5;
  else if (this.horizontalAlign == spark.layouts.HorizontalAlign.RIGHT)
    hAlign = 1;
  var /** @type {number} */ visibleRows = 0;
  var /** @type {number} */ minVisibleY = layoutTarget.verticalScrollPosition;
  var /** @type {number} */ maxVisibleY = minVisibleY + targetHeight;
  var /** @type {number} */ x0 = this.paddingLeft;
  var /** @type {number} */ y = this.paddingTop;
  var /** @type {number} */ maxX = this.paddingLeft;
  var /** @type {number} */ maxY = this.paddingTop;
  var /** @type {number} */ firstRowInView = -1;
  var /** @type {number} */ lastRowInView = -1;
  if (excessHeight > 0 || !this.clipAndEnableScrolling) {
    var /** @type {string} */ vAlign = this.verticalAlign;
    if (vAlign == spark.layouts.VerticalAlign.MIDDLE) {
      y = this.paddingTop + Math.round(excessHeight / 2);
    } else if (vAlign == spark.layouts.VerticalAlign.BOTTOM) {
      y = this.paddingTop + excessHeight;
    }
  }
  for (var /** @type {number} */ index = 0; index < count; index++) {
    layoutElement = org.apache.royale.utils.Language.as(layoutTarget.getElementAt(index), mx.core.ILayoutElement);
    if (!layoutElement || !layoutElement.includeInLayout)
      continue;
    var /** @type {number} */ dx = Math.ceil(layoutElement.getLayoutBoundsWidth());
    var /** @type {number} */ dy = Math.ceil(layoutElement.getLayoutBoundsHeight());
    var /** @type {number} */ x = x0 + (containerWidth - dx) * hAlign;
    if (hAlign == 0.5)
      x = Math.round(x);
    layoutElement.setLayoutBoundsPosition(x, y);
    maxX = Math.max(maxX, x + dx);
    maxY = Math.max(maxY, y + dy);
    if (!this.clipAndEnableScrolling || ((y < maxVisibleY) && ((y + dy) > minVisibleY)) || ((dy <= 0) && ((y == maxVisibleY) || (y == minVisibleY)))) {
      visibleRows += 1;
      if (firstRowInView == -1)
        firstRowInView = lastRowInView = index;
      else
        lastRowInView = index;
    }
    y += dy + this.gap;
  }
  this.http_$$www_adobe_com$2006$flex$mx$internal__setRowCount((visibleRows) >> 0);
  this.http_$$www_adobe_com$2006$flex$mx$internal__setIndexInView(firstRowInView, lastRowInView);
  layoutTarget.setContentSize(Math.ceil(maxX + this.paddingRight), Math.ceil(maxY + this.paddingBottom));
};


/**
 *  @asprivate
 * 
 *  This function sets the height of each child
 *  so that the heights add up to <code>height</code>. 
 *  Each child is set to its preferred height
 *  if its percentHeight is zero.
 *  If its percentHeight is a positive number,
 *  the child grows (or shrinks) to consume its
 *  share of extra space.
 *  
 *  The return value is any extra space that's left over
 *  after growing all children to their maxHeight.
 * @private
 * @param {number} width
 * @param {number} height
 * @param {number} restrictedWidth
 * @return {number}
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout_distributeHeight = function(width, height, restrictedWidth) {
  var /** @type {number} */ spaceToDistribute = height;
  var /** @type {number} */ totalPercentHeight = 0;
  var /** @type {Array} */ childInfoArray = [];
  var /** @type {spark.layouts.VerticalLayout.LayoutElementFlexChildInfo} */ childInfo;
  var /** @type {mx.core.ILayoutElement} */ layoutElement;
  var /** @type {number} */ rh = this.variableRowHeight ? 0 : Math.ceil(this.rowHeight);
  var /** @type {number} */ count = this.target.numElements;
  var /** @type {number} */ totalCount = count;
  for (var /** @type {number} */ index = 0; index < count; index++) {
    layoutElement = org.apache.royale.utils.Language.as(this.target.getElementAt(index), mx.core.ILayoutElement);
    if (!layoutElement || !layoutElement.includeInLayout) {
      totalCount--;
      continue;
    }
    if (!isNaN(layoutElement.percentHeight) && this.variableRowHeight) {
      totalPercentHeight += layoutElement.percentHeight;
      childInfo = new spark.layouts.VerticalLayout.LayoutElementFlexChildInfo();
      childInfo.layoutElement = layoutElement;
      childInfo.percent = layoutElement.percentHeight;
      childInfo.min = layoutElement.getMinBoundsHeight();
      childInfo.max = layoutElement.getMaxBoundsHeight();
      childInfoArray.push(childInfo);
    } else {
      spark.layouts.VerticalLayout.sizeLayoutElement(layoutElement, width, this.horizontalAlign, restrictedWidth, NaN, this.variableRowHeight, rh);
      spaceToDistribute -= Math.ceil(layoutElement.getLayoutBoundsHeight());
    }
  }
  if (totalCount > 1)
    spaceToDistribute -= (totalCount - 1) * this.gap;
  if (totalPercentHeight) {
    mx.containers.utilityClasses.Flex.flexChildrenProportionally(height, spaceToDistribute, totalPercentHeight, childInfoArray);
    var /** @type {number} */ roundOff = 0;
    var foreachiter0_target = childInfoArray;
    for (var foreachiter0 in foreachiter0_target) 
    {
    childInfo = foreachiter0_target[foreachiter0];
    {
      var /** @type {number} */ childSize = (Math.round(childInfo.size + roundOff)) >> 0;
      roundOff += childInfo.size - childSize;
      spark.layouts.VerticalLayout.sizeLayoutElement(childInfo.layoutElement, width, this.horizontalAlign, restrictedWidth, childSize, this.variableRowHeight, rh);
      spaceToDistribute -= childSize;
    }}
    
  }
  return spaceToDistribute;
};


/**
 *  @asprivate
 * @export
 * @override
 */
spark.layouts.VerticalLayout.prototype.updateDisplayList = function(unscaledWidth, unscaledHeight) {
  spark.layouts.VerticalLayout.superClass_.updateDisplayList.apply(this, [ unscaledWidth, unscaledHeight] );
  var /** @type {spark.components.supportClasses.GroupBase} */ layoutTarget = this.target;
  if (!layoutTarget)
    return;
  if ((layoutTarget.numElements == 0) || (unscaledWidth == 0) || (unscaledHeight == 0)) {
    this.http_$$www_adobe_com$2006$flex$mx$internal__setRowCount(0);
    this.http_$$www_adobe_com$2006$flex$mx$internal__setIndexInView(-1, -1);
    if (layoutTarget.numElements == 0)
      layoutTarget.setContentSize(Math.ceil(this.paddingLeft + this.paddingRight), Math.ceil(this.paddingTop + this.paddingBottom));
    return;
  }
  if (this.useVirtualLayout)
    this.spark_layouts_VerticalLayout_updateDisplayListVirtual(unscaledWidth, unscaledHeight);
  else
    this.spark_layouts_VerticalLayout_updateDisplayListReal(unscaledWidth, unscaledHeight);
};


/**
 *  @asprivate 
 *  Convenience function for subclasses that invalidates the
 *  target's size and displayList so that both layout's <code>measure()</code>
 *  and <code>updateDisplayList</code> methods get called.
 * 
 *  <p>Typically a layout invalidates the target's size and display list so that
 *  it gets a chance to recalculate the target's default size and also size and
 *  position the target's elements. For example changing the <code>gap</code>
 *  property on a <code>VerticalLayout</code> will internally call this method
 *  to ensure that the elements are re-arranged with the new setting and the
 *  target's default size is recomputed.</p> 
 * @private
 */
spark.layouts.VerticalLayout.prototype.spark_layouts_VerticalLayout_invalidateTargetSizeAndDisplayList = function() {
  var /** @type {spark.components.supportClasses.GroupBase} */ g = this.target;
  if (!g)
    return;
};


/**
 *  @asprivate 
 * @protected
 * @override
 */
spark.layouts.VerticalLayout.prototype.calculateDropIndex = function(x, y) {
  var /** @type {spark.components.supportClasses.GroupBase} */ layoutTarget = this.target;
  var /** @type {number} */ count = layoutTarget.numElements;
  if (count == 0)
    return 0;
  var /** @type {number} */ minDistance = Number.MAX_VALUE;
  var /** @type {number} */ bestIndex = -1;
  var /** @type {number} */ start = this.firstIndexInView;
  var /** @type {number} */ end = this.lastIndexInView;
  for (var /** @type {number} */ i = start; i <= end; i++) {
    var /** @type {org.apache.royale.geom.Rectangle} */ elementBounds = this.getElementBounds(i);
    if (!elementBounds)
      continue;
    if (elementBounds.top <= y && y <= elementBounds.bottom) {
      var /** @type {number} */ centerY = elementBounds.y + elementBounds.height / 2;
      return ((y < centerY) ? i : i + 1) >> 0;
    }
    var /** @type {number} */ curDistance = Math.min(Math.abs(y - elementBounds.top), Math.abs(y - elementBounds.bottom));
    if (curDistance < minDistance) {
      minDistance = curDistance;
      bestIndex = ((y < elementBounds.top) ? i : i + 1) >> 0;
    }
  }
  if (bestIndex == -1)
    bestIndex = (this.getElementBounds(0).y < y ? count : 0) >> 0;
  return bestIndex;
};


/**
 *  @asprivate
 * @protected
 * @override
 */
spark.layouts.VerticalLayout.prototype.calculateDropIndicatorBounds = function(dropLocation) {
  var /** @type {number} */ dropIndex = dropLocation.dropIndex;
  var /** @type {number} */ count = this.target.numElements;
  var /** @type {number} */ gap = this.gap;
  if (gap < 0 && dropIndex == count)
    gap = 0;
  var /** @type {number} */ emptySpace = (0 < gap) ? gap : 0;
  var /** @type {number} */ emptySpaceTop = 0;
  if (this.target.numElements > 0) {
    emptySpaceTop = (dropIndex < count) ? this.getElementBounds(dropIndex).top - emptySpace : this.getElementBounds((dropIndex - 1) >> 0).bottom + gap - emptySpace;
  }
  var /** @type {number} */ width = Math.max(this.target.width, this.target.contentWidth) - this.paddingLeft - this.paddingRight;
  var /** @type {number} */ height = emptySpace;
  if (org.apache.royale.utils.Language.is(this.dropIndicator, mx.core.IVisualElement)) {
    var /** @type {mx.core.IVisualElement} */ element = org.apache.royale.utils.Language.as(this.dropIndicator, mx.core.IVisualElement, true);
    height = Math.max(Math.min(height, element.getMaxBoundsHeight(false)), element.getMinBoundsHeight(false));
  }
  var /** @type {number} */ x = this.paddingLeft;
  var /** @type {number} */ y = emptySpaceTop + Math.round((emptySpace - height) / 2);
  y = Math.max(-1, Math.min(this.target.contentHeight - height + 1, y));
  return new org.apache.royale.geom.Rectangle(x, y, width, height);
};


/**
 *  @asprivate
 *  Identifies the element which has its "compare point" located closest 
 *  to the specified position.
 * @export
 * @override
 */
spark.layouts.VerticalLayout.prototype.http_$$www_adobe_com$2006$flex$mx$internal__getElementNearestScrollPosition = function(position, elementComparePoint) {
  elementComparePoint = typeof elementComparePoint !== 'undefined' ? elementComparePoint : "center";
  if (!this.useVirtualLayout)
    return spark.layouts.VerticalLayout.superClass_.http_$$www_adobe_com$2006$flex$mx$internal__getElementNearestScrollPosition.apply(this, [ position, elementComparePoint] );
  var /** @type {spark.components.supportClasses.GroupBase} */ g = org.apache.royale.utils.Language.as(this.target, spark.components.supportClasses.GroupBase, true);
  if (!g)
    return -1;
  this.spark_layouts_VerticalLayout_updateLLV(g);
  var /** @type {number} */ index = this.spark_layouts_VerticalLayout_llv.indexOf(position.y);
  if (index == -1)
    index = (position.y < 0 ? 0 : g.numElements - 1) >> 0;
  var /** @type {org.apache.royale.geom.Rectangle} */ bounds = this.spark_layouts_VerticalLayout_llv.getBounds((index) >>> 0);
  var /** @type {org.apache.royale.geom.Rectangle} */ adjacentBounds;
  if ((elementComparePoint == "bottomLeft" || elementComparePoint == "bottomRight") && index > 0) {
    adjacentBounds = this.spark_layouts_VerticalLayout_llv.getBounds((index - 1) >>> 0);
    if (org.apache.royale.geom.Point.distance(position, adjacentBounds.bottomRight) < org.apache.royale.geom.Point.distance(position, bounds.bottomRight))
      index--;
  }
  if ((elementComparePoint == "topLeft" || elementComparePoint == "topRight") && index < g.numElements - 1) {
    adjacentBounds = this.spark_layouts_VerticalLayout_llv.getBounds((index + 1) >>> 0);
    if (org.apache.royale.geom.Point.distance(position, adjacentBounds.topLeft) < org.apache.royale.geom.Point.distance(position, bounds.topLeft))
      index++;
  }
  return index;
};


spark.layouts.VerticalLayout.prototype.get__gap = function() {
  return this.spark_layouts_VerticalLayout__gap;
};


spark.layouts.VerticalLayout.prototype.set__gap = function(value) {
  if (this.spark_layouts_VerticalLayout__gap == value)
    return;
  this.spark_layouts_VerticalLayout__gap = value;
  this.spark_layouts_VerticalLayout_invalidateTargetSizeAndDisplayList();
};


spark.layouts.VerticalLayout.prototype.get__rowCount = function() {
  return this.spark_layouts_VerticalLayout__rowCount;
};


spark.layouts.VerticalLayout.prototype.get__horizontalAlign = function() {
  return this.spark_layouts_VerticalLayout__horizontalAlign;
};


spark.layouts.VerticalLayout.prototype.set__horizontalAlign = function(value) {
  if (value == this.spark_layouts_VerticalLayout__horizontalAlign)
    return;
  this.spark_layouts_VerticalLayout__horizontalAlign = value;
};


spark.layouts.VerticalLayout.prototype.get__verticalAlign = function() {
  return this.spark_layouts_VerticalLayout__verticalAlign;
};


spark.layouts.VerticalLayout.prototype.set__verticalAlign = function(value) {
  if (value == this.spark_layouts_VerticalLayout__verticalAlign)
    return;
  this.spark_layouts_VerticalLayout__verticalAlign = value;
};


spark.layouts.VerticalLayout.prototype.get__padding = function() {
  return this.spark_layouts_VerticalLayout__padding;
};


spark.layouts.VerticalLayout.prototype.set__padding = function(value) {
  if (this.spark_layouts_VerticalLayout__padding == value)
    return;
  this.spark_layouts_VerticalLayout__padding = value;
  this.paddingBottom = this.spark_layouts_VerticalLayout__padding;
  this.paddingLeft = this.spark_layouts_VerticalLayout__padding;
  this.paddingRight = this.spark_layouts_VerticalLayout__padding;
  this.paddingTop = this.spark_layouts_VerticalLayout__padding;
  this.spark_layouts_VerticalLayout_invalidateTargetSizeAndDisplayList();
};


spark.layouts.VerticalLayout.prototype.get__paddingLeft = function() {
  return this.spark_layouts_VerticalLayout__paddingLeft;
};


spark.layouts.VerticalLayout.prototype.set__paddingLeft = function(value) {
  if (this.spark_layouts_VerticalLayout__paddingLeft == value)
    return;
  this.spark_layouts_VerticalLayout__paddingLeft = value;
  this.spark_layouts_VerticalLayout_invalidateTargetSizeAndDisplayList();
};


spark.layouts.VerticalLayout.prototype.get__paddingRight = function() {
  return this.spark_layouts_VerticalLayout__paddingRight;
};


spark.layouts.VerticalLayout.prototype.set__paddingRight = function(value) {
  if (this.spark_layouts_VerticalLayout__paddingRight == value)
    return;
  this.spark_layouts_VerticalLayout__paddingRight = value;
  this.spark_layouts_VerticalLayout_invalidateTargetSizeAndDisplayList();
};


spark.layouts.VerticalLayout.prototype.get__paddingTop = function() {
  return this.spark_layouts_VerticalLayout__paddingTop;
};


spark.layouts.VerticalLayout.prototype.set__paddingTop = function(value) {
  if (this.spark_layouts_VerticalLayout__paddingTop == value)
    return;
  this.spark_layouts_VerticalLayout__paddingTop = value;
  this.spark_layouts_VerticalLayout_invalidateTargetSizeAndDisplayList();
};


spark.layouts.VerticalLayout.prototype.get__paddingBottom = function() {
  return this.spark_layouts_VerticalLayout__paddingBottom;
};


spark.layouts.VerticalLayout.prototype.set__paddingBottom = function(value) {
  if (this.spark_layouts_VerticalLayout__paddingBottom == value)
    return;
  this.spark_layouts_VerticalLayout__paddingBottom = value;
  this.spark_layouts_VerticalLayout_invalidateTargetSizeAndDisplayList();
};


spark.layouts.VerticalLayout.prototype.get__requestedMaxRowCount = function() {
  return this.spark_layouts_VerticalLayout__requestedMaxRowCount;
};


spark.layouts.VerticalLayout.prototype.set__requestedMaxRowCount = function(value) {
  if (this.spark_layouts_VerticalLayout__requestedMaxRowCount == value)
    return;
  this.spark_layouts_VerticalLayout__requestedMaxRowCount = value;
  if (this.target)
    this.target.invalidateSize();
};


spark.layouts.VerticalLayout.prototype.get__requestedMinRowCount = function() {
  return this.spark_layouts_VerticalLayout__requestedMinRowCount;
};


spark.layouts.VerticalLayout.prototype.set__requestedMinRowCount = function(value) {
  if (this.spark_layouts_VerticalLayout__requestedMinRowCount == value)
    return;
  this.spark_layouts_VerticalLayout__requestedMinRowCount = value;
  if (this.target)
    this.target.invalidateSize();
};


spark.layouts.VerticalLayout.prototype.get__requestedRowCount = function() {
  return this.spark_layouts_VerticalLayout__requestedRowCount;
};


spark.layouts.VerticalLayout.prototype.set__requestedRowCount = function(value) {
  if (this.spark_layouts_VerticalLayout__requestedRowCount == value)
    return;
  this.spark_layouts_VerticalLayout__requestedRowCount = value;
  if (this.target)
    this.target.invalidateSize();
};


spark.layouts.VerticalLayout.prototype.get__rowHeight = function() {
  if (!isNaN(this.spark_layouts_VerticalLayout__rowHeight))
    return this.spark_layouts_VerticalLayout__rowHeight; else {
    var /** @type {mx.core.ILayoutElement} */ elt = this.typicalLayoutElement;
    return elt ? elt.getPreferredBoundsHeight() : 0;
  }
};


spark.layouts.VerticalLayout.prototype.set__rowHeight = function(value) {
  if (this.spark_layouts_VerticalLayout__rowHeight == value)
    return;
  this.spark_layouts_VerticalLayout__rowHeight = value;
  this.spark_layouts_VerticalLayout_invalidateTargetSizeAndDisplayList();
};


spark.layouts.VerticalLayout.prototype.get__variableRowHeight = function() {
  return this.spark_layouts_VerticalLayout__variableRowHeight;
};


spark.layouts.VerticalLayout.prototype.set__variableRowHeight = function(value) {
  if (value == this.spark_layouts_VerticalLayout__variableRowHeight)
    return;
  this.spark_layouts_VerticalLayout__variableRowHeight = value;
  this.spark_layouts_VerticalLayout_invalidateTargetSizeAndDisplayList();
};


spark.layouts.VerticalLayout.prototype.get__firstIndexInView = function() {
  return this.spark_layouts_VerticalLayout__firstIndexInView;
};


spark.layouts.VerticalLayout.prototype.get__lastIndexInView = function() {
  return this.spark_layouts_VerticalLayout__lastIndexInView;
};


spark.layouts.VerticalLayout.prototype.set__clipAndEnableScrolling = function(value) {
  spark.layouts.VerticalLayout.superClass_.set__clipAndEnableScrolling.apply(this, [ value] );
};


Object.defineProperties(spark.layouts.VerticalLayout.prototype, /** @lends {spark.layouts.VerticalLayout.prototype} */ {
/**
  * @export
  * @type {number} */
gap: {
get: spark.layouts.VerticalLayout.prototype.get__gap,
set: spark.layouts.VerticalLayout.prototype.set__gap},
/**
  * @export
  * @type {number} */
rowCount: {
get: spark.layouts.VerticalLayout.prototype.get__rowCount},
/**
  * @export
  * @type {string} */
horizontalAlign: {
get: spark.layouts.VerticalLayout.prototype.get__horizontalAlign,
set: spark.layouts.VerticalLayout.prototype.set__horizontalAlign},
/**
  * @export
  * @type {string} */
verticalAlign: {
get: spark.layouts.VerticalLayout.prototype.get__verticalAlign,
set: spark.layouts.VerticalLayout.prototype.set__verticalAlign},
/**
  * @export
  * @type {number} */
padding: {
get: spark.layouts.VerticalLayout.prototype.get__padding,
set: spark.layouts.VerticalLayout.prototype.set__padding},
/**
  * @export
  * @type {number} */
paddingLeft: {
get: spark.layouts.VerticalLayout.prototype.get__paddingLeft,
set: spark.layouts.VerticalLayout.prototype.set__paddingLeft},
/**
  * @export
  * @type {number} */
paddingRight: {
get: spark.layouts.VerticalLayout.prototype.get__paddingRight,
set: spark.layouts.VerticalLayout.prototype.set__paddingRight},
/**
  * @export
  * @type {number} */
paddingTop: {
get: spark.layouts.VerticalLayout.prototype.get__paddingTop,
set: spark.layouts.VerticalLayout.prototype.set__paddingTop},
/**
  * @export
  * @type {number} */
paddingBottom: {
get: spark.layouts.VerticalLayout.prototype.get__paddingBottom,
set: spark.layouts.VerticalLayout.prototype.set__paddingBottom},
/**
  * @export
  * @type {number} */
requestedMaxRowCount: {
get: spark.layouts.VerticalLayout.prototype.get__requestedMaxRowCount,
set: spark.layouts.VerticalLayout.prototype.set__requestedMaxRowCount},
/**
  * @export
  * @type {number} */
requestedMinRowCount: {
get: spark.layouts.VerticalLayout.prototype.get__requestedMinRowCount,
set: spark.layouts.VerticalLayout.prototype.set__requestedMinRowCount},
/**
  * @export
  * @type {number} */
requestedRowCount: {
get: spark.layouts.VerticalLayout.prototype.get__requestedRowCount,
set: spark.layouts.VerticalLayout.prototype.set__requestedRowCount},
/**
  * @export
  * @type {number} */
rowHeight: {
get: spark.layouts.VerticalLayout.prototype.get__rowHeight,
set: spark.layouts.VerticalLayout.prototype.set__rowHeight},
/**
  * @export
  * @type {boolean} */
variableRowHeight: {
get: spark.layouts.VerticalLayout.prototype.get__variableRowHeight,
set: spark.layouts.VerticalLayout.prototype.set__variableRowHeight},
/**
  * @export
  * @type {number} */
firstIndexInView: {
get: spark.layouts.VerticalLayout.prototype.get__firstIndexInView},
/**
  * @export
  * @type {number} */
lastIndexInView: {
get: spark.layouts.VerticalLayout.prototype.get__lastIndexInView},
/**
  * @export
  * @type {boolean} */
clipAndEnableScrolling: {
get: spark.layouts.supportClasses.LayoutBase.prototype.get__clipAndEnableScrolling,
set: spark.layouts.VerticalLayout.prototype.set__clipAndEnableScrolling}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
spark.layouts.VerticalLayout.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'VerticalLayout', qName: 'spark.layouts.VerticalLayout', kind: 'class' }], interfaces: [spark.core.IGapLayout] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
spark.layouts.VerticalLayout.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    accessors: function () {
      return {
        'gap': { type: 'int', access: 'readwrite', declaredBy: 'spark.layouts.VerticalLayout'},
        'rowCount': { type: 'int', access: 'readonly', declaredBy: 'spark.layouts.VerticalLayout', metadata: function () { return [ { name: 'Bindable', args: [ { key: '', value: 'propertyChange' } ] } ]; }},
        'horizontalAlign': { type: 'String', access: 'readwrite', declaredBy: 'spark.layouts.VerticalLayout'},
        'verticalAlign': { type: 'String', access: 'readwrite', declaredBy: 'spark.layouts.VerticalLayout'},
        'padding': { type: 'Number', access: 'readwrite', declaredBy: 'spark.layouts.VerticalLayout'},
        'paddingLeft': { type: 'Number', access: 'readwrite', declaredBy: 'spark.layouts.VerticalLayout'},
        'paddingRight': { type: 'Number', access: 'readwrite', declaredBy: 'spark.layouts.VerticalLayout'},
        'paddingTop': { type: 'Number', access: 'readwrite', declaredBy: 'spark.layouts.VerticalLayout'},
        'paddingBottom': { type: 'Number', access: 'readwrite', declaredBy: 'spark.layouts.VerticalLayout'},
        'requestedMaxRowCount': { type: 'int', access: 'readwrite', declaredBy: 'spark.layouts.VerticalLayout'},
        'requestedMinRowCount': { type: 'int', access: 'readwrite', declaredBy: 'spark.layouts.VerticalLayout'},
        'requestedRowCount': { type: 'int', access: 'readwrite', declaredBy: 'spark.layouts.VerticalLayout'},
        'rowHeight': { type: 'Number', access: 'readwrite', declaredBy: 'spark.layouts.VerticalLayout'},
        'variableRowHeight': { type: 'Boolean', access: 'readwrite', declaredBy: 'spark.layouts.VerticalLayout'},
        'firstIndexInView': { type: 'int', access: 'readonly', declaredBy: 'spark.layouts.VerticalLayout', metadata: function () { return [ { name: 'Bindable', args: [ { key: '', value: 'indexInViewChanged' } ] } ]; }},
        'lastIndexInView': { type: 'int', access: 'readonly', declaredBy: 'spark.layouts.VerticalLayout', metadata: function () { return [ { name: 'Bindable', args: [ { key: '', value: 'indexInViewChanged' } ] } ]; }},
        'clipAndEnableScrolling': { type: 'Boolean', access: 'writeonly', declaredBy: 'spark.layouts.VerticalLayout'}
      };
    },
    methods: function () {
      return {
        'VerticalLayout': { type: 'void', declaredBy: 'spark.layouts.VerticalLayout'},
        'http://www.adobe.com/2006/flex/mx/internal::setRowCount': { type: 'void', declaredBy: 'spark.layouts.VerticalLayout', parameters: function () { return [ 'int', false ]; }},
        'http://www.adobe.com/2006/flex/mx/internal::setIndexInView': { type: 'void', declaredBy: 'spark.layouts.VerticalLayout', parameters: function () { return [ 'int', false ,'int', false ]; }},
        'clearVirtualLayoutCache': { type: 'void', declaredBy: 'spark.layouts.VerticalLayout'},
        'getElementBounds': { type: 'org.apache.royale.geom.Rectangle', declaredBy: 'spark.layouts.VerticalLayout', parameters: function () { return [ 'int', false ]; }},
        'fractionOfElementInView': { type: 'Number', declaredBy: 'spark.layouts.VerticalLayout', parameters: function () { return [ 'int', false ]; }},
        'http://www.adobe.com/2006/flex/mx/internal::getRowsToMeasure': { type: 'int', declaredBy: 'spark.layouts.VerticalLayout', parameters: function () { return [ 'int', false ]; }},
        'elementAdded': { type: 'void', declaredBy: 'spark.layouts.VerticalLayout', parameters: function () { return [ 'int', false ]; }},
        'elementRemoved': { type: 'void', declaredBy: 'spark.layouts.VerticalLayout', parameters: function () { return [ 'int', false ]; }},
        'measure': { type: 'void', declaredBy: 'spark.layouts.VerticalLayout'},
        'getNavigationDestinationIndex': { type: 'int', declaredBy: 'spark.layouts.VerticalLayout', parameters: function () { return [ 'int', false ,'uint', false ,'Boolean', false ]; }},
        'updateDisplayList': { type: 'void', declaredBy: 'spark.layouts.VerticalLayout', parameters: function () { return [ 'Number', false ,'Number', false ]; }},
        'http://www.adobe.com/2006/flex/mx/internal::getElementNearestScrollPosition': { type: 'int', declaredBy: 'spark.layouts.VerticalLayout', parameters: function () { return [ 'org.apache.royale.geom.Point', false ,'String', true ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
spark.layouts.VerticalLayout.prototype.ROYALE_COMPILE_FLAGS = 10;



/**
 * @constructor
 * @extends {mx.containers.utilityClasses.FlexChildInfo}
 */
spark.layouts.VerticalLayout.LayoutElementFlexChildInfo = function() {
  spark.layouts.VerticalLayout.LayoutElementFlexChildInfo.base(this, 'constructor');
};
goog.inherits(spark.layouts.VerticalLayout.LayoutElementFlexChildInfo, mx.containers.utilityClasses.FlexChildInfo);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('spark.layouts.VerticalLayout.LayoutElementFlexChildInfo', spark.layouts.VerticalLayout.LayoutElementFlexChildInfo);


/**
 * @export
 * @type {mx.core.ILayoutElement}
 */
spark.layouts.VerticalLayout.LayoutElementFlexChildInfo.prototype.layoutElement;


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
spark.layouts.VerticalLayout.LayoutElementFlexChildInfo.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'LayoutElementFlexChildInfo', qName: 'spark.layouts.VerticalLayout.LayoutElementFlexChildInfo', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
spark.layouts.VerticalLayout.LayoutElementFlexChildInfo.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        'layoutElement': { type: 'mx.core.ILayoutElement', get_set: function (/** spark.layouts.VerticalLayout.LayoutElementFlexChildInfo */ inst, /** * */ v) {return v !== undefined ? inst.layoutElement = v : inst.layoutElement;}}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
spark.layouts.VerticalLayout.LayoutElementFlexChildInfo.prototype.ROYALE_COMPILE_FLAGS = 10;



/**
 * @constructor
 */
spark.layouts.VerticalLayout.SizesAndLimit = function() {
};


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('spark.layouts.VerticalLayout.SizesAndLimit', spark.layouts.VerticalLayout.SizesAndLimit);


/**
 * @export
 * @type {number}
 */
spark.layouts.VerticalLayout.SizesAndLimit.prototype.preferredSize;


/**
 * @export
 * @type {number}
 */
spark.layouts.VerticalLayout.SizesAndLimit.prototype.minSize;


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
spark.layouts.VerticalLayout.SizesAndLimit.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'SizesAndLimit', qName: 'spark.layouts.VerticalLayout.SizesAndLimit', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
spark.layouts.VerticalLayout.SizesAndLimit.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        'preferredSize': { type: 'Number', get_set: function (/** spark.layouts.VerticalLayout.SizesAndLimit */ inst, /** * */ v) {return v !== undefined ? inst.preferredSize = v : inst.preferredSize;}},
        'minSize': { type: 'Number', get_set: function (/** spark.layouts.VerticalLayout.SizesAndLimit */ inst, /** * */ v) {return v !== undefined ? inst.minSize = v : inst.minSize;}}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
spark.layouts.VerticalLayout.SizesAndLimit.prototype.ROYALE_COMPILE_FLAGS = 10;

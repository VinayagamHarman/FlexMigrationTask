/**
 * Generated by Apache Royale Compiler from spark/layouts/HorizontalLayout.as
 * spark.layouts.HorizontalLayout
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('spark.layouts.HorizontalLayout');
/* Royale Dependency List: mx.containers.utilityClasses.Flex,mx.core.ILayoutElement,mx.core.IVisualElement,mx.core.mx_internal,mx.events.PropertyChangeEvent,org.apache.royale.events.Event,org.apache.royale.geom.Point,org.apache.royale.geom.Rectangle,spark.components.supportClasses.GroupBase,spark.core.NavigationUnit,spark.layouts.HorizontalAlign,spark.layouts.VerticalAlign,spark.layouts.supportClasses.DropLocation,spark.layouts.supportClasses.LayoutElementHelper,spark.layouts.supportClasses.LinearLayoutVector,org.apache.royale.utils.Language,XML*/
goog.provide('spark.layouts.HorizontalLayout.HLayoutElementFlexChildInfo');
goog.provide('spark.layouts.HorizontalLayout.SizesAndLimit');

goog.require('mx.containers.utilityClasses.FlexChildInfo');
goog.require('spark.layouts.supportClasses.LayoutBase');
goog.require('spark.core.IGapLayout');



/**
 *  Constructor. 
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @constructor
 * @extends {spark.layouts.supportClasses.LayoutBase}
 * @implements {spark.core.IGapLayout}
 */
spark.layouts.HorizontalLayout = function() {
  
  this.spark_layouts_HorizontalLayout__horizontalAlign = spark.layouts.HorizontalAlign.LEFT;
  this.spark_layouts_HorizontalLayout__verticalAlign = spark.layouts.VerticalAlign.TOP;
  spark.layouts.HorizontalLayout.base(this, 'constructor');
  this.http_$$www_adobe_com$2006$flex$mx$internal__dragScrollRegionSizeVertical = 0;
};
goog.inherits(spark.layouts.HorizontalLayout, spark.layouts.supportClasses.LayoutBase);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('spark.layouts.HorizontalLayout', spark.layouts.HorizontalLayout);


/**
 * @private
 * @type {spark.layouts.supportClasses.LinearLayoutVector}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout_llv;


/**
 * @private
 * @param {mx.core.ILayoutElement} layoutElement
 * @param {number} height
 * @return {number}
 */
spark.layouts.HorizontalLayout.calculatePercentHeight = function(layoutElement, height) {
  var /** @type {number} */ percentHeight;
  percentHeight = spark.layouts.supportClasses.LayoutElementHelper.pinBetween(Math.min(Math.round(layoutElement.percentHeight * 0.01 * height), height), layoutElement.getMinBoundsHeight(), layoutElement.getMaxBoundsHeight());
  return percentHeight;
};


/**
 * @private
 * @param {mx.core.ILayoutElement} layoutElement
 * @param {number} height
 * @param {string} verticalAlign
 * @param {number} restrictedHeight
 * @param {number} width
 * @param {boolean} variableColumnWidth
 * @param {number} columnWidth
 */
spark.layouts.HorizontalLayout.sizeLayoutElement = function(layoutElement, height, verticalAlign, restrictedHeight, width, variableColumnWidth, columnWidth) {
  var /** @type {number} */ newHeight = NaN;
  if (verticalAlign == spark.layouts.VerticalAlign.JUSTIFY || verticalAlign == spark.layouts.VerticalAlign.CONTENT_JUSTIFY) {
    newHeight = restrictedHeight;
  } else {
    if (!isNaN(layoutElement.percentHeight))
      newHeight = spark.layouts.HorizontalLayout.calculatePercentHeight(layoutElement, height);
  }
  if (variableColumnWidth)
    layoutElement.setLayoutBoundsSize(width, newHeight);
  else
    layoutElement.setLayoutBoundsSize(columnWidth, newHeight);
};


/**
 * @private
 * @type {Object}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout__alignmentBaseline = "maxAscent:0";


/**
 * @private
 * @type {number}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout__gap = 6;


/**
 * @private
 * @type {number}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout__columnCount = -1;


/**
 *  @asprivate
 * 
 *  Sets the <code>columnCount</code> property and dispatches
 *  a PropertyChangeEvent.
 * @private
 * @param {number} value
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout_setColumnCount = function(value) {
  if (this.spark_layouts_HorizontalLayout__columnCount == value)
    return;
  var /** @type {number} */ oldValue = this.spark_layouts_HorizontalLayout__columnCount;
  this.spark_layouts_HorizontalLayout__columnCount = value;
  this.dispatchEvent(mx.events.PropertyChangeEvent.createUpdateEvent(this, "columnCount", oldValue, value));
};


/**
 * @private
 * @type {number}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout__padding = 0;


/**
 * @private
 * @type {number}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout__paddingLeft = 0;


/**
 * @private
 * @type {number}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout__paddingRight = 0;


/**
 * @private
 * @type {number}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout__paddingTop = 0;


/**
 * @private
 * @type {number}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout__paddingBottom = 0;


/**
 * @private
 * @type {number}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout__requestedMaxColumnCount = -1;


/**
 * @private
 * @type {number}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout__requestedMinColumnCount = -1;


/**
 * @private
 * @type {number}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout__requestedColumnCount = -1;


/**
 * @private
 * @type {number}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout__columnWidth;


/**
 * @private
 * @type {boolean}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout__variableColumnWidth = true;


/**
 * @private
 * @type {number}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout__firstIndexInView = -1;


/**
 * @private
 * @type {number}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout__lastIndexInView = -1;


/**
 * @private
 * @type {string}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout__horizontalAlign;


/**
 * @private
 * @type {string}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout__verticalAlign;


/**
 *  @asprivate
 * 
 *  Sets the <code>firstIndexInView</code> and <code>lastIndexInView</code>
 *  properties and dispatches a <code>"indexInViewChanged"</code>
 *  event.  
 * 
 *  @asparam firstIndex The new value for firstIndexInView.
 *  @asparam lastIndex The new value for lastIndexInView.
 * 
 *  @see firstIndexInView
 *  @see lastIndexInview
 * @private
 * @param {number} firstIndex
 * @param {number} lastIndex
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout_setIndexInView = function(firstIndex, lastIndex) {
  if ((this.spark_layouts_HorizontalLayout__firstIndexInView == firstIndex) && (this.spark_layouts_HorizontalLayout__lastIndexInView == lastIndex))
    return;
  this.spark_layouts_HorizontalLayout__firstIndexInView = firstIndex;
  this.spark_layouts_HorizontalLayout__lastIndexInView = lastIndex;
  this.dispatchEvent(new org.apache.royale.events.Event("indexInViewChanged"));
};


/**
 * @asprivate
 * @export
 * @override
 */
spark.layouts.HorizontalLayout.prototype.clearVirtualLayoutCache = function() {
  this.spark_layouts_HorizontalLayout_llv = null;
};


/**
 *  @asprivate
 * @export
 * @override
 */
spark.layouts.HorizontalLayout.prototype.getElementBounds = function(index) {
  if (!this.useVirtualLayout)
    return spark.layouts.HorizontalLayout.superClass_.getElementBounds.apply(this, [ index] );
  var /** @type {spark.components.supportClasses.GroupBase} */ g = org.apache.royale.utils.Language.as(this.target, spark.components.supportClasses.GroupBase, true);
  if (!g || (index < 0) || (index >= g.numElements) || !this.spark_layouts_HorizontalLayout_llv)
    return null;
  this.spark_layouts_HorizontalLayout_updateLLV(g);
  return this.spark_layouts_HorizontalLayout_llv.getBounds((index) >>> 0);
};


/**
 *  Returns 1.0 if the specified index is completely in view, 0.0 if
 *  it's not, or a value between 0.0 and 1.0 that represents the percentage 
 *  of the if the index that is partially in view.
 * 
 *  <p>An index is "in view" if the corresponding non-null layout element is 
 *  within the horizontal limits of the container's <code>scrollRect</code>
 *  and included in the layout.</p>
 *  
 *  <p>If the specified index is partially within the view, the 
 *  returned value is the percentage of the corresponding
 *  layout element that's visible.</p>
 *
 *  @asparam index The index of the column.
 * 
 *  @asreturn The percentage of the specified element that's in view.
 *  Returns 0.0 if the specified index is invalid or if it corresponds to
 *  null element, or a ILayoutElement for which 
 *  the <code>includeInLayout</code> property is <code>false</code>.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 * @param {number} index
 * @return {number}
 */
spark.layouts.HorizontalLayout.prototype.fractionOfElementInView = function(index) {
  var /** @type {spark.components.supportClasses.GroupBase} */ g = this.target;
  if (!g)
    return 0.0;
  if ((index < 0) || (index >= g.numElements))
    return 0.0;
  if (!this.clipAndEnableScrolling)
    return 1.0;
  var /** @type {number} */ r0 = this.firstIndexInView;
  var /** @type {number} */ r1 = this.lastIndexInView;
  if ((r0 == -1) || (r1 == -1) || (index < r0) || (index > r1))
    return 0.0;
  if ((index > r0) && (index < r1))
    return 1.0;
  var /** @type {number} */ eltX;
  var /** @type {number} */ eltWidth;
  if (this.useVirtualLayout) {
    if (!this.spark_layouts_HorizontalLayout_llv)
      return 0.0;
    eltX = this.spark_layouts_HorizontalLayout_llv.start((index) >>> 0);
    eltWidth = this.spark_layouts_HorizontalLayout_llv.getMajorSize((index) >>> 0);
  } else {
    var /** @type {mx.core.ILayoutElement} */ elt = org.apache.royale.utils.Language.as(g.getElementAt(index), mx.core.ILayoutElement);
    if (!elt || !elt.includeInLayout)
      return 0.0;
    eltX = elt.getLayoutBoundsX();
    eltWidth = elt.getLayoutBoundsWidth();
  }
  var /** @type {number} */ x0 = g.horizontalScrollPosition;
  var /** @type {number} */ x1 = x0 + g.width;
  var /** @type {number} */ ix0 = eltX;
  var /** @type {number} */ ix1 = ix0 + eltWidth;
  if (ix0 >= ix1)
    return 1.0;
  if ((ix0 >= x0) && (ix1 <= x1))
    return 1.0;
  return (Math.min(x1, ix1) - Math.max(x0, ix0)) / (ix1 - ix0);
};


/**
 *  @asprivate
 * 
 *  Binary search for the first layout element that contains y.  
 * 
 *  This function considers both the element's actual bounds and 
 *  the gap that follows it to be part of the element.  The search 
 *  covers index i0 through i1 (inclusive).
 * 
 *  This function is intended for variable height elements.
 * 
 *  Returns the index of the element that contains x, or -1.
 * @private
 * @param {number} x
 * @param {number} gap
 * @param {spark.components.supportClasses.GroupBase} g
 * @param {number} i0
 * @param {number} i1
 * @return {number}
 */
spark.layouts.HorizontalLayout.findIndexAt = function(x, gap, g, i0, i1) {
  var /** @type {number} */ index = ((i0 + i1) / 2) >> 0;
  var /** @type {mx.core.ILayoutElement} */ element = org.apache.royale.utils.Language.as(g.getElementAt(index), mx.core.ILayoutElement);
  var /** @type {number} */ elementX = element.getLayoutBoundsX();
  if ((x >= elementX) && (x < elementX + element.getLayoutBoundsWidth() + gap))
    return index;
  else if (i0 == i1)
    return -1;
  else if (x < elementX)
    return spark.layouts.HorizontalLayout.findIndexAt(x, gap, g, i0, (Math.max(i0, index - 1)) >> 0);
  else
    return spark.layouts.HorizontalLayout.findIndexAt(x, gap, g, (Math.min(index + 1, i1)) >> 0, i1);
};


/**
 *  @asprivate
 * 
 *  Returns the index of the first non-null includeInLayout element, 
 *  beginning with the element at index i.  
 * 
 *  Returns -1 if no such element can be found.
 * @private
 * @param {spark.components.supportClasses.GroupBase} g
 * @param {number} i
 * @param {number} dir
 * @return {number}
 */
spark.layouts.HorizontalLayout.findLayoutElementIndex = function(g, i, dir) {
  var /** @type {number} */ n = g.numElements;
  while ((i >= 0) && (i < n)) {
    var /** @type {mx.core.ILayoutElement} */ element = org.apache.royale.utils.Language.as(g.getElementAt(i), mx.core.ILayoutElement);
    if (element && element.includeInLayout) {
      return i;
    }
    i += dir;
  }
  return -1;
};


/**
 *  @asprivate
 * 
 *  Updates the first,lastIndexInView properties per the new
 *  scroll position.
 *  
 *  @see setIndexInView
 * @protected
 * @override
 */
spark.layouts.HorizontalLayout.prototype.scrollPositionChanged = function() {
  var /** @type {number} */ i0 = 0;
  var /** @type {number} */ i1 = 0;
  spark.layouts.HorizontalLayout.superClass_.scrollPositionChanged.apply(this);
  var /** @type {spark.components.supportClasses.GroupBase} */ g = this.target;
  if (!g)
    return;
  var /** @type {number} */ n = (g.numElements - 1) >> 0;
  if (n < 0) {
    this.spark_layouts_HorizontalLayout_setIndexInView(-1, -1);
    return;
  }
  var /** @type {org.apache.royale.geom.Rectangle} */ scrollR = this.getScrollRect();
  if (!scrollR) {
    this.spark_layouts_HorizontalLayout_setIndexInView(0, n);
    return;
  }
  var /** @type {number} */ x0 = scrollR.left;
  var /** @type {number} */ x1 = scrollR.right - .0001;
  if (x1 <= x0) {
    this.spark_layouts_HorizontalLayout_setIndexInView(-1, -1);
    return;
  }
  if (this.useVirtualLayout && !this.spark_layouts_HorizontalLayout_llv) {
    this.spark_layouts_HorizontalLayout_setIndexInView(-1, -1);
    return;
  }
  //var /** @type {number} */ i0 = 0;
  //var /** @type {number} */ i1 = 0;
  if (this.useVirtualLayout) {
    i0 = this.spark_layouts_HorizontalLayout_llv.indexOf(x0);
    i1 = this.spark_layouts_HorizontalLayout_llv.indexOf(x1);
  } else {
    i0 = spark.layouts.HorizontalLayout.findIndexAt(x0 + this.gap, this.gap, g, 0, n);
    i1 = spark.layouts.HorizontalLayout.findIndexAt(x1, this.gap, g, 0, n);
  }
  if (i0 == -1) {
    var /** @type {number} */ index0 = spark.layouts.HorizontalLayout.findLayoutElementIndex(g, 0, 1);
    if (index0 != -1) {
      var /** @type {mx.core.ILayoutElement} */ element0 = org.apache.royale.utils.Language.as(g.getElementAt(index0), mx.core.ILayoutElement);
      var /** @type {number} */ element0X = element0.getLayoutBoundsX();
      var /** @type {number} */ element0Width = element0.getLayoutBoundsWidth();
      if ((element0X < x1) && ((element0X + element0Width) > x0))
        i0 = index0;
    }
  }
  if (i1 == -1) {
    var /** @type {number} */ index1 = spark.layouts.HorizontalLayout.findLayoutElementIndex(g, n, -1);
    if (index1 != -1) {
      var /** @type {mx.core.ILayoutElement} */ element1 = org.apache.royale.utils.Language.as(g.getElementAt(index1), mx.core.ILayoutElement);
      var /** @type {number} */ element1X = element1.getLayoutBoundsX();
      var /** @type {number} */ element1Width = element1.getLayoutBoundsWidth();
      if ((element1X < x1) && ((element1X + element1Width) > x0))
        i1 = index1;
    }
  }
  if (this.useVirtualLayout) {
    var /** @type {mx.core.ILayoutElement} */ firstElement = org.apache.royale.utils.Language.as(g.getElementAt(this.spark_layouts_HorizontalLayout__firstIndexInView), mx.core.ILayoutElement);
    var /** @type {mx.core.ILayoutElement} */ lastElement = org.apache.royale.utils.Language.as(g.getElementAt(this.spark_layouts_HorizontalLayout__lastIndexInView), mx.core.ILayoutElement);
    var /** @type {org.apache.royale.geom.Rectangle} */ scrollRect = this.getScrollRect();
  }
  this.spark_layouts_HorizontalLayout_setIndexInView(i0, i1);
};


/**
 *  @asprivate
 * 
 *  Returns the actual position/size Rectangle of the first partially 
 *  visible or not-visible, non-null includeInLayout element, beginning
 *  with the element at index i, searching in direction dir (dir must
 *  be +1 or -1).   The last argument is the GroupBase scrollRect, it's
 *  guaranteed to be non-null.
 * 
 *  Returns null if no such element can be found.
 * @private
 * @param {spark.components.supportClasses.GroupBase} g
 * @param {number} i
 * @param {number} dir
 * @param {org.apache.royale.geom.Rectangle} r
 * @return {org.apache.royale.geom.Rectangle}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout_findLayoutElementBounds = function(g, i, dir, r) {
  var /** @type {number} */ n = g.numElements;
  if (this.fractionOfElementInView(i) >= 1) {
    i += dir;
    if (i < 0)
      return new org.apache.royale.geom.Rectangle(0, 0, this.paddingLeft, 0);
    if (i >= n)
      return new org.apache.royale.geom.Rectangle(this.getElementBounds((n - 1) >> 0).right, 0, this.paddingRight, 0);
  }
  while ((i >= 0) && (i < n)) {
    var /** @type {org.apache.royale.geom.Rectangle} */ elementR = this.getElementBounds(i);
    if (elementR) {
      var /** @type {boolean} */ overlapsLeft = (dir == -1) && (elementR.left == r.left) && (elementR.right >= r.right);
      var /** @type {boolean} */ overlapsRight = (dir == +1) && (elementR.right == r.right) && (elementR.left <= r.left);
      if (!(overlapsLeft || overlapsRight))
        return elementR;
    }
    i += dir;
  }
  return null;
};


/**
 *  @asprivate 
 * @protected
 * @override
 */
spark.layouts.HorizontalLayout.prototype.getElementBoundsLeftOfScrollRect = function(scrollRect) {
  return this.spark_layouts_HorizontalLayout_findLayoutElementBounds(this.target, this.firstIndexInView, -1, scrollRect);
};


/**
 *  @asprivate 
 * @protected
 * @override
 */
spark.layouts.HorizontalLayout.prototype.getElementBoundsRightOfScrollRect = function(scrollRect) {
  return this.spark_layouts_HorizontalLayout_findLayoutElementBounds(this.target, this.lastIndexInView, 1, scrollRect);
};


/**
 *  @asprivate
 *  Fills in the result with preferred and min sizes of the element.
 * @private
 * @param {mx.core.ILayoutElement} element
 * @param {number} fixedColumnWidth
 * @param {spark.layouts.HorizontalLayout.SizesAndLimit} result
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout_getElementWidth = function(element, fixedColumnWidth, result) {
  var /** @type {number} */ elementPreferredWidth = isNaN(fixedColumnWidth) ? Math.ceil(element.getPreferredBoundsWidth()) : fixedColumnWidth;
  var /** @type {boolean} */ flexibleWidth = !isNaN(element.percentWidth);
  var /** @type {number} */ elementMinWidth = flexibleWidth ? Math.ceil(element.getMinBoundsWidth()) : elementPreferredWidth;
  result.preferredSize = elementPreferredWidth;
  result.minSize = elementMinWidth;
};


/**
 *  @asprivate
 *  Fills in the result with preferred and min sizes of the element.
 * @private
 * @param {mx.core.ILayoutElement} element
 * @param {boolean} justify
 * @param {spark.layouts.HorizontalLayout.SizesAndLimit} result
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout_getElementHeight = function(element, justify, result) {
  var /** @type {number} */ elementPreferredHeight = Math.ceil(element.getPreferredBoundsHeight());
  var /** @type {boolean} */ flexibleHeight = !isNaN(element.percentHeight) || justify;
  var /** @type {number} */ elementMinHeight = flexibleHeight ? Math.ceil(element.getMinBoundsHeight()) : elementPreferredHeight;
  result.preferredSize = elementPreferredHeight;
  result.minSize = elementMinHeight;
};


/**
 *  @asprivate
 *  Returns [baselineTop, baselineBottom, baselineBottomMin],
 *  where baselineTop is the portion of the elements above the common baseline
 *  and the baselineBottom is the portion of the elements below the common baseline.
 * @private
 * @param {boolean} calculateBottom
 * @return {Array}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout_calculateBaselineTopBottom = function(calculateBottom) {
  var /** @type {number} */ baselineOffset = 0;
  var /** @type {number} */ baselineTop = 0;
  var /** @type {number} */ baselineBottom = 0;
  var /** @type {number} */ baselineBottomMin = 0;
  var /** @type {boolean} */ calculateTop;
  var /** @type {Array} */ temp = spark.layouts.supportClasses.LayoutElementHelper.parseConstraintExp(this.http_$$www_adobe_com$2006$flex$mx$internal__alignmentBaseline);
  if (temp.length == 2 && temp[1] == "maxAscent") {
    baselineOffset = Number(temp[0]);
    calculateTop = true;
  } else {
    calculateTop = false;
    baselineTop = Number(temp[0]);
    if (isNaN(baselineTop)) {
      baselineTop = 0;
      calculateTop = true;
    }
  }
  var /** @type {number} */ count = this.target.numElements;
  for (var /** @type {number} */ i = 0; i < count; i++) {
    var /** @type {mx.core.ILayoutElement} */ element = org.apache.royale.utils.Language.as(this.target.getElementAt(i), mx.core.ILayoutElement);
    if (!element || !element.includeInLayout)
      continue;
    var /** @type {number} */ elementBaseline = 0;
    var /** @type {number} */ baselinePosition = element.baselinePosition;
    var /** @type {number} */ elementBaselineTop = baselinePosition - elementBaseline;
    if (calculateTop)
      baselineTop = Math.max(elementBaselineTop, baselineTop);
    if (calculateBottom) {
      var /** @type {number} */ elementHeight = element.getPreferredBoundsHeight();
      var /** @type {number} */ elementBaselineBottom = elementHeight - elementBaselineTop;
      var /** @type {number} */ elementBaselineBottomMin = elementBaselineBottom;
      if (!isNaN(element.percentHeight))
        elementBaselineBottomMin = element.getMinBoundsHeight() - elementBaselineTop;
      baselineBottom = Math.max(elementBaselineBottom, baselineBottom);
    }
  }
  if (calculateTop)
    baselineTop += baselineOffset;
  return [baselineTop, baselineBottom, baselineBottomMin];
};


/**
 *  @asprivate
 *  @asreturn columns to measure based on elements in layout and any requested/min/max rowCount settings. 
 * @private
 * @param {number} numElementsInLayout
 * @return {number}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout_getColumsToMeasure = function(numElementsInLayout) {
  var /** @type {number} */ columnsToMeasure = 0;
  //var /** @type {number} */ columnsToMeasure = 0;
  if (this.requestedColumnCount != -1)
    columnsToMeasure = this.requestedColumnCount; else {
    columnsToMeasure = numElementsInLayout;
    if (this.requestedMaxColumnCount != -1)
      columnsToMeasure = (Math.min(this.requestedMaxColumnCount, columnsToMeasure)) >> 0;
    if (this.requestedMinColumnCount != -1)
      columnsToMeasure = (Math.max(this.requestedMinColumnCount, columnsToMeasure)) >> 0;
  }
  return columnsToMeasure;
};


/**
 *  @asprivate
 * 
 *  Compute exact values for measuredWidth,Height and  measuredMinWidth,Height.
 *  
 *  Measure each of the layout elements.  If requestedColumnCount >= 0 we 
 *  consider the height and width of as many layout elements, padding with 
 *  typicalLayoutElement if needed, starting with index 0. We then only 
 *  consider the height of the elements remaining.
 * 
 *  If requestedColumnCount is -1, we consider width/height of each element.
 * @private
 * @param {spark.components.supportClasses.GroupBase} layoutTarget
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout_measureReal = function(layoutTarget) {
  var /** @type {spark.layouts.HorizontalLayout.SizesAndLimit} */ size = new spark.layouts.HorizontalLayout.SizesAndLimit();
  var /** @type {boolean} */ alignToBaseline = this.verticalAlign == spark.layouts.VerticalAlign.BASELINE;
  var /** @type {boolean} */ justify = this.verticalAlign == spark.layouts.VerticalAlign.JUSTIFY;
  var /** @type {number} */ numElements = layoutTarget.numElements;
  var /** @type {number} */ numElementsInLayout = numElements;
  var /** @type {number} */ requestedColumnCount = this.requestedColumnCount;
  var /** @type {number} */ columnsMeasured = 0;
  var /** @type {number} */ preferredHeight = 0;
  var /** @type {number} */ preferredWidth = 0;
  var /** @type {number} */ minHeight = 0;
  var /** @type {number} */ minWidth = 0;
  var /** @type {number} */ fixedColumnWidth = NaN;
  if (!this.variableColumnWidth)
    fixedColumnWidth = this.columnWidth;
  var /** @type {number} */ columnsToMeasure = this.spark_layouts_HorizontalLayout_getColumsToMeasure(numElementsInLayout);
  var /** @type {mx.core.ILayoutElement} */ element;
  for (var /** @type {number} */ i = 0; i < numElements; i++) {
    element = org.apache.royale.utils.Language.as(layoutTarget.getElementAt(i), mx.core.ILayoutElement);
    if (!element || !element.includeInLayout) {
      numElementsInLayout--;
      continue;
    }
    if (!alignToBaseline) {
      this.spark_layouts_HorizontalLayout_getElementHeight(element, justify, size);
      preferredHeight = Math.max(preferredHeight, size.preferredSize);
      minHeight = Math.max(minHeight, size.minSize);
    }
    if (columnsMeasured < columnsToMeasure) {
      this.spark_layouts_HorizontalLayout_getElementWidth(element, fixedColumnWidth, size);
      preferredWidth += size.preferredSize;
      minWidth += size.minSize;
      columnsMeasured++;
    }
  }
  columnsToMeasure = this.spark_layouts_HorizontalLayout_getColumsToMeasure(numElementsInLayout);
  if (columnsMeasured < columnsToMeasure) {
    element = this.typicalLayoutElement;
    if (element) {
      if (!alignToBaseline) {
        this.spark_layouts_HorizontalLayout_getElementHeight(element, justify, size);
        preferredHeight = Math.max(preferredHeight, size.preferredSize);
        minHeight = Math.max(minHeight, size.minSize);
      }
      this.spark_layouts_HorizontalLayout_getElementWidth(element, fixedColumnWidth, size);
      preferredWidth += size.preferredSize * (columnsToMeasure - columnsMeasured);
      minWidth += size.minSize * (columnsToMeasure - columnsMeasured);
      columnsMeasured = columnsToMeasure;
    }
  }
  if (alignToBaseline) {
    var /** @type {Array} */ result = this.spark_layouts_HorizontalLayout_calculateBaselineTopBottom(true);
    var /** @type {number} */ top = Number(result[0]);
    var /** @type {number} */ bottom = Number(result[1]);
    var /** @type {number} */ bottomMin = Number(result[2]);
    preferredHeight = Math.ceil(top + bottom);
    minHeight = Math.ceil(top + bottomMin);
  }
  if (columnsMeasured > 1) {
    var /** @type {number} */ hgap = this.gap * (columnsMeasured - 1);
    preferredWidth += hgap;
    minWidth += hgap;
  }
  var /** @type {number} */ hPadding = this.paddingLeft + this.paddingRight;
  var /** @type {number} */ vPadding = this.paddingTop + this.paddingBottom;
  layoutTarget.measuredHeight = preferredHeight + vPadding;
  layoutTarget.measuredWidth = preferredWidth + hPadding;
  layoutTarget.measuredMinHeight = minHeight + vPadding;
  layoutTarget.measuredMinWidth = minWidth + hPadding;
};


/**
 *  @asprivate
 * 
 *  Syncs the LinearLayoutVector llv with typicalLayoutElement and
 *  the target's numElements.  Calling this function accounts
 *  for the possibility that the typicalLayoutElement has changed, or
 *  something that its preferred size depends on has changed.
 * @private
 * @param {spark.components.supportClasses.GroupBase} layoutTarget
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout_updateLLV = function(layoutTarget) {
  if (!this.spark_layouts_HorizontalLayout_llv) {
    this.spark_layouts_HorizontalLayout_llv = new spark.layouts.supportClasses.LinearLayoutVector(spark.layouts.supportClasses.LinearLayoutVector.HORIZONTAL);
    this.spark_layouts_HorizontalLayout_llv.defaultMinorSize = 22;
    this.spark_layouts_HorizontalLayout_llv.defaultMajorSize = 71;
  }
  var /** @type {mx.core.ILayoutElement} */ typicalElt = this.typicalLayoutElement;
  if (typicalElt) {
    var /** @type {number} */ typicalWidth = typicalElt.getPreferredBoundsWidth();
    var /** @type {number} */ typicalHeight = typicalElt.getPreferredBoundsHeight();
    this.spark_layouts_HorizontalLayout_llv.defaultMinorSize = typicalHeight;
    this.spark_layouts_HorizontalLayout_llv.defaultMajorSize = typicalWidth;
  }
  if (!isNaN(this.spark_layouts_HorizontalLayout__columnWidth))
    this.spark_layouts_HorizontalLayout_llv.defaultMajorSize = this.spark_layouts_HorizontalLayout__columnWidth;
  if (layoutTarget)
    this.spark_layouts_HorizontalLayout_llv.length = (layoutTarget.numElements) >>> 0;
  this.spark_layouts_HorizontalLayout_llv.gap = this.gap;
  this.spark_layouts_HorizontalLayout_llv.majorAxisOffset = this.paddingLeft;
};


/**
 *  @asprivate
 * @export
 * @override
 */
spark.layouts.HorizontalLayout.prototype.elementAdded = function(index) {
  if ((index >= 0) && this.useVirtualLayout && this.spark_layouts_HorizontalLayout_llv)
    this.spark_layouts_HorizontalLayout_llv.insert((index) >>> 0);
};


/**
 *  @asprivate
 * @export
 * @override
 */
spark.layouts.HorizontalLayout.prototype.elementRemoved = function(index) {
  if ((index >= 0) && this.useVirtualLayout && this.spark_layouts_HorizontalLayout_llv)
    this.spark_layouts_HorizontalLayout_llv.remove((index) >>> 0);
};


/**
 *  @asprivate
 * 
 *  Compute potentially approximate values for measuredWidth,Height and 
 *  measuredMinWidth,Height.
 * 
 *  This method does not get layout elements from the target except
 *  as a side effect of calling typicalLayoutElement.
 * 
 *  If variableColumnWidth="false" then all dimensions are based on 
 *  typicalLayoutElement and the sizes already cached in llv.  The 
 *  llv's defaultMajorSize, minorSize, and minMinorSize 
 *  are based on typicalLayoutElement.
 * @private
 * @param {spark.components.supportClasses.GroupBase} layoutTarget
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout_measureVirtual = function(layoutTarget) {
  var /** @type {number} */ eltCount = layoutTarget.numElements;
  var /** @type {number} */ measuredEltCount = this.spark_layouts_HorizontalLayout_getColumsToMeasure(eltCount);
  var /** @type {number} */ hPadding = this.paddingLeft + this.paddingRight;
  var /** @type {number} */ vPadding = this.paddingTop + this.paddingBottom;
  if (measuredEltCount <= 0) {
    layoutTarget.measuredWidth = layoutTarget.measuredMinWidth = hPadding;
    layoutTarget.measuredHeight = layoutTarget.measuredMinHeight = vPadding;
    return;
  }
  this.spark_layouts_HorizontalLayout_updateLLV(layoutTarget);
  if (this.variableColumnWidth) {
    var /** @type {number} */ oldLength = -1;
    if (measuredEltCount > this.spark_layouts_HorizontalLayout_llv.length) {
      oldLength = (this.spark_layouts_HorizontalLayout_llv.length) >> 0;
      this.spark_layouts_HorizontalLayout_llv.length = (measuredEltCount) >>> 0;
    }
    var /** @type {number} */ measuredWidth = this.spark_layouts_HorizontalLayout_llv.end((measuredEltCount - 1) >>> 0) + this.paddingRight;
    layoutTarget.measuredWidth = measuredWidth;
    if (oldLength != -1)
      this.spark_layouts_HorizontalLayout_llv.length = (oldLength) >>> 0;
  } else {
    var /** @type {number} */ hgap = (measuredEltCount > 1) ? (measuredEltCount - 1) * this.gap : 0;
    layoutTarget.measuredWidth = (measuredEltCount * this.columnWidth) + hgap + hPadding;
  }
  layoutTarget.measuredHeight = this.spark_layouts_HorizontalLayout_llv.minorSize + vPadding;
  layoutTarget.measuredMinWidth = layoutTarget.measuredWidth;
  layoutTarget.measuredMinHeight = (this.verticalAlign == spark.layouts.VerticalAlign.JUSTIFY) ? this.spark_layouts_HorizontalLayout_llv.minMinorSize + vPadding : layoutTarget.measuredHeight;
};


/**
 *  @asprivate
 * 
 *  If requestedColumnCount is specified then as many layout elements
 *  or "columns" are measured, starting with element 0, otherwise all of the 
 *  layout elements are measured.
 *  
 *  If requestedColumnCount is specified and is greater than the
 *  number of layout elements, then the typicalLayoutElement is used
 *  in place of the missing layout elements.
 * 
 *  If variableColumnWidth="true", then the layoutTarget's measuredWidth
 *  is the sum of preferred widths of the layout elements, plus the sum of the
 *  gaps between elements, and its measuredHeight is the max of the elements' 
 *  preferred heights.
 * 
 *  If variableColumnWidth="false", then the layoutTarget's measuredWidth
 *  is columnWidth multiplied by the number or layout elements, plus the 
 *  sum of the gaps between elements.
 * 
 *  The layoutTarget's measuredMinWidth is the sum of the minWidths of 
 *  layout elements that have specified a value for the percentWidth
 *  property, and the preferredWidth of the elements that have not, 
 *  plus the sum of the gaps between elements.
 * 
 *  The difference reflects the fact that elements which specify 
 *  percentWidth are considered to be "flexible" and updateDisplayList 
 *  will give flexible components at least their minWidth.  
 * 
 *  Layout elements that aren't flexible always get their preferred width.
 * 
 *  The layoutTarget's measuredMinHeight is the max of the minHeights for 
 *  elements that have specified percentHeight (that are "flexible") and the 
 *  preferredHeight of the elements that have not.
 * 
 *  As before the difference is due to the fact that flexible items are only
 *  guaranteed their minHeight.
 * @export
 * @override
 */
spark.layouts.HorizontalLayout.prototype.measure = function() {
  var /** @type {spark.components.supportClasses.GroupBase} */ layoutTarget = this.target;
  if (!layoutTarget)
    return;
  if (this.useVirtualLayout)
    this.spark_layouts_HorizontalLayout_measureVirtual(layoutTarget);
  else
    this.spark_layouts_HorizontalLayout_measureReal(layoutTarget);
  layoutTarget.measuredWidth = Math.ceil(layoutTarget.measuredWidth);
  layoutTarget.measuredHeight = Math.ceil(layoutTarget.measuredHeight);
  layoutTarget.measuredMinWidth = Math.ceil(layoutTarget.measuredMinWidth);
  layoutTarget.measuredMinHeight = Math.ceil(layoutTarget.measuredMinHeight);
};


/**
 *  @asprivate 
 * @export
 * @override
 */
spark.layouts.HorizontalLayout.prototype.getNavigationDestinationIndex = function(currentIndex, navigationUnit, arrowKeysWrapFocus) {
  var /** @type {number} */ newIndex = 0;
  if (!this.target || this.target.numElements < 1)
    return -1;
  var /** @type {number} */ maxIndex = (this.target.numElements - 1) >> 0;
  if (currentIndex == -1) {
    if (navigationUnit == spark.core.NavigationUnit.LEFT)
      return (arrowKeysWrapFocus ? maxIndex : -1) >> 0;
    if (navigationUnit == spark.core.NavigationUnit.RIGHT)
      return 0;
  }
  currentIndex = (Math.max(0, Math.min(maxIndex, currentIndex))) >> 0;
  //var /** @type {number} */ newIndex = 0;
  var /** @type {org.apache.royale.geom.Rectangle} */ bounds;
  var /** @type {number} */ x;
  switch (navigationUnit) {
    case spark.core.NavigationUnit.LEFT:
      if (arrowKeysWrapFocus && currentIndex == 0)
        newIndex = maxIndex;
      else
        newIndex = (currentIndex - 1) >> 0;
      break;
    case spark.core.NavigationUnit.RIGHT:
      if (arrowKeysWrapFocus && currentIndex == maxIndex)
        newIndex = 0;
      else
        newIndex = (currentIndex + 1) >> 0;
      break;
    case spark.core.NavigationUnit.PAGE_UP:
    
    case spark.core.NavigationUnit.PAGE_LEFT:
      var /** @type {number} */ firstVisible = this.firstIndexInView;
      var /** @type {number} */ firstFullyVisible = firstVisible;
      if (this.fractionOfElementInView(firstFullyVisible) < 1)
        firstFullyVisible += 1;
      if (firstFullyVisible < currentIndex && currentIndex <= this.lastIndexInView)
        newIndex = firstFullyVisible; else {
        if (currentIndex == firstFullyVisible || currentIndex == firstVisible) {
          x = this.getHorizontalScrollPositionDelta(spark.core.NavigationUnit.PAGE_LEFT) + this.getScrollRect().left;
        } else {
          x = this.getElementBounds(currentIndex).right - this.getScrollRect().width;
        }
        newIndex = (currentIndex - 1) >> 0;
        while (0 <= newIndex) {
          bounds = this.getElementBounds(newIndex);
          if (bounds && bounds.left < x) {
            newIndex = (Math.min(currentIndex - 1, newIndex + 1)) >> 0;
            break;
          }
          newIndex--;
        }
      }
      break;
    case spark.core.NavigationUnit.PAGE_DOWN:
    
    case spark.core.NavigationUnit.PAGE_RIGHT:
      var /** @type {number} */ lastVisible = this.lastIndexInView;
      var /** @type {number} */ lastFullyVisible = lastVisible;
      if (this.fractionOfElementInView(lastFullyVisible) < 1)
        lastFullyVisible -= 1;
      if (this.firstIndexInView <= currentIndex && currentIndex < lastFullyVisible)
        newIndex = lastFullyVisible; else {
        if (currentIndex == lastFullyVisible || currentIndex == lastVisible) {
          x = this.getHorizontalScrollPositionDelta(spark.core.NavigationUnit.PAGE_RIGHT) + this.getScrollRect().right;
        } else {
          x = this.getElementBounds(currentIndex).left + this.getScrollRect().width;
        }
        newIndex = (currentIndex + 1) >> 0;
        while (newIndex <= maxIndex) {
          bounds = this.getElementBounds(newIndex);
          if (bounds && bounds.right > x) {
            newIndex = (Math.max(currentIndex + 1, newIndex - 1)) >> 0;
            break;
          }
          newIndex++;
        }
      }
      break;
    default:
      return spark.layouts.HorizontalLayout.superClass_.getNavigationDestinationIndex.apply(this, [ currentIndex, navigationUnit, arrowKeysWrapFocus] );
  }
  return (Math.max(0, Math.min(maxIndex, newIndex))) >> 0;
};


/**
 *  @asprivate
 * 
 *  Used only for virtual layout.
 * @private
 * @param {mx.core.ILayoutElement} elt
 * @param {number} targetHeight
 * @param {number} containerHeight
 * @return {number}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout_calculateElementHeight = function(elt, targetHeight, containerHeight) {
  var /** @type {number} */ percentHeight = elt.percentHeight;
  if (!isNaN(percentHeight)) {
    var /** @type {number} */ height = percentHeight * 0.01 * targetHeight;
    return Math.min(targetHeight, Math.min(elt.getMaxBoundsHeight(), Math.max(elt.getMinBoundsHeight(), height)));
  }
  switch (this.verticalAlign) {
    case spark.layouts.VerticalAlign.JUSTIFY:
      return targetHeight;
    case spark.layouts.VerticalAlign.CONTENT_JUSTIFY:
      return Math.max(elt.getPreferredBoundsHeight(), containerHeight);
  }
  return NaN;
};


/**
 *  @asprivate
 * 
 *  Used only for virtual layout.
 * @private
 * @param {mx.core.ILayoutElement} elt
 * @param {number} eltHeight
 * @param {number} containerHeight
 * @return {number}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout_calculateElementY = function(elt, eltHeight, containerHeight) {
  switch (this.verticalAlign) {
    case spark.layouts.VerticalAlign.MIDDLE:
      return Math.round((containerHeight - eltHeight) * 0.5);
    case spark.layouts.VerticalAlign.BOTTOM:
      return containerHeight - eltHeight;
  }
  return 0;
};


/**
 *  @asprivate
 * 
 *  Update the layout of the virtualized elements that overlap
 *  the scrollRect's horizontal extent.
 *
 *  The width of each layout element will be its preferred width, and its
 *  x will be the right edge of the previous item, plus the gap.
 * 
 *  No support for percentWidth, includeInLayout=false, or null layoutElements,
 * 
 *  The height of each layout element will be set to its preferred height, unless
 *  one of the following is true:
 * 
 *  - If percentHeight is specified for this element, then its height will be the
 *  specified percentage of the target's actual (unscaled) height, clipped 
 *  the layout element's minimum and maximum height.
 * 
 *  - If verticalAlign is "justify", then the element's height will
 *  be set to the target's actual (unscaled) height.
 * 
 *  - If verticalAlign is "contentJustify", then the element's height
 *  will be set to the target's content height.
 * 
 *  The Y coordinate of each layout element will be set to 0 unless one of the
 *  following is true:
 * 
 *  - If verticalAlign is "middle" then y is set so that the element's preferred
 *  height is centered within the larget of the contentHeight and the target's height:
 *      y = (Math.max(contentHeight, target.height) - layoutElementHeight) * 0.5
 * 
 *  - If verticalAlign is "bottom" the y is set so that the element's bottom
 *  edge is aligned with the the bottom edge of the content:
 *      y = (Math.max(contentHeight, target.height) - layoutElementHeight)
 * 
 *  Implementation note: unless verticalAlign is either "justify" or 
 *  "top", the layout elements' y or height depends on the contentHeight.
 *  The contentHeight is a maximum and although it may be updated to 
 *  different value after all (viewable) elements have been laid out, it
 *  often does not change.  For that reason we use the current contentHeight
 *  for the initial layout and then, if it has changed, we loop through 
 *  the layout items again and fix up the y/height values.
 * @private
 * @param {number} targetWidth
 * @param {number} targetHeight
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout_updateDisplayListVirtual = function(targetWidth, targetHeight) {
  var /** @type {spark.components.supportClasses.GroupBase} */ layoutTarget = this.target;
  var /** @type {number} */ eltCount = layoutTarget.numElements;
  targetHeight = Math.max(0, targetHeight - this.paddingTop - this.paddingBottom);
  var /** @type {number} */ minVisibleX = layoutTarget.horizontalScrollPosition;
  var /** @type {number} */ maxVisibleX = minVisibleX + targetWidth;
  var /** @type {number} */ contentWidth;
  var /** @type {number} */ paddedContentWidth;
  this.spark_layouts_HorizontalLayout_updateLLV(layoutTarget);
  var /** @type {number} */ startIndex = this.spark_layouts_HorizontalLayout_llv.indexOf(Math.max(0, minVisibleX + this.gap));
  if (startIndex == -1) {
    contentWidth = this.spark_layouts_HorizontalLayout_llv.end((this.spark_layouts_HorizontalLayout_llv.length - 1) >>> 0) - this.paddingLeft;
    paddedContentWidth = Math.ceil(contentWidth + this.paddingLeft + this.paddingRight);
    layoutTarget.setContentSize(paddedContentWidth, layoutTarget.contentHeight);
    return;
  }
  var /** @type {number} */ fixedColumnWidth = NaN;
  if (!this.variableColumnWidth)
    fixedColumnWidth = this.columnWidth;
  var /** @type {boolean} */ justifyHeights = this.verticalAlign == spark.layouts.VerticalAlign.JUSTIFY;
  var /** @type {number} */ eltWidth = NaN;
  var /** @type {number} */ eltHeight = justifyHeights ? Math.max(this.spark_layouts_HorizontalLayout_llv.minMinorSize, targetHeight) : this.spark_layouts_HorizontalLayout_llv.minorSize;
  var /** @type {number} */ contentHeight = justifyHeights ? Math.max(this.spark_layouts_HorizontalLayout_llv.minMinorSize, targetHeight) : this.spark_layouts_HorizontalLayout_llv.minorSize;
  var /** @type {number} */ containerHeight = Math.max(contentHeight, targetHeight);
  var /** @type {number} */ x = this.spark_layouts_HorizontalLayout_llv.start((startIndex) >>> 0);
  var /** @type {number} */ index = startIndex;
  var /** @type {number} */ y0 = this.paddingTop;
  for (; (x < maxVisibleX) && (index < eltCount); index++) {
    var /** @type {mx.core.ILayoutElement} */ elt = layoutTarget.getVirtualElementAt(index);
    var /** @type {number} */ w = fixedColumnWidth;
    var /** @type {number} */ h = this.spark_layouts_HorizontalLayout_calculateElementHeight(elt, targetHeight, containerHeight);
    elt.setLayoutBoundsSize(w, h);
    w = elt.getLayoutBoundsWidth();
    h = elt.getLayoutBoundsHeight();
    var /** @type {number} */ y = y0 + this.spark_layouts_HorizontalLayout_calculateElementY(elt, h, containerHeight);
    elt.setLayoutBoundsPosition(x, y);
    this.spark_layouts_HorizontalLayout_llv.cacheDimensions((index) >>> 0, elt);
    x += w + this.gap;
  }
  var /** @type {number} */ endIndex = (index - 1) >> 0;
  if (!justifyHeights && (this.spark_layouts_HorizontalLayout_llv.minorSize != contentHeight)) {
    contentHeight = this.spark_layouts_HorizontalLayout_llv.minorSize;
    containerHeight = Math.max(contentHeight, targetHeight);
    if ((this.verticalAlign != spark.layouts.VerticalAlign.TOP) && (this.verticalAlign != spark.layouts.VerticalAlign.JUSTIFY)) {
      for (index = startIndex; index <= endIndex; index++) {
        elt = org.apache.royale.utils.Language.as(layoutTarget.getElementAt(index), mx.core.ILayoutElement);
        h = this.spark_layouts_HorizontalLayout_calculateElementHeight(elt, targetHeight, containerHeight);
        elt.setLayoutBoundsSize(elt.getLayoutBoundsWidth(), h);
        h = elt.getLayoutBoundsHeight();
        y = y0 + this.spark_layouts_HorizontalLayout_calculateElementY(elt, h, containerHeight);
        elt.setLayoutBoundsPosition(elt.getLayoutBoundsX(), y);
      }
    }
  }
  contentWidth = this.spark_layouts_HorizontalLayout_llv.end((this.spark_layouts_HorizontalLayout_llv.length - 1) >>> 0) - this.paddingLeft;
  targetWidth = Math.max(0, targetWidth - this.paddingLeft - this.paddingRight);
  if (contentWidth < targetWidth) {
    var /** @type {number} */ excessWidth = targetWidth - contentWidth;
    var /** @type {number} */ dx = 0;
    var /** @type {string} */ hAlign = this.horizontalAlign;
    if (hAlign == spark.layouts.HorizontalAlign.CENTER) {
      dx = Math.round(excessWidth / 2);
    } else if (hAlign == spark.layouts.HorizontalAlign.RIGHT) {
      dx = excessWidth;
    }
    if (dx > 0) {
      for (index = startIndex; index <= endIndex; index++) {
        elt = org.apache.royale.utils.Language.as(layoutTarget.getElementAt(index), mx.core.ILayoutElement);
        elt.setLayoutBoundsPosition(dx + elt.getLayoutBoundsX(), elt.getLayoutBoundsY());
      }
      contentWidth += dx;
    }
  }
  this.spark_layouts_HorizontalLayout_setColumnCount((index - startIndex) >> 0);
  this.spark_layouts_HorizontalLayout_setIndexInView(startIndex, endIndex);
  paddedContentWidth = Math.ceil(contentWidth + this.paddingLeft + this.paddingRight);
  var /** @type {number} */ paddedContentHeight = Math.ceil(contentHeight + this.paddingTop + this.paddingBottom);
  layoutTarget.setContentSize(paddedContentWidth, paddedContentHeight);
};


/**
 *  @asprivate 
 * @private
 * @param {number} targetWidth
 * @param {number} targetHeight
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout_updateDisplayListReal = function(targetWidth, targetHeight) {
  var /** @type {spark.components.supportClasses.GroupBase} */ layoutTarget = this.target;
  targetWidth = Math.max(0, targetWidth - this.paddingLeft - this.paddingRight);
  targetHeight = Math.max(0, targetHeight - this.paddingTop - this.paddingBottom);
  var /** @type {mx.core.ILayoutElement} */ layoutElement;
  var /** @type {number} */ count = layoutTarget.numElements;
  var /** @type {number} */ containerHeight = targetHeight;
  if (this.verticalAlign == spark.layouts.VerticalAlign.CONTENT_JUSTIFY || (this.clipAndEnableScrolling && (this.verticalAlign == spark.layouts.VerticalAlign.MIDDLE || this.verticalAlign == spark.layouts.VerticalAlign.BOTTOM))) {
    for (var /** @type {number} */ i = 0; i < count; i++) {
      layoutElement = org.apache.royale.utils.Language.as(layoutTarget.getElementAt(i), mx.core.ILayoutElement);
      if (!layoutElement || !layoutElement.includeInLayout)
        continue;
      var /** @type {number} */ layoutElementHeight;
      if (!isNaN(layoutElement.percentHeight))
        layoutElementHeight = spark.layouts.HorizontalLayout.calculatePercentHeight(layoutElement, targetHeight);
      else
        layoutElementHeight = layoutElement.getPreferredBoundsHeight();
      containerHeight = Math.max(containerHeight, Math.ceil(layoutElementHeight));
    }
  }
  var /** @type {number} */ excessWidth = this.spark_layouts_HorizontalLayout_distributeWidth(targetWidth, targetHeight, containerHeight);
  var /** @type {number} */ vAlign = 0;
  if (this.verticalAlign == spark.layouts.VerticalAlign.MIDDLE)
    vAlign = .5;
  else if (this.verticalAlign == spark.layouts.VerticalAlign.BOTTOM)
    vAlign = 1;
  var /** @type {number} */ actualBaseline = 0;
  var /** @type {boolean} */ alignToBaseline = this.verticalAlign == spark.layouts.VerticalAlign.BASELINE;
  if (alignToBaseline) {
    var /** @type {Array} */ result = this.spark_layouts_HorizontalLayout_calculateBaselineTopBottom(false);
    actualBaseline = Number(result[0]);
  }
  var /** @type {number} */ visibleColumns = 0;
  var /** @type {number} */ minVisibleX = layoutTarget.horizontalScrollPosition;
  var /** @type {number} */ maxVisibleX = minVisibleX + targetWidth;
  var /** @type {number} */ x = this.paddingLeft;
  var /** @type {number} */ y0 = this.paddingTop;
  var /** @type {number} */ maxX = this.paddingLeft;
  var /** @type {number} */ maxY = this.paddingTop;
  var /** @type {number} */ firstColInView = -1;
  var /** @type {number} */ lastColInView = -1;
  if (excessWidth > 0 || !this.clipAndEnableScrolling) {
    var /** @type {string} */ hAlign = this.horizontalAlign;
    if (hAlign == spark.layouts.HorizontalAlign.CENTER) {
      x = this.paddingLeft + Math.round(excessWidth / 2);
    } else if (hAlign == spark.layouts.HorizontalAlign.RIGHT) {
      x = this.paddingLeft + excessWidth;
    }
  }
  for (var /** @type {number} */ index = 0; index < count; index++) {
    layoutElement = org.apache.royale.utils.Language.as(layoutTarget.getElementAt(index), mx.core.ILayoutElement);
    if (!layoutElement || !layoutElement.includeInLayout)
      continue;
    var /** @type {number} */ dx = Math.ceil(layoutElement.getLayoutBoundsWidth());
    var /** @type {number} */ dy = Math.ceil(layoutElement.getLayoutBoundsHeight());
    var /** @type {number} */ y;
    if (alignToBaseline) {
      var /** @type {number} */ elementBaseline = 0;
      var /** @type {number} */ baselinePosition = layoutElement.baselinePosition;
      y = y0 + actualBaseline + elementBaseline - baselinePosition;
    } else {
      y = y0 + (containerHeight - dy) * vAlign;
      if (vAlign == 0.5)
        y = Math.round(y);
    }
    layoutElement.setLayoutBoundsPosition(x, y);
    maxX = Math.max(maxX, x + dx);
    maxY = Math.max(maxY, y + dy);
    if (!this.clipAndEnableScrolling || ((x < maxVisibleX) && ((x + dx) > minVisibleX)) || ((dx <= 0) && ((x == maxVisibleX) || (x == minVisibleX)))) {
      visibleColumns += 1;
      if (firstColInView == -1)
        firstColInView = lastColInView = index;
      else
        lastColInView = index;
    }
    x += dx + this.gap;
  }
  this.spark_layouts_HorizontalLayout_setColumnCount((visibleColumns) >> 0);
  this.spark_layouts_HorizontalLayout_setIndexInView(firstColInView, lastColInView);
  layoutTarget.setContentSize(Math.ceil(maxX + this.paddingRight), Math.ceil(maxY + this.paddingBottom));
};


/**
 *  @asprivate
 * 
 *  This function sets the width of each child
 *  so that the widths add up to <code>width</code>. 
 *  Each child is set to its preferred width
 *  if its percentWidth is zero.
 *  If its percentWidth is a positive number,
 *  the child grows (or shrinks) to consume its
 *  share of extra space.
 *  
 *  The return value is any extra space that's left over
 *  after growing all children to their maxWidth.
 * @private
 * @param {number} width
 * @param {number} height
 * @param {number} restrictedHeight
 * @return {number}
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout_distributeWidth = function(width, height, restrictedHeight) {
  var /** @type {number} */ spaceToDistribute = width;
  var /** @type {number} */ totalPercentWidth = 0;
  var /** @type {Array} */ childInfoArray = [];
  var /** @type {spark.layouts.HorizontalLayout.HLayoutElementFlexChildInfo} */ childInfo;
  var /** @type {number} */ newHeight;
  var /** @type {mx.core.ILayoutElement} */ layoutElement;
  var /** @type {number} */ cw = this.variableColumnWidth ? 0 : Math.ceil(this.columnWidth);
  var /** @type {number} */ count = this.target.numElements;
  var /** @type {number} */ totalCount = count;
  for (var /** @type {number} */ index = 0; index < count; index++) {
    layoutElement = org.apache.royale.utils.Language.as(this.target.getElementAt(index), mx.core.ILayoutElement);
    if (!layoutElement || !layoutElement.includeInLayout) {
      totalCount--;
      continue;
    }
    if (!isNaN(layoutElement.percentWidth) && this.variableColumnWidth) {
      totalPercentWidth += layoutElement.percentWidth;
      childInfo = new spark.layouts.HorizontalLayout.HLayoutElementFlexChildInfo();
      childInfo.layoutElement = layoutElement;
      childInfo.percent = layoutElement.percentWidth;
      childInfo.min = layoutElement.getMinBoundsWidth();
      childInfo.max = layoutElement.getMaxBoundsWidth();
      childInfoArray.push(childInfo);
    } else {
      spark.layouts.HorizontalLayout.sizeLayoutElement(layoutElement, height, this.verticalAlign, restrictedHeight, NaN, this.variableColumnWidth, cw);
      spaceToDistribute -= Math.ceil(layoutElement.getLayoutBoundsWidth());
    }
  }
  if (totalCount > 1)
    spaceToDistribute -= (totalCount - 1) * this.gap;
  if (totalPercentWidth) {
    mx.containers.utilityClasses.Flex.flexChildrenProportionally(width, spaceToDistribute, totalPercentWidth, childInfoArray);
    var /** @type {number} */ roundOff = 0;
    var foreachiter0_target = childInfoArray;
    for (var foreachiter0 in foreachiter0_target) 
    {
    childInfo = foreachiter0_target[foreachiter0];
    {
      var /** @type {number} */ childSize = (Math.round(childInfo.size + roundOff)) >> 0;
      roundOff += childInfo.size - childSize;
      spark.layouts.HorizontalLayout.sizeLayoutElement(childInfo.layoutElement, height, this.verticalAlign, restrictedHeight, childSize, this.variableColumnWidth, cw);
      spaceToDistribute -= childSize;
    }}
    
  }
  return spaceToDistribute;
};


/**
 *  @asprivate
 * @export
 * @override
 */
spark.layouts.HorizontalLayout.prototype.updateDisplayList = function(unscaledWidth, unscaledHeight) {
  spark.layouts.HorizontalLayout.superClass_.updateDisplayList.apply(this, [ unscaledWidth, unscaledHeight] );
  var /** @type {spark.components.supportClasses.GroupBase} */ layoutTarget = this.target;
  if (!layoutTarget)
    return;
  if ((layoutTarget.numElements == 0) || (unscaledWidth == 0) || (unscaledHeight == 0)) {
    this.spark_layouts_HorizontalLayout_setColumnCount(0);
    this.spark_layouts_HorizontalLayout_setIndexInView(-1, -1);
    if (layoutTarget.numElements == 0)
      layoutTarget.setContentSize(Math.ceil(this.paddingLeft + this.paddingRight), Math.ceil(this.paddingTop + this.paddingBottom));
    return;
  }
  if (this.useVirtualLayout)
    this.spark_layouts_HorizontalLayout_updateDisplayListVirtual(unscaledWidth, unscaledHeight);
  else
    this.spark_layouts_HorizontalLayout_updateDisplayListReal(unscaledWidth, unscaledHeight);
};


/**
 *  @asprivate 
 *  Convenience function for subclasses that invalidates the
 *  target's size and displayList so that both layout's <code>measure()</code>
 *  and <code>updateDisplayList</code> methods get called.
 * 
 *  <p>Typically a layout invalidates the target's size and display list so that
 *  it gets a chance to recalculate the target's default size and also size and
 *  position the target's elements. For example changing the <code>gap</code>
 *  property on a <code>VerticalLayout</code> will internally call this method
 *  to ensure that the elements are re-arranged with the new setting and the
 *  target's default size is recomputed.</p> 
 * @private
 */
spark.layouts.HorizontalLayout.prototype.spark_layouts_HorizontalLayout_invalidateTargetSizeAndDisplayList = function() {
};


/**
 *  @asprivate 
 * @protected
 * @override
 */
spark.layouts.HorizontalLayout.prototype.calculateDropIndex = function(x, y) {
  var /** @type {spark.components.supportClasses.GroupBase} */ layoutTarget = this.target;
  var /** @type {number} */ count = layoutTarget.numElements;
  if (count == 0)
    return 0;
  var /** @type {number} */ minDistance = Number.MAX_VALUE;
  var /** @type {number} */ bestIndex = -1;
  var /** @type {number} */ start = this.firstIndexInView;
  var /** @type {number} */ end = this.lastIndexInView;
  for (var /** @type {number} */ i = start; i <= end; i++) {
    var /** @type {org.apache.royale.geom.Rectangle} */ elementBounds = this.getElementBounds(i);
    if (!elementBounds)
      continue;
    if (elementBounds.left <= x && x <= elementBounds.right) {
      var /** @type {number} */ centerX = elementBounds.x + elementBounds.width / 2;
      return ((x < centerX) ? i : i + 1) >> 0;
    }
    var /** @type {number} */ curDistance = Math.min(Math.abs(x - elementBounds.left), Math.abs(x - elementBounds.right));
    if (curDistance < minDistance) {
      minDistance = curDistance;
      bestIndex = ((x < elementBounds.left) ? i : i + 1) >> 0;
    }
  }
  if (bestIndex == -1)
    bestIndex = (this.getElementBounds(0).x < x ? count : 0) >> 0;
  return bestIndex;
};


/**
 *  @asprivate
 * @protected
 * @override
 */
spark.layouts.HorizontalLayout.prototype.calculateDropIndicatorBounds = function(dropLocation) {
  var /** @type {number} */ dropIndex = dropLocation.dropIndex;
  var /** @type {number} */ count = this.target.numElements;
  var /** @type {number} */ gap = this.gap;
  if (gap < 0 && dropIndex == count)
    gap = 0;
  var /** @type {number} */ emptySpace = (0 < gap) ? gap : 0;
  var /** @type {number} */ emptySpaceLeft = 0;
  if (this.target.numElements > 0) {
    emptySpaceLeft = (dropIndex < count) ? this.getElementBounds(dropIndex).left - emptySpace : this.getElementBounds((dropIndex - 1) >> 0).right + gap - emptySpace;
  }
  var /** @type {number} */ width = emptySpace;
  var /** @type {number} */ height = Math.max(this.target.height, this.target.contentHeight) - this.paddingTop - this.paddingBottom;
  if (org.apache.royale.utils.Language.is(this.dropIndicator, mx.core.IVisualElement)) {
    var /** @type {mx.core.IVisualElement} */ element = org.apache.royale.utils.Language.as(this.dropIndicator, mx.core.IVisualElement, true);
    width = Math.max(Math.min(width, element.getMaxBoundsWidth(false)), element.getMinBoundsWidth(false));
  }
  var /** @type {number} */ x = emptySpaceLeft + Math.round((emptySpace - width) / 2);
  x = Math.max(-Math.ceil(width / 2), Math.min(this.target.contentWidth - Math.ceil(width / 2), x));
  var /** @type {number} */ y = this.paddingTop;
  return new org.apache.royale.geom.Rectangle(x, y, width, height);
};


/**
 *  @asprivate
 *  Identifies the element which has its "compare point" located closest 
 *  to the specified position.
 * @export
 * @override
 */
spark.layouts.HorizontalLayout.prototype.http_$$www_adobe_com$2006$flex$mx$internal__getElementNearestScrollPosition = function(position, elementComparePoint) {
  elementComparePoint = typeof elementComparePoint !== 'undefined' ? elementComparePoint : "center";
  if (!this.useVirtualLayout)
    return spark.layouts.HorizontalLayout.superClass_.http_$$www_adobe_com$2006$flex$mx$internal__getElementNearestScrollPosition.apply(this, [ position, elementComparePoint] );
  var /** @type {spark.components.supportClasses.GroupBase} */ g = org.apache.royale.utils.Language.as(this.target, spark.components.supportClasses.GroupBase, true);
  if (!g)
    return -1;
  this.spark_layouts_HorizontalLayout_updateLLV(g);
  var /** @type {number} */ index = this.spark_layouts_HorizontalLayout_llv.indexOf(position.x);
  if (index == -1)
    index = (position.x < 0 ? 0 : g.numElements - 1) >> 0;
  var /** @type {org.apache.royale.geom.Rectangle} */ bounds = this.spark_layouts_HorizontalLayout_llv.getBounds((index) >>> 0);
  var /** @type {org.apache.royale.geom.Rectangle} */ adjacentBounds;
  if ((elementComparePoint == "topRight" || elementComparePoint == "bottomRight") && index > 0) {
    adjacentBounds = this.spark_layouts_HorizontalLayout_llv.getBounds((index - 1) >>> 0);
    if (org.apache.royale.geom.Point.distance(position, adjacentBounds.bottomRight) < org.apache.royale.geom.Point.distance(position, bounds.bottomRight))
      index--;
  }
  if ((elementComparePoint == "topLeft" || elementComparePoint == "bottomLeft") && index < g.numElements - 1) {
    adjacentBounds = this.spark_layouts_HorizontalLayout_llv.getBounds((index + 1) >>> 0);
    if (org.apache.royale.geom.Point.distance(position, adjacentBounds.topLeft) < org.apache.royale.geom.Point.distance(position, bounds.topLeft))
      index++;
  }
  return index;
};


spark.layouts.HorizontalLayout.prototype.http_$$www_adobe_com$2006$flex$mx$internal__get__alignmentBaseline = function() {
  return this.spark_layouts_HorizontalLayout__alignmentBaseline;
};


spark.layouts.HorizontalLayout.prototype.http_$$www_adobe_com$2006$flex$mx$internal__set__alignmentBaseline = function(value) {
  if (this.spark_layouts_HorizontalLayout__alignmentBaseline == value)
    return;
  this.spark_layouts_HorizontalLayout__alignmentBaseline = value;
  this.spark_layouts_HorizontalLayout_invalidateTargetSizeAndDisplayList();
};


spark.layouts.HorizontalLayout.prototype.get__gap = function() {
  return this.spark_layouts_HorizontalLayout__gap;
};


spark.layouts.HorizontalLayout.prototype.set__gap = function(value) {
  if (this.spark_layouts_HorizontalLayout__gap == value)
    return;
  this.spark_layouts_HorizontalLayout__gap = value;
  this.spark_layouts_HorizontalLayout_invalidateTargetSizeAndDisplayList();
};


spark.layouts.HorizontalLayout.prototype.get__columnCount = function() {
  return this.spark_layouts_HorizontalLayout__columnCount;
};


spark.layouts.HorizontalLayout.prototype.get__padding = function() {
  return this.spark_layouts_HorizontalLayout__padding;
};


spark.layouts.HorizontalLayout.prototype.set__padding = function(value) {
  if (this.spark_layouts_HorizontalLayout__padding == value)
    return;
  this.spark_layouts_HorizontalLayout__padding = value;
  this.paddingBottom = this.spark_layouts_HorizontalLayout__padding;
  this.paddingLeft = this.spark_layouts_HorizontalLayout__padding;
  this.paddingRight = this.spark_layouts_HorizontalLayout__padding;
  this.paddingTop = this.spark_layouts_HorizontalLayout__padding;
  this.spark_layouts_HorizontalLayout_invalidateTargetSizeAndDisplayList();
};


spark.layouts.HorizontalLayout.prototype.get__paddingLeft = function() {
  return this.spark_layouts_HorizontalLayout__paddingLeft;
};


spark.layouts.HorizontalLayout.prototype.set__paddingLeft = function(value) {
  if (this.spark_layouts_HorizontalLayout__paddingLeft == value)
    return;
  this.spark_layouts_HorizontalLayout__paddingLeft = value;
  this.spark_layouts_HorizontalLayout_invalidateTargetSizeAndDisplayList();
};


spark.layouts.HorizontalLayout.prototype.get__paddingRight = function() {
  return this.spark_layouts_HorizontalLayout__paddingRight;
};


spark.layouts.HorizontalLayout.prototype.set__paddingRight = function(value) {
  if (this.spark_layouts_HorizontalLayout__paddingRight == value)
    return;
  this.spark_layouts_HorizontalLayout__paddingRight = value;
  this.spark_layouts_HorizontalLayout_invalidateTargetSizeAndDisplayList();
};


spark.layouts.HorizontalLayout.prototype.get__paddingTop = function() {
  return this.spark_layouts_HorizontalLayout__paddingTop;
};


spark.layouts.HorizontalLayout.prototype.set__paddingTop = function(value) {
  if (this.spark_layouts_HorizontalLayout__paddingTop == value)
    return;
  this.spark_layouts_HorizontalLayout__paddingTop = value;
  this.spark_layouts_HorizontalLayout_invalidateTargetSizeAndDisplayList();
};


spark.layouts.HorizontalLayout.prototype.get__paddingBottom = function() {
  return this.spark_layouts_HorizontalLayout__paddingBottom;
};


spark.layouts.HorizontalLayout.prototype.set__paddingBottom = function(value) {
  if (this.spark_layouts_HorizontalLayout__paddingBottom == value)
    return;
  this.spark_layouts_HorizontalLayout__paddingBottom = value;
  this.spark_layouts_HorizontalLayout_invalidateTargetSizeAndDisplayList();
};


spark.layouts.HorizontalLayout.prototype.get__requestedMaxColumnCount = function() {
  return this.spark_layouts_HorizontalLayout__requestedMaxColumnCount;
};


spark.layouts.HorizontalLayout.prototype.set__requestedMaxColumnCount = function(value) {
  if (this.spark_layouts_HorizontalLayout__requestedMaxColumnCount == value)
    return;
  this.spark_layouts_HorizontalLayout__requestedMaxColumnCount = value;
  if (this.target)
    this.target.invalidateSize();
};


spark.layouts.HorizontalLayout.prototype.get__requestedMinColumnCount = function() {
  return this.spark_layouts_HorizontalLayout__requestedMinColumnCount;
};


spark.layouts.HorizontalLayout.prototype.set__requestedMinColumnCount = function(value) {
  if (this.spark_layouts_HorizontalLayout__requestedMinColumnCount == value)
    return;
  this.spark_layouts_HorizontalLayout__requestedMinColumnCount = value;
  if (this.target)
    this.target.invalidateSize();
};


spark.layouts.HorizontalLayout.prototype.get__requestedColumnCount = function() {
  return this.spark_layouts_HorizontalLayout__requestedColumnCount;
};


spark.layouts.HorizontalLayout.prototype.set__requestedColumnCount = function(value) {
  if (this.spark_layouts_HorizontalLayout__requestedColumnCount == value)
    return;
  this.spark_layouts_HorizontalLayout__requestedColumnCount = value;
  if (this.target)
    this.target.invalidateSize();
};


spark.layouts.HorizontalLayout.prototype.get__columnWidth = function() {
  if (!isNaN(this.spark_layouts_HorizontalLayout__columnWidth))
    return this.spark_layouts_HorizontalLayout__columnWidth; else {
    var /** @type {mx.core.ILayoutElement} */ elt = this.typicalLayoutElement;
    return elt ? elt.getPreferredBoundsWidth() : 0;
  }
};


spark.layouts.HorizontalLayout.prototype.set__columnWidth = function(value) {
  if (this.spark_layouts_HorizontalLayout__columnWidth == value)
    return;
  this.spark_layouts_HorizontalLayout__columnWidth = value;
  this.spark_layouts_HorizontalLayout_invalidateTargetSizeAndDisplayList();
};


spark.layouts.HorizontalLayout.prototype.get__variableColumnWidth = function() {
  return this.spark_layouts_HorizontalLayout__variableColumnWidth;
};


spark.layouts.HorizontalLayout.prototype.set__variableColumnWidth = function(value) {
  if (value == this.spark_layouts_HorizontalLayout__variableColumnWidth)
    return;
  this.spark_layouts_HorizontalLayout__variableColumnWidth = value;
  this.spark_layouts_HorizontalLayout_invalidateTargetSizeAndDisplayList();
};


spark.layouts.HorizontalLayout.prototype.get__firstIndexInView = function() {
  return this.spark_layouts_HorizontalLayout__firstIndexInView;
};


spark.layouts.HorizontalLayout.prototype.get__lastIndexInView = function() {
  return this.spark_layouts_HorizontalLayout__lastIndexInView;
};


spark.layouts.HorizontalLayout.prototype.get__horizontalAlign = function() {
  return this.spark_layouts_HorizontalLayout__horizontalAlign;
};


spark.layouts.HorizontalLayout.prototype.set__horizontalAlign = function(value) {
  if (value == this.spark_layouts_HorizontalLayout__horizontalAlign)
    return;
  this.spark_layouts_HorizontalLayout__horizontalAlign = value;
};


spark.layouts.HorizontalLayout.prototype.get__verticalAlign = function() {
  return this.spark_layouts_HorizontalLayout__verticalAlign;
};


spark.layouts.HorizontalLayout.prototype.set__verticalAlign = function(value) {
  if (value == this.spark_layouts_HorizontalLayout__verticalAlign)
    return;
  var /** @type {string} */ oldValue = this.spark_layouts_HorizontalLayout__verticalAlign;
  this.spark_layouts_HorizontalLayout__verticalAlign = value;
  if (oldValue == spark.layouts.VerticalAlign.BASELINE || value == spark.layouts.VerticalAlign.BASELINE) {
    this.spark_layouts_HorizontalLayout_invalidateTargetSizeAndDisplayList();
  } else {
  }
};


spark.layouts.HorizontalLayout.prototype.set__clipAndEnableScrolling = function(value) {
  spark.layouts.HorizontalLayout.superClass_.set__clipAndEnableScrolling.apply(this, [ value] );
};


Object.defineProperties(spark.layouts.HorizontalLayout.prototype, /** @lends {spark.layouts.HorizontalLayout.prototype} */ {
/**
  * @export
  * @type {Object} */
http_$$www_adobe_com$2006$flex$mx$internal__alignmentBaseline: {
get: spark.layouts.HorizontalLayout.prototype.http_$$www_adobe_com$2006$flex$mx$internal__get__alignmentBaseline,
set: spark.layouts.HorizontalLayout.prototype.http_$$www_adobe_com$2006$flex$mx$internal__set__alignmentBaseline},
/**
  * @export
  * @type {number} */
gap: {
get: spark.layouts.HorizontalLayout.prototype.get__gap,
set: spark.layouts.HorizontalLayout.prototype.set__gap},
/**
  * @export
  * @type {number} */
columnCount: {
get: spark.layouts.HorizontalLayout.prototype.get__columnCount},
/**
  * @export
  * @type {number} */
padding: {
get: spark.layouts.HorizontalLayout.prototype.get__padding,
set: spark.layouts.HorizontalLayout.prototype.set__padding},
/**
  * @export
  * @type {number} */
paddingLeft: {
get: spark.layouts.HorizontalLayout.prototype.get__paddingLeft,
set: spark.layouts.HorizontalLayout.prototype.set__paddingLeft},
/**
  * @export
  * @type {number} */
paddingRight: {
get: spark.layouts.HorizontalLayout.prototype.get__paddingRight,
set: spark.layouts.HorizontalLayout.prototype.set__paddingRight},
/**
  * @export
  * @type {number} */
paddingTop: {
get: spark.layouts.HorizontalLayout.prototype.get__paddingTop,
set: spark.layouts.HorizontalLayout.prototype.set__paddingTop},
/**
  * @export
  * @type {number} */
paddingBottom: {
get: spark.layouts.HorizontalLayout.prototype.get__paddingBottom,
set: spark.layouts.HorizontalLayout.prototype.set__paddingBottom},
/**
  * @export
  * @type {number} */
requestedMaxColumnCount: {
get: spark.layouts.HorizontalLayout.prototype.get__requestedMaxColumnCount,
set: spark.layouts.HorizontalLayout.prototype.set__requestedMaxColumnCount},
/**
  * @export
  * @type {number} */
requestedMinColumnCount: {
get: spark.layouts.HorizontalLayout.prototype.get__requestedMinColumnCount,
set: spark.layouts.HorizontalLayout.prototype.set__requestedMinColumnCount},
/**
  * @export
  * @type {number} */
requestedColumnCount: {
get: spark.layouts.HorizontalLayout.prototype.get__requestedColumnCount,
set: spark.layouts.HorizontalLayout.prototype.set__requestedColumnCount},
/**
  * @export
  * @type {number} */
columnWidth: {
get: spark.layouts.HorizontalLayout.prototype.get__columnWidth,
set: spark.layouts.HorizontalLayout.prototype.set__columnWidth},
/**
  * @export
  * @type {boolean} */
variableColumnWidth: {
get: spark.layouts.HorizontalLayout.prototype.get__variableColumnWidth,
set: spark.layouts.HorizontalLayout.prototype.set__variableColumnWidth},
/**
  * @export
  * @type {number} */
firstIndexInView: {
get: spark.layouts.HorizontalLayout.prototype.get__firstIndexInView},
/**
  * @export
  * @type {number} */
lastIndexInView: {
get: spark.layouts.HorizontalLayout.prototype.get__lastIndexInView},
/**
  * @export
  * @type {string} */
horizontalAlign: {
get: spark.layouts.HorizontalLayout.prototype.get__horizontalAlign,
set: spark.layouts.HorizontalLayout.prototype.set__horizontalAlign},
/**
  * @export
  * @type {string} */
verticalAlign: {
get: spark.layouts.HorizontalLayout.prototype.get__verticalAlign,
set: spark.layouts.HorizontalLayout.prototype.set__verticalAlign},
/**
  * @export
  * @type {boolean} */
clipAndEnableScrolling: {
get: spark.layouts.supportClasses.LayoutBase.prototype.get__clipAndEnableScrolling,
set: spark.layouts.HorizontalLayout.prototype.set__clipAndEnableScrolling}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
spark.layouts.HorizontalLayout.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'HorizontalLayout', qName: 'spark.layouts.HorizontalLayout', kind: 'class' }], interfaces: [spark.core.IGapLayout] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
spark.layouts.HorizontalLayout.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    accessors: function () {
      return {
        'http://www.adobe.com/2006/flex/mx/internal::alignmentBaseline': { type: 'Object', access: 'readwrite', declaredBy: 'spark.layouts.HorizontalLayout'},
        'gap': { type: 'int', access: 'readwrite', declaredBy: 'spark.layouts.HorizontalLayout'},
        'columnCount': { type: 'int', access: 'readonly', declaredBy: 'spark.layouts.HorizontalLayout', metadata: function () { return [ { name: 'Bindable', args: [ { key: '', value: 'propertyChange' } ] } ]; }},
        'padding': { type: 'Number', access: 'readwrite', declaredBy: 'spark.layouts.HorizontalLayout'},
        'paddingLeft': { type: 'Number', access: 'readwrite', declaredBy: 'spark.layouts.HorizontalLayout'},
        'paddingRight': { type: 'Number', access: 'readwrite', declaredBy: 'spark.layouts.HorizontalLayout'},
        'paddingTop': { type: 'Number', access: 'readwrite', declaredBy: 'spark.layouts.HorizontalLayout'},
        'paddingBottom': { type: 'Number', access: 'readwrite', declaredBy: 'spark.layouts.HorizontalLayout'},
        'requestedMaxColumnCount': { type: 'int', access: 'readwrite', declaredBy: 'spark.layouts.HorizontalLayout'},
        'requestedMinColumnCount': { type: 'int', access: 'readwrite', declaredBy: 'spark.layouts.HorizontalLayout'},
        'requestedColumnCount': { type: 'int', access: 'readwrite', declaredBy: 'spark.layouts.HorizontalLayout'},
        'columnWidth': { type: 'Number', access: 'readwrite', declaredBy: 'spark.layouts.HorizontalLayout'},
        'variableColumnWidth': { type: 'Boolean', access: 'readwrite', declaredBy: 'spark.layouts.HorizontalLayout'},
        'firstIndexInView': { type: 'int', access: 'readonly', declaredBy: 'spark.layouts.HorizontalLayout', metadata: function () { return [ { name: 'Bindable', args: [ { key: '', value: 'indexInViewChanged' } ] } ]; }},
        'lastIndexInView': { type: 'int', access: 'readonly', declaredBy: 'spark.layouts.HorizontalLayout', metadata: function () { return [ { name: 'Bindable', args: [ { key: '', value: 'indexInViewChanged' } ] } ]; }},
        'horizontalAlign': { type: 'String', access: 'readwrite', declaredBy: 'spark.layouts.HorizontalLayout'},
        'verticalAlign': { type: 'String', access: 'readwrite', declaredBy: 'spark.layouts.HorizontalLayout'},
        'clipAndEnableScrolling': { type: 'Boolean', access: 'writeonly', declaredBy: 'spark.layouts.HorizontalLayout'}
      };
    },
    methods: function () {
      return {
        'HorizontalLayout': { type: 'void', declaredBy: 'spark.layouts.HorizontalLayout'},
        'clearVirtualLayoutCache': { type: 'void', declaredBy: 'spark.layouts.HorizontalLayout'},
        'getElementBounds': { type: 'org.apache.royale.geom.Rectangle', declaredBy: 'spark.layouts.HorizontalLayout', parameters: function () { return [ 'int', false ]; }},
        'fractionOfElementInView': { type: 'Number', declaredBy: 'spark.layouts.HorizontalLayout', parameters: function () { return [ 'int', false ]; }},
        'elementAdded': { type: 'void', declaredBy: 'spark.layouts.HorizontalLayout', parameters: function () { return [ 'int', false ]; }},
        'elementRemoved': { type: 'void', declaredBy: 'spark.layouts.HorizontalLayout', parameters: function () { return [ 'int', false ]; }},
        'measure': { type: 'void', declaredBy: 'spark.layouts.HorizontalLayout'},
        'getNavigationDestinationIndex': { type: 'int', declaredBy: 'spark.layouts.HorizontalLayout', parameters: function () { return [ 'int', false ,'uint', false ,'Boolean', false ]; }},
        'updateDisplayList': { type: 'void', declaredBy: 'spark.layouts.HorizontalLayout', parameters: function () { return [ 'Number', false ,'Number', false ]; }},
        'http://www.adobe.com/2006/flex/mx/internal::getElementNearestScrollPosition': { type: 'int', declaredBy: 'spark.layouts.HorizontalLayout', parameters: function () { return [ 'org.apache.royale.geom.Point', false ,'String', true ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
spark.layouts.HorizontalLayout.prototype.ROYALE_COMPILE_FLAGS = 10;



/**
 * @constructor
 * @extends {mx.containers.utilityClasses.FlexChildInfo}
 */
spark.layouts.HorizontalLayout.HLayoutElementFlexChildInfo = function() {
  spark.layouts.HorizontalLayout.HLayoutElementFlexChildInfo.base(this, 'constructor');
};
goog.inherits(spark.layouts.HorizontalLayout.HLayoutElementFlexChildInfo, mx.containers.utilityClasses.FlexChildInfo);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('spark.layouts.HorizontalLayout.HLayoutElementFlexChildInfo', spark.layouts.HorizontalLayout.HLayoutElementFlexChildInfo);


/**
 * @export
 * @type {mx.core.ILayoutElement}
 */
spark.layouts.HorizontalLayout.HLayoutElementFlexChildInfo.prototype.layoutElement;


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
spark.layouts.HorizontalLayout.HLayoutElementFlexChildInfo.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'HLayoutElementFlexChildInfo', qName: 'spark.layouts.HorizontalLayout.HLayoutElementFlexChildInfo', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
spark.layouts.HorizontalLayout.HLayoutElementFlexChildInfo.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        'layoutElement': { type: 'mx.core.ILayoutElement', get_set: function (/** spark.layouts.HorizontalLayout.HLayoutElementFlexChildInfo */ inst, /** * */ v) {return v !== undefined ? inst.layoutElement = v : inst.layoutElement;}}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
spark.layouts.HorizontalLayout.HLayoutElementFlexChildInfo.prototype.ROYALE_COMPILE_FLAGS = 10;



/**
 * @constructor
 */
spark.layouts.HorizontalLayout.SizesAndLimit = function() {
};


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('spark.layouts.HorizontalLayout.SizesAndLimit', spark.layouts.HorizontalLayout.SizesAndLimit);


/**
 * @export
 * @type {number}
 */
spark.layouts.HorizontalLayout.SizesAndLimit.prototype.preferredSize;


/**
 * @export
 * @type {number}
 */
spark.layouts.HorizontalLayout.SizesAndLimit.prototype.minSize;


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
spark.layouts.HorizontalLayout.SizesAndLimit.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'SizesAndLimit', qName: 'spark.layouts.HorizontalLayout.SizesAndLimit', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
spark.layouts.HorizontalLayout.SizesAndLimit.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        'preferredSize': { type: 'Number', get_set: function (/** spark.layouts.HorizontalLayout.SizesAndLimit */ inst, /** * */ v) {return v !== undefined ? inst.preferredSize = v : inst.preferredSize;}},
        'minSize': { type: 'Number', get_set: function (/** spark.layouts.HorizontalLayout.SizesAndLimit */ inst, /** * */ v) {return v !== undefined ? inst.minSize = v : inst.minSize;}}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
spark.layouts.HorizontalLayout.SizesAndLimit.prototype.ROYALE_COMPILE_FLAGS = 10;

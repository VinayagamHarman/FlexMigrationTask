/**
 * Generated by Apache Royale Compiler from org/apache/royale/textLayout/factory/TextFlowTextLineFactory.as
 * org.apache.royale.textLayout.factory.TextFlowTextLineFactory
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('org.apache.royale.textLayout.factory.TextFlowTextLineFactory');
/* Royale Dependency List: org.apache.royale.core.UIBase,org.apache.royale.geom.Rectangle,org.apache.royale.text.engine.ITextLine,org.apache.royale.textLayout.compose.FloatCompositionData,org.apache.royale.textLayout.compose.IFlowComposer,org.apache.royale.textLayout.compose.ISimpleCompose,org.apache.royale.textLayout.compose.utils.FactoryHelper,org.apache.royale.textLayout.container.ScrollPolicy,org.apache.royale.textLayout.elements.IFlowGroupElement,org.apache.royale.textLayout.elements.IFlowLeafElement,org.apache.royale.textLayout.elements.ITextFlow,org.apache.royale.textLayout.elements.ParagraphElement,org.apache.royale.textLayout.elements.SpanElement,org.apache.royale.textLayout.formats.BlockProgression,org.apache.royale.textLayout.formats.Float,org.apache.royale.textLayout.formats.ITextLayoutFormat,XML*/

goog.require('org.apache.royale.textLayout.factory.TextLineFactoryBase');



/** 
 * Creates a TextFlowTextLineFactory object. 
 * 
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * @constructor
 * @extends {org.apache.royale.textLayout.factory.TextLineFactoryBase}
 */
org.apache.royale.textLayout.factory.TextFlowTextLineFactory = function() {
  org.apache.royale.textLayout.factory.TextFlowTextLineFactory.base(this, 'constructor');
};
goog.inherits(org.apache.royale.textLayout.factory.TextFlowTextLineFactory, org.apache.royale.textLayout.factory.TextLineFactoryBase);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('org.apache.royale.textLayout.factory.TextFlowTextLineFactory', org.apache.royale.textLayout.factory.TextFlowTextLineFactory);


/**
 * Creates ITextLine objects from the specified text flow.
 * 
 * <p>The text lines are composed to fit the bounds assigned to the <code>compositionBounds</code> property.
 * As each line is created, the factory calls the function specified in the 
 * <code>callback</code> parameter. This function is passed the ITextLine object and
 * is responsible for displaying the line. If a line has a background color, the factory also calls the
 * callback function with a Shape object containing a rectangle of the background color.</p>
 * 
 * <p>Note that the scroll policies of the factory will control how many lines are generated.</p>
 * 
 * @asparam callback function to call with each generated ITextLine object.  
 * The callback will be called with a Shape object representing any background color (if present), 
 * and with ITextLine objects for the text.
 * @asparam textFlow The TextFlow from which the lines are created.
 * 
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 *
 * @export
 * @param {Function} callback
 * @param {org.apache.royale.textLayout.elements.ITextFlow} textFlow
 */
org.apache.royale.textLayout.factory.TextFlowTextLineFactory.prototype.createTextLines = function(callback, textFlow) {
  var /** @type {org.apache.royale.textLayout.compose.ISimpleCompose} */ saved = org.apache.royale.textLayout.factory.TextLineFactoryBase.beginFactoryCompose();
  try {
    this.org_apache_royale_textLayout_factory_TextFlowTextLineFactory_createTextLinesInternal(callback, textFlow);
  } finally {
    textFlow.changeFlowComposer(null, false);
    org.apache.royale.textLayout.compose.utils.FactoryHelper.staticComposer.lines.splice(0);
    if (this._pass0Lines)
      this._pass0Lines.splice(0);
    org.apache.royale.textLayout.factory.TextLineFactoryBase.endFactoryCompose(saved);
  }
};


/**
 * @private
 * @param {Function} callback
 * @param {org.apache.royale.textLayout.elements.ITextFlow} textFlow
 */
org.apache.royale.textLayout.factory.TextFlowTextLineFactory.prototype.org_apache_royale_textLayout_factory_TextFlowTextLineFactory_createTextLinesInternal = function(callback, textFlow) {
  var /** @type {boolean} */ measureWidth = isNaN(this.compositionBounds.width);
  var /** @type {string} */ bp = org.apache.royale.utils.Language.string(textFlow.computedFormat.blockProgression);
  var /** @type {org.apache.royale.textLayout.compose.IFlowComposer} */ helper = this.createFlowComposer();
  helper.swfContext = this.swfContext;
  helper.addController(this.containerController);
  textFlow.flowComposer = helper;
  textFlow.clearBackgroundManager();
  
  this._isTruncated = false;
  this.containerController.setCompositionSize(this.compositionBounds.width, this.compositionBounds.height);
  this.containerController.verticalScrollPolicy = this.truncationOptions ? org.apache.royale.textLayout.container.ScrollPolicy.OFF : this.verticalScrollPolicy;
  this.containerController.horizontalScrollPolicy = this.truncationOptions ? org.apache.royale.textLayout.container.ScrollPolicy.OFF : this.horizontalScrollPolicy;
  textFlow.normalize();
  textFlow.applyUpdateElements(true);
  helper.compose();
  if (this.truncationOptions && !this.doesComposedTextFit(this.truncationOptions.lineCountLimit, (textFlow.textLength) >>> 0, bp)) {
    this._isTruncated = true;
    var /** @type {boolean} */ somethingFit = false;
    this.computeLastAllowedLineIndex(this.truncationOptions.lineCountLimit);
    if (this._truncationLineIndex >= 0) {
      var /** @type {org.apache.royale.textLayout.elements.SpanElement} */ truncationIndicatorSpan = new org.apache.royale.textLayout.elements.SpanElement();
      truncationIndicatorSpan.text = this.truncationOptions.truncationIndicator;
      truncationIndicatorSpan.id = "truncationIndicator";
      if (this.truncationOptions.truncationIndicatorFormat)
        truncationIndicatorSpan.format = this.truncationOptions.truncationIndicatorFormat;
      var /** @type {org.apache.royale.textLayout.formats.ITextLayoutFormat} */ hostFormat = textFlow.hostFormat;
      var /** @type {org.apache.royale.text.engine.ITextLine} */ line = org.apache.royale.textLayout.compose.utils.FactoryHelper.staticComposer.lines[this._truncationLineIndex];
      var /** @type {number} */ truncateAtCharPosition = (line.userData + line.rawTextLength) >> 0;
      if (!this._pass0Lines)
        this._pass0Lines = new Array();
      this._pass0Lines = org.apache.royale.textLayout.compose.utils.FactoryHelper.staticComposer.swapLines(this._pass0Lines);
      do {
        textFlow = textFlow.deepCopy(0, truncateAtCharPosition);
        if (hostFormat)
          textFlow.hostFormat = hostFormat;
        var /** @type {org.apache.royale.textLayout.elements.IFlowGroupElement} */ parent;
        var /** @type {org.apache.royale.textLayout.elements.IFlowLeafElement} */ lastLeaf = textFlow.getLastLeaf();
        if (lastLeaf) {
          parent = lastLeaf.parent;
          if (!this.truncationOptions.truncationIndicatorFormat)
            truncationIndicatorSpan.format = lastLeaf.format;
        } else {
          parent = new org.apache.royale.textLayout.elements.ParagraphElement();
          textFlow.addChild(parent);
        }
        if (truncationIndicatorSpan.parent)
          truncationIndicatorSpan.parent.removeChild(truncationIndicatorSpan);
        parent.addChild(truncationIndicatorSpan);
        textFlow.flowComposer = helper;
        textFlow.normalize();
        helper.compose();
        if (this.doesComposedTextFit(this.truncationOptions.lineCountLimit, (textFlow.textLength) >>> 0, bp)) {
          somethingFit = true;
          break;
        }
        if (truncateAtCharPosition == 0)
          break;
        truncateAtCharPosition = this.getNextTruncationPosition(truncateAtCharPosition, true);
      } while (true);
    }
    if (this.org_apache_royale_textLayout_factory_TextFlowTextLineFactory__truncatedTextFlowCallback != null)
      this.org_apache_royale_textLayout_factory_TextFlowTextLineFactory__truncatedTextFlowCallback(somethingFit ? textFlow : null);
    if (!somethingFit)
      org.apache.royale.textLayout.compose.utils.FactoryHelper.staticComposer.lines.splice(0);
  }
  var /** @type {number} */ xadjust = this.compositionBounds.x;
  var /** @type {org.apache.royale.geom.Rectangle} */ controllerBounds = this.containerController.getContentBounds();
  if (bp == org.apache.royale.textLayout.formats.BlockProgression.RL)
    xadjust += (measureWidth ? controllerBounds.width : this.compositionBounds.width);
  controllerBounds.left += xadjust;
  controllerBounds.right += xadjust;
  controllerBounds.top += this.compositionBounds.y;
  controllerBounds.bottom += this.compositionBounds.y;
  if (textFlow.backgroundManager)
    this.processBackgroundColors(textFlow, callback, xadjust, this.compositionBounds.y, this.containerController.compositionWidth, this.containerController.compositionHeight);
  this.callbackWithTextLines(callback, xadjust, this.compositionBounds.y);
  this.setContentBounds(controllerBounds);
  this.containerController.clearCompositionResults();
};


/** @asprivate - documented in base class 
 * @protected
 * @override
 */
org.apache.royale.textLayout.factory.TextFlowTextLineFactory.prototype.callbackWithTextLines = function(callback, delx, dely) {
  org.apache.royale.textLayout.factory.TextFlowTextLineFactory.superClass_.callbackWithTextLines.apply(this, [ callback, delx, dely] );
  var /** @type {number} */ numFloats = this.containerController.numFloats;
  for (var /** @type {number} */ i = 0; i < numFloats; ++i) {
    var /** @type {org.apache.royale.textLayout.compose.FloatCompositionData} */ floatInfo = this.containerController.getFloatAt(i);
    var /** @type {org.apache.royale.core.UIBase} */ inlineHolder = new org.apache.royale.core.UIBase();
    inlineHolder.alpha = floatInfo.alpha;
    inlineHolder.x += floatInfo.x;
    inlineHolder.y += floatInfo.y;
    inlineHolder.addElement(floatInfo.graphic);
    if (floatInfo.floatType == org.apache.royale.textLayout.formats.Float.NONE)
      floatInfo.parent.addElement(inlineHolder); else {
      inlineHolder.x += delx;
      inlineHolder.y += dely;
      callback(inlineHolder);
    }
  }
};


/**
 * @private
 * @type {Function}
 */
org.apache.royale.textLayout.factory.TextFlowTextLineFactory.prototype.org_apache_royale_textLayout_factory_TextFlowTextLineFactory__truncatedTextFlowCallback;


org.apache.royale.textLayout.factory.TextFlowTextLineFactory.prototype.set__truncatedTextFlowCallback = function(val) {
  this.org_apache_royale_textLayout_factory_TextFlowTextLineFactory__truncatedTextFlowCallback = val;
};


Object.defineProperties(org.apache.royale.textLayout.factory.TextFlowTextLineFactory.prototype, /** @lends {org.apache.royale.textLayout.factory.TextFlowTextLineFactory.prototype} */ {
/**
  * @export
  * @type {Function} */
truncatedTextFlowCallback: {
set: org.apache.royale.textLayout.factory.TextFlowTextLineFactory.prototype.set__truncatedTextFlowCallback}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
org.apache.royale.textLayout.factory.TextFlowTextLineFactory.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'TextFlowTextLineFactory', qName: 'org.apache.royale.textLayout.factory.TextFlowTextLineFactory', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
org.apache.royale.textLayout.factory.TextFlowTextLineFactory.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    accessors: function () {
      return {
        'truncatedTextFlowCallback': { type: 'Function', access: 'writeonly', declaredBy: 'org.apache.royale.textLayout.factory.TextFlowTextLineFactory'}
      };
    },
    methods: function () {
      return {
        'TextFlowTextLineFactory': { type: '', declaredBy: 'org.apache.royale.textLayout.factory.TextFlowTextLineFactory'},
        'createTextLines': { type: 'void', declaredBy: 'org.apache.royale.textLayout.factory.TextFlowTextLineFactory', parameters: function () { return [ 'Function', false ,'org.apache.royale.textLayout.elements.ITextFlow', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
org.apache.royale.textLayout.factory.TextFlowTextLineFactory.prototype.ROYALE_COMPILE_FLAGS = 10;

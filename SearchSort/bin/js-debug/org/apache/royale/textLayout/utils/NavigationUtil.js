/**
 * Generated by Apache Royale Compiler from org/apache/royale/textLayout/utils/NavigationUtil.as
 * org.apache.royale.textLayout.utils.NavigationUtil
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('org.apache.royale.textLayout.utils.NavigationUtil');
/* Royale Dependency List: org.apache.royale.geom.Point,org.apache.royale.geom.Rectangle,org.apache.royale.text.engine.ITextLine,org.apache.royale.text.engine.TextRotation,org.apache.royale.textLayout.compose.IFlowComposer,org.apache.royale.textLayout.compose.ITextFlowLine,org.apache.royale.textLayout.compose.TextFlowTableBlock,org.apache.royale.textLayout.container.IContainerController,org.apache.royale.textLayout.container.ScrollPolicy,org.apache.royale.textLayout.elements.IFlowLeafElement,org.apache.royale.textLayout.elements.IParagraphElement,org.apache.royale.textLayout.elements.ITextFlow,org.apache.royale.textLayout.elements.ParagraphElement,org.apache.royale.textLayout.elements.TextRange,org.apache.royale.textLayout.formats.BlockProgression,org.apache.royale.textLayout.formats.Direction,org.apache.royale.textLayout.utils.CharacterUtil,org.apache.royale.utils.Language,XML*/




/**
 * @constructor
 */
org.apache.royale.textLayout.utils.NavigationUtil = function() {
};


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('org.apache.royale.textLayout.utils.NavigationUtil', org.apache.royale.textLayout.utils.NavigationUtil);


/**
 * @private
 * @param {org.apache.royale.textLayout.elements.TextRange} range
 * @return {boolean}
 */
org.apache.royale.textLayout.utils.NavigationUtil.validateTextRange = function(range) {
  return range.textFlow != null && range.anchorPosition != -1 && range.activePosition != -1;
};


/**
 * @private
 * @param {org.apache.royale.textLayout.elements.ITextFlow} flowRoot
 * @param {number} pos
 * @param {Function} incrementer
 * @return {number}
 */
org.apache.royale.textLayout.utils.NavigationUtil.doIncrement = function(flowRoot, pos, incrementer) {
  var /** @type {org.apache.royale.textLayout.elements.IParagraphElement} */ para = flowRoot.findAbsoluteParagraph(pos);
  return (incrementer(flowRoot, para, pos, para.getAbsoluteStart())) >> 0;
};


/**
 * @private
 * @param {org.apache.royale.textLayout.elements.ITextFlow} flowRoot
 * @param {org.apache.royale.textLayout.elements.ParagraphElement} para
 * @param {number} pos
 * @param {number} paraStart
 * @return {number}
 */
org.apache.royale.textLayout.utils.NavigationUtil.previousAtomHelper = function(flowRoot, para, pos, paraStart) {
  if (pos - paraStart == 0)
    return ((pos > 0) ? pos - 1 : 0) >> 0;
  var /** @type {number} */ paraEnd = para.getAbsoluteStart() + para.textLength;
  para.getTextFlow().flowComposer.composeToPosition((paraEnd) >> 0);
  return (para.findPreviousAtomBoundary((pos - paraStart) >> 0) + paraStart) >> 0;
};


/** 
 * Returns the absolute position of the previous atom. 
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * @export
 * @param {org.apache.royale.textLayout.elements.ITextFlow} flowRoot
 * @param {number} absolutePos
 * @return {number}
 */
org.apache.royale.textLayout.utils.NavigationUtil.previousAtomPosition = function(flowRoot, absolutePos) {
  return org.apache.royale.textLayout.utils.NavigationUtil.doIncrement(flowRoot, absolutePos, org.apache.royale.textLayout.utils.NavigationUtil.previousAtomHelper);
};


/**
 * @private
 * @param {org.apache.royale.textLayout.elements.ITextFlow} flowRoot
 * @param {org.apache.royale.textLayout.elements.ParagraphElement} para
 * @param {number} pos
 * @param {number} paraStart
 * @return {number}
 */
org.apache.royale.textLayout.utils.NavigationUtil.nextAtomHelper = function(flowRoot, para, pos, paraStart) {
  if (pos - paraStart == para.textLength - 1)
    return (Math.min(flowRoot.textLength, pos + 1)) >> 0;
  var /** @type {number} */ paraEnd = para.getAbsoluteStart() + para.textLength;
  para.getTextFlow().flowComposer.composeToPosition((paraEnd) >> 0);
  return (para.findNextAtomBoundary((pos - paraStart) >> 0) + paraStart) >> 0;
};


/** 
 * Returns the absolute position of the next atom.
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * @export
 * @param {org.apache.royale.textLayout.elements.ITextFlow} flowRoot
 * @param {number} absolutePos
 * @return {number}
 */
org.apache.royale.textLayout.utils.NavigationUtil.nextAtomPosition = function(flowRoot, absolutePos) {
  return org.apache.royale.textLayout.utils.NavigationUtil.doIncrement(flowRoot, absolutePos, org.apache.royale.textLayout.utils.NavigationUtil.nextAtomHelper);
};


/** 
 * Returns absolute position of the beginning of the previous word.
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * @export
 * @param {org.apache.royale.textLayout.elements.ITextFlow} flowRoot
 * @param {number} absolutePos
 * @return {number}
 */
org.apache.royale.textLayout.utils.NavigationUtil.previousWordPosition = function(flowRoot, absolutePos) {
  if (org.apache.royale.textLayout.utils.NavigationUtil.isOverset(flowRoot, absolutePos))
    return org.apache.royale.textLayout.utils.NavigationUtil.endOfLastController(flowRoot);
  var /** @type {org.apache.royale.textLayout.elements.IParagraphElement} */ para = flowRoot.findAbsoluteParagraph(absolutePos);
  var /** @type {number} */ paraStart = para.getAbsoluteStart();
  var /** @type {number} */ paraEnd = para.getAbsoluteStart() + para.textLength;
  para.getTextFlow().flowComposer.composeToPosition((paraEnd) >> 0);
  var /** @type {number} */ prevWordPos = (absolutePos - paraStart) >> 0;
  var /** @type {number} */ nextWordPos = 0;
  if (absolutePos - paraStart == 0)
    return ((absolutePos > 0) ? absolutePos - 1 : 0) >> 0;
  do {
    nextWordPos = para.findPreviousWordBoundary(prevWordPos);
    if (prevWordPos == nextWordPos)
      prevWordPos = para.findPreviousWordBoundary((prevWordPos - 1) >> 0);
    else
      prevWordPos = nextWordPos;
  } while (prevWordPos > 0 && org.apache.royale.textLayout.utils.CharacterUtil.isWhitespace(para.getCharCodeAtPosition(prevWordPos)));
  return (prevWordPos + paraStart) >> 0;
};


/** 
 * Returns the absolute position of the beginning of the next word.
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * @export
 * @param {org.apache.royale.textLayout.elements.ITextFlow} flowRoot
 * @param {number} absolutePos
 * @return {number}
 */
org.apache.royale.textLayout.utils.NavigationUtil.nextWordPosition = function(flowRoot, absolutePos) {
  var /** @type {org.apache.royale.textLayout.elements.IParagraphElement} */ para = flowRoot.findAbsoluteParagraph(absolutePos);
  var /** @type {number} */ paraStart = para.getAbsoluteStart();
  var /** @type {number} */ paraEnd = para.getAbsoluteStart() + para.textLength;
  para.getTextFlow().flowComposer.composeToPosition((paraEnd) >> 0);
  var /** @type {number} */ nextWordPos = (absolutePos - paraStart) >> 0;
  if (absolutePos - paraStart == para.textLength - 1)
    return (Math.min(flowRoot.textLength, absolutePos + 1)) >> 0;
  do {
    nextWordPos = para.findNextWordBoundary(nextWordPos);
  } while (nextWordPos < (para.textLength - 1) && org.apache.royale.textLayout.utils.CharacterUtil.isWhitespace(para.getCharCodeAtPosition(nextWordPos)));
  return (nextWordPos + paraStart) >> 0;
};


/** @asprivate 
 * @export
 * @param {org.apache.royale.textLayout.elements.ITextFlow} textFlow
 * @param {number} idx
 * @return {number}
 */
org.apache.royale.textLayout.utils.NavigationUtil.updateStartIfInReadOnlyElement = function(textFlow, idx) {
  return idx;
};


/** @asprivate 
 * @export
 * @param {org.apache.royale.textLayout.elements.ITextFlow} textFlow
 * @param {number} idx
 * @return {number}
 */
org.apache.royale.textLayout.utils.NavigationUtil.updateEndIfInReadOnlyElement = function(textFlow, idx) {
  return idx;
};


/**
 * @private
 * @param {org.apache.royale.textLayout.elements.TextRange} range
 * @param {boolean} extendSelection
 * @param {Function} incrementor
 * @return {boolean}
 */
org.apache.royale.textLayout.utils.NavigationUtil.moveForwardHelper = function(range, extendSelection, incrementor) {
  var /** @type {org.apache.royale.textLayout.elements.ITextFlow} */ textFlow = range.textFlow;
  var /** @type {number} */ begIdx = range.anchorPosition;
  var /** @type {number} */ endIdx = range.activePosition;
  if (extendSelection)
    endIdx = (incrementor(textFlow, endIdx)) >> 0; else {
    if (begIdx == endIdx) {
      begIdx = (incrementor(textFlow, begIdx)) >> 0;
      endIdx = begIdx;
    }
    else if (endIdx > begIdx)
      begIdx = endIdx;
    else
      endIdx = begIdx;
  }
  if (begIdx == endIdx) {
    begIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateStartIfInReadOnlyElement(textFlow, begIdx);
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateEndIfInReadOnlyElement(textFlow, endIdx);
  } else {
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateEndIfInReadOnlyElement(textFlow, endIdx);
  }
  if (!extendSelection && (range.anchorPosition == begIdx) && (range.activePosition == endIdx)) {
    if (begIdx < endIdx) {
      begIdx = (Math.min(endIdx + 1, textFlow.textLength - 1)) >> 0;
      endIdx = begIdx;
    } else {
      endIdx = (Math.min(begIdx + 1, textFlow.textLength - 1)) >> 0;
      begIdx = endIdx;
    }
  }
  return range.updateRange(begIdx, endIdx);
};


/**
 * @private
 * @param {org.apache.royale.textLayout.elements.TextRange} range
 * @param {boolean} extendSelection
 * @param {Function} incrementor
 * @return {boolean}
 */
org.apache.royale.textLayout.utils.NavigationUtil.moveBackwardHelper = function(range, extendSelection, incrementor) {
  var /** @type {org.apache.royale.textLayout.elements.ITextFlow} */ textFlow = range.textFlow;
  var /** @type {number} */ begIdx = range.anchorPosition;
  var /** @type {number} */ endIdx = range.activePosition;
  if (extendSelection)
    endIdx = (incrementor(textFlow, endIdx)) >> 0; else {
    if (begIdx == endIdx) {
      begIdx = (incrementor(textFlow, begIdx)) >> 0;
      endIdx = begIdx;
    }
    else if (endIdx > begIdx)
      endIdx = begIdx;
    else
      begIdx = endIdx;
  }
  if (begIdx == endIdx) {
    begIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateEndIfInReadOnlyElement(textFlow, begIdx);
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateStartIfInReadOnlyElement(textFlow, endIdx);
  } else {
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateStartIfInReadOnlyElement(textFlow, endIdx);
  }
  if (!extendSelection && (range.anchorPosition == begIdx) && (range.activePosition == endIdx)) {
    if (begIdx < endIdx) {
      endIdx = (Math.max(begIdx - 1, 0)) >> 0;
      begIdx = endIdx;
    } else {
      begIdx = (Math.max(endIdx - 1, 0)) >> 0;
      endIdx = begIdx;
    }
  }
  return range.updateRange(begIdx, endIdx);
};


/**
 * Sets the TextRange forward by one character.
 * @asparam extendSelection	Indicates that only activeIndex should move
 * @asreturn true if selection changed.
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * @export
 * @param {org.apache.royale.textLayout.elements.TextRange} range
 * @param {boolean=} extendSelection
 * @return {boolean}
 */
org.apache.royale.textLayout.utils.NavigationUtil.nextCharacter = function(range, extendSelection) {
  extendSelection = typeof extendSelection !== 'undefined' ? extendSelection : false;
  if (org.apache.royale.textLayout.utils.NavigationUtil.validateTextRange(range)) {
    if (!org.apache.royale.textLayout.utils.NavigationUtil.adjustForOversetForward(range))
      org.apache.royale.textLayout.utils.NavigationUtil.moveForwardHelper(range, extendSelection, org.apache.royale.textLayout.utils.NavigationUtil.nextAtomPosition);
    return true;
  }
  return false;
};


/**
 * Sets the TextRange backward by one character.
 * @asparam extendSelection	Indicates that only activeIndex should move
 * @asreturn true if selection changed.
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * @export
 * @param {org.apache.royale.textLayout.elements.TextRange} range
 * @param {boolean=} extendSelection
 * @return {boolean}
 */
org.apache.royale.textLayout.utils.NavigationUtil.previousCharacter = function(range, extendSelection) {
  extendSelection = typeof extendSelection !== 'undefined' ? extendSelection : false;
  if (org.apache.royale.textLayout.utils.NavigationUtil.validateTextRange(range)) {
    if (!org.apache.royale.textLayout.utils.NavigationUtil.adjustForOversetBack(range))
      org.apache.royale.textLayout.utils.NavigationUtil.moveBackwardHelper(range, extendSelection, org.apache.royale.textLayout.utils.NavigationUtil.previousAtomPosition);
    return true;
  }
  return false;
};


/**
 * Sets the TextRange forward by one word.
 * @asparam extendSelection	Indicates that only activeIndex should move
 * @asreturn true if selection changed.
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * @export
 * @param {org.apache.royale.textLayout.elements.TextRange} range
 * @param {boolean=} extendSelection
 * @return {boolean}
 */
org.apache.royale.textLayout.utils.NavigationUtil.nextWord = function(range, extendSelection) {
  extendSelection = typeof extendSelection !== 'undefined' ? extendSelection : false;
  if (org.apache.royale.textLayout.utils.NavigationUtil.validateTextRange(range)) {
    if (!org.apache.royale.textLayout.utils.NavigationUtil.adjustForOversetForward(range))
      org.apache.royale.textLayout.utils.NavigationUtil.moveForwardHelper(range, extendSelection, org.apache.royale.textLayout.utils.NavigationUtil.nextWordPosition);
    return true;
  }
  return false;
};


/**
 * Sets the TextRange backward by one word.
 * @asparam extendSelection	Indicates that only activeIndex should move
 * @asreturn true if selection changed.
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * @export
 * @param {org.apache.royale.textLayout.elements.TextRange} range
 * @param {boolean=} extendSelection
 * @return {boolean}
 */
org.apache.royale.textLayout.utils.NavigationUtil.previousWord = function(range, extendSelection) {
  extendSelection = typeof extendSelection !== 'undefined' ? extendSelection : false;
  if (org.apache.royale.textLayout.utils.NavigationUtil.validateTextRange(range)) {
    if (!org.apache.royale.textLayout.utils.NavigationUtil.adjustForOversetBack(range))
      org.apache.royale.textLayout.utils.NavigationUtil.moveBackwardHelper(range, extendSelection, org.apache.royale.textLayout.utils.NavigationUtil.previousWordPosition);
    return true;
  }
  return false;
};


/** @asprivate 
 * @export
 * @param {org.apache.royale.textLayout.compose.ITextFlowLine} targetFlowLine
 * @param {org.apache.royale.textLayout.compose.ITextFlowLine} curTextFlowLine
 * @param {string} blockProgression
 * @param {boolean} isRTLDirection
 * @param {org.apache.royale.geom.Point} localPoint
 * @return {number}
 */
org.apache.royale.textLayout.utils.NavigationUtil.computeEndIdx = function(targetFlowLine, curTextFlowLine, blockProgression, isRTLDirection, localPoint) {
  var /** @type {number} */ endIdx = 0;
  var /** @type {number} */ paraSelectionIdx = 0;
  //var /** @type {number} */ endIdx = 0;
  var /** @type {org.apache.royale.text.engine.ITextLine} */ targetTextLine = targetFlowLine.getTextLine(true);
  var /** @type {number} */ blockOffset = targetFlowLine.paragraph.getTextBlockAbsoluteStart(targetTextLine.textBlock);
  var /** @type {org.apache.royale.text.engine.ITextLine} */ currentTextLine = curTextFlowLine.getTextLine(true);
  if (targetFlowLine.controller == curTextFlowLine.controller) {
    if (blockProgression != org.apache.royale.textLayout.formats.BlockProgression.RL) {
      localPoint.y = targetTextLine.y + (targetTextLine.height / 2);
    } else {
      localPoint.x += (targetTextLine.x - currentTextLine.x);
    }
  } else {
    var /** @type {org.apache.royale.geom.Rectangle} */ firstAtomRect = targetTextLine.getAtomBounds(0);
    var /** @type {org.apache.royale.geom.Point} */ firstAtomPoint = new org.apache.royale.geom.Point();
    firstAtomPoint.x = firstAtomRect.left;
    firstAtomPoint.y = 0;
    if (blockProgression != org.apache.royale.textLayout.formats.BlockProgression.RL) {
      localPoint.x -= curTextFlowLine.controller.container.x;
      localPoint.y = firstAtomPoint.y;
    } else {
      localPoint.x = firstAtomPoint.x;
      localPoint.y -= curTextFlowLine.controller.container.y;
    }
  }
  var /** @type {number} */ atomIndex = targetTextLine.getAtomIndexAtPoint(localPoint.x, localPoint.y);
  var /** @type {boolean} */ bidiRightToLeft = ((currentTextLine.getAtomBidiLevel(atomIndex) % 2) != 0);
  if (atomIndex == -1) {
    if (blockProgression != org.apache.royale.textLayout.formats.BlockProgression.RL) {
      if (!bidiRightToLeft)
        endIdx = ((localPoint.x <= targetTextLine.x) ? targetFlowLine.absoluteStart : (targetFlowLine.absoluteStart + targetFlowLine.textLength - 1)) >> 0;
      else
        endIdx = ((localPoint.x <= targetTextLine.x) ? (targetFlowLine.absoluteStart + targetFlowLine.textLength - 1) : targetFlowLine.absoluteStart) >> 0;
    } else {
      if (!bidiRightToLeft)
        endIdx = ((localPoint.y <= targetTextLine.y) ? targetFlowLine.absoluteStart : (targetFlowLine.absoluteStart + targetFlowLine.textLength - 1)) >> 0;
      else
        endIdx = ((localPoint.y <= targetTextLine.y) ? (targetFlowLine.absoluteStart + targetFlowLine.textLength - 1) : targetFlowLine.absoluteStart) >> 0;
    }
  } else {
    var /** @type {org.apache.royale.geom.Rectangle} */ glyphRect = targetTextLine.getAtomBounds(atomIndex);
    var /** @type {boolean} */ leanRight = false;
    if (glyphRect) {
      var /** @type {org.apache.royale.geom.Point} */ glyphPoint = new org.apache.royale.geom.Point();
      glyphPoint.x = glyphRect.x;
      glyphPoint.y = glyphRect.y;
      if ((blockProgression == org.apache.royale.textLayout.formats.BlockProgression.RL) && targetTextLine.getAtomTextRotation(atomIndex) != org.apache.royale.text.engine.TextRotation.ROTATE_0)
        leanRight = (localPoint.y > (glyphPoint.y + glyphRect.height / 2));
      else
        leanRight = (localPoint.x > (glyphPoint.x + glyphRect.width / 2));
    }
    //var /** @type {number} */ paraSelectionIdx = 0;
    if ((targetTextLine.getAtomBidiLevel(atomIndex) % 2) != 0)
      paraSelectionIdx = leanRight ? targetTextLine.getAtomTextBlockBeginIndex(atomIndex) : targetTextLine.getAtomTextBlockEndIndex(atomIndex); else {
      if (isRTLDirection) {
        if ((leanRight == false) && (atomIndex > 0)) {
          paraSelectionIdx = targetTextLine.getAtomTextBlockBeginIndex((atomIndex - 1) >> 0);
        } else {
          paraSelectionIdx = targetTextLine.getAtomTextBlockBeginIndex(atomIndex);
        }
      } else {
        paraSelectionIdx = leanRight ? targetTextLine.getAtomTextBlockEndIndex(atomIndex) : targetTextLine.getAtomTextBlockBeginIndex(atomIndex);
      }
    }
    endIdx = (blockOffset + paraSelectionIdx) >> 0;
  }
  return endIdx;
};


/**
 * Sets the TextRange down one line
 * @asparam extendSelection	Indicates that only activeIndex should move
 * @asreturn true if selection changed.
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * @export
 * @param {org.apache.royale.textLayout.elements.TextRange} range
 * @param {boolean=} extendSelection
 * @return {boolean}
 */
org.apache.royale.textLayout.utils.NavigationUtil.nextLine = function(range, extendSelection) {
  extendSelection = typeof extendSelection !== 'undefined' ? extendSelection : false;
  if (!org.apache.royale.textLayout.utils.NavigationUtil.validateTextRange(range))
    return false;
  if (org.apache.royale.textLayout.utils.NavigationUtil.adjustForOversetForward(range))
    return true;
  var /** @type {org.apache.royale.textLayout.elements.ITextFlow} */ textFlow = range.textFlow;
  var /** @type {string} */ blockProgression = org.apache.royale.utils.Language.string(textFlow.computedFormat.blockProgression);
  var /** @type {number} */ begIdx = range.anchorPosition;
  var /** @type {number} */ endIdx = range.activePosition;
  var /** @type {number} */ limitIdx = org.apache.royale.textLayout.utils.NavigationUtil.endOfLastController(textFlow);
  var /** @type {number} */ curLine = textFlow.flowComposer.findLineIndexAtPosition(endIdx);
  var /** @type {boolean} */ isRTLDirection = (textFlow.computedFormat.direction == org.apache.royale.textLayout.formats.Direction.RTL);
  if (curLine < textFlow.flowComposer.numLines - 1) {
    var /** @type {org.apache.royale.textLayout.compose.ITextFlowLine} */ curTextFlowLine = textFlow.flowComposer.getLineAt(curLine);
    var /** @type {org.apache.royale.text.engine.ITextLine} */ currentTextLine = curTextFlowLine.getTextLine(true);
    var /** @type {number} */ blockOffset = curTextFlowLine.paragraph.getTextBlockAbsoluteStart(currentTextLine.textBlock);
    var /** @type {number} */ atomIndex = currentTextLine.getAtomIndexAtCharIndex((endIdx - blockOffset) >> 0);
    var /** @type {org.apache.royale.geom.Rectangle} */ curPosRect = currentTextLine.getAtomBounds(atomIndex);
    var /** @type {number} */ currentTextLineX = currentTextLine.x;
    var /** @type {number} */ curPosRectLeft = curPosRect.left;
    var /** @type {number} */ curPosRectRight = curPosRect.right;
    if (blockProgression == org.apache.royale.textLayout.formats.BlockProgression.RL) {
      currentTextLineX = currentTextLine.y;
      curPosRectLeft = curPosRect.top;
      curPosRectRight = curPosRect.bottom;
    }
    var /** @type {org.apache.royale.geom.Point} */ localPoint = new org.apache.royale.geom.Point();
    if (blockProgression != org.apache.royale.textLayout.formats.BlockProgression.RL) {
      if (!isRTLDirection)
        localPoint.x = curPosRect.left;
      else
        localPoint.x = curPosRect.right;
      localPoint.y = 0;
    } else {
      localPoint.x = 0;
      if (!isRTLDirection)
        localPoint.y = curPosRect.top;
      else
        localPoint.y = curPosRect.bottom;
    }
    var /** @type {number} */ lineInc = 1;
    var /** @type {org.apache.royale.textLayout.compose.ITextFlowLine} */ nextFlowLine = textFlow.flowComposer.getLineAt((curLine + lineInc) >> 0);
    while (org.apache.royale.utils.Language.is(nextFlowLine, org.apache.royale.textLayout.compose.TextFlowTableBlock))
      nextFlowLine = textFlow.flowComposer.getLineAt((++lineInc + curLine) >> 0);
    if (!nextFlowLine || nextFlowLine.absoluteStart >= limitIdx) {
      if (!extendSelection)
        range.activePosition = range.anchorPosition = (textFlow.textLength - 1) >> 0;
      else
        range.activePosition = textFlow.textLength;
      return true;
    }
    var /** @type {org.apache.royale.textLayout.container.IContainerController} */ controller = textFlow.flowComposer.getControllerAt((textFlow.flowComposer.numControllers - 1) >> 0);
    var /** @type {number} */ firstPosInContainer = controller.absoluteStart;
    var /** @type {number} */ lastPosInContainer = (firstPosInContainer + controller.textLength) >> 0;
    if ((nextFlowLine.absoluteStart >= firstPosInContainer) && (nextFlowLine.absoluteStart < lastPosInContainer)) {
      if (nextFlowLine.isDamaged()) {
        textFlow.flowComposer.composeToPosition((nextFlowLine.absoluteStart + 1) >> 0);
        nextFlowLine = textFlow.flowComposer.getLineAt((curLine + 1) >> 0);
        if (nextFlowLine.isDamaged())
          return false;
      }
      var /** @type {number} */ curLogicalHorizontalScrollPos = (blockProgression == org.apache.royale.textLayout.formats.BlockProgression.TB) ? controller.horizontalScrollPosition : controller.verticalScrollPosition;
      controller.scrollToRange(nextFlowLine.absoluteStart, (nextFlowLine.absoluteStart + nextFlowLine.textLength - 1) >> 0);
      if (blockProgression == org.apache.royale.textLayout.formats.BlockProgression.TB)
        controller.horizontalScrollPosition = curLogicalHorizontalScrollPos;
      else
        controller.verticalScrollPosition = curLogicalHorizontalScrollPos;
    }
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.computeEndIdx(nextFlowLine, curTextFlowLine, blockProgression, isRTLDirection, localPoint);
    if (endIdx >= textFlow.textLength)
      endIdx = textFlow.textLength;
  }
  else
    endIdx = textFlow.textLength;
  if (!extendSelection)
    begIdx = endIdx;
  if (begIdx == endIdx) {
    begIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateStartIfInReadOnlyElement(textFlow, begIdx);
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateEndIfInReadOnlyElement(textFlow, endIdx);
  } else {
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateEndIfInReadOnlyElement(textFlow, endIdx);
  }
  return range.updateRange(begIdx, endIdx);
};


/**
 * Sets the TextRange up one line.
 * @asparam extendSelection	Indicates that only activeIndex should move
 * @asreturn true if selection changed.
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * @export
 * @param {org.apache.royale.textLayout.elements.TextRange} range
 * @param {boolean=} extendSelection
 * @return {boolean}
 */
org.apache.royale.textLayout.utils.NavigationUtil.previousLine = function(range, extendSelection) {
  extendSelection = typeof extendSelection !== 'undefined' ? extendSelection : false;
  if (!org.apache.royale.textLayout.utils.NavigationUtil.validateTextRange(range))
    return false;
  if (org.apache.royale.textLayout.utils.NavigationUtil.adjustForOversetBack(range))
    return true;
  var /** @type {org.apache.royale.textLayout.elements.ITextFlow} */ textFlow = range.textFlow;
  var /** @type {string} */ blockProgression = org.apache.royale.utils.Language.string(textFlow.computedFormat.blockProgression);
  var /** @type {number} */ begIdx = range.anchorPosition;
  var /** @type {number} */ endIdx = range.activePosition;
  var /** @type {number} */ curLine = textFlow.flowComposer.findLineIndexAtPosition(endIdx);
  var /** @type {boolean} */ isRTLDirection = (textFlow.computedFormat.direction == org.apache.royale.textLayout.formats.Direction.RTL);
  if (curLine > 0) {
    var /** @type {org.apache.royale.textLayout.compose.ITextFlowLine} */ curTextFlowLine = textFlow.flowComposer.getLineAt(curLine);
    var /** @type {org.apache.royale.text.engine.ITextLine} */ currentTextLine = curTextFlowLine.getTextLine(true);
    var /** @type {number} */ blockOffset = curTextFlowLine.paragraph.getTextBlockAbsoluteStart(currentTextLine.textBlock);
    var /** @type {number} */ atomIndex = currentTextLine.getAtomIndexAtCharIndex((endIdx - blockOffset) >> 0);
    var /** @type {org.apache.royale.geom.Rectangle} */ curPosRect = currentTextLine.getAtomBounds(atomIndex);
    var /** @type {number} */ currentTextLineX = currentTextLine.x;
    var /** @type {number} */ curPosRectLeft = curPosRect.left;
    var /** @type {number} */ curPosRectRight = curPosRect.right;
    if (blockProgression == org.apache.royale.textLayout.formats.BlockProgression.RL) {
      currentTextLineX = currentTextLine.y;
      curPosRectLeft = curPosRect.top;
      curPosRectRight = curPosRect.bottom;
    }
    var /** @type {org.apache.royale.geom.Point} */ localPoint = new org.apache.royale.geom.Point();
    if (blockProgression != org.apache.royale.textLayout.formats.BlockProgression.RL) {
      if (!isRTLDirection)
        localPoint.x = curPosRect.left;
      else
        localPoint.x = curPosRect.right;
      localPoint.y = 0;
    } else {
      localPoint.x = 0;
      if (!isRTLDirection)
        localPoint.y = curPosRect.top;
      else
        localPoint.y = curPosRect.bottom;
    }
    var /** @type {number} */ lineInc = 1;
    var /** @type {org.apache.royale.textLayout.compose.ITextFlowLine} */ prevFlowLine = textFlow.flowComposer.getLineAt((curLine - lineInc) >> 0);
    while (org.apache.royale.utils.Language.is(prevFlowLine, org.apache.royale.textLayout.compose.TextFlowTableBlock))
      prevFlowLine = textFlow.flowComposer.getLineAt((curLine - (++lineInc)) >> 0);
    if (!prevFlowLine) {
      if (!extendSelection)
        range.activePosition = range.anchorPosition = 0;
      else
        range.activePosition = 0;
      return true;
    }
    var /** @type {org.apache.royale.textLayout.container.IContainerController} */ controller = textFlow.flowComposer.getControllerAt((textFlow.flowComposer.numControllers - 1) >> 0);
    var /** @type {number} */ firstPosInContainer = controller.absoluteStart;
    var /** @type {number} */ lastPosInContainer = (firstPosInContainer + controller.textLength) >> 0;
    if ((prevFlowLine.absoluteStart >= firstPosInContainer) && (prevFlowLine.absoluteStart < lastPosInContainer)) {
      var /** @type {number} */ curLogicalHorizontalScrollPos = (blockProgression == org.apache.royale.textLayout.formats.BlockProgression.TB) ? controller.horizontalScrollPosition : controller.verticalScrollPosition;
      controller.scrollToRange(prevFlowLine.absoluteStart, (prevFlowLine.absoluteStart + prevFlowLine.textLength - 1) >> 0);
      if (blockProgression == org.apache.royale.textLayout.formats.BlockProgression.TB)
        controller.horizontalScrollPosition = curLogicalHorizontalScrollPos;
      else
        controller.verticalScrollPosition = curLogicalHorizontalScrollPos;
    }
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.computeEndIdx(prevFlowLine, curTextFlowLine, blockProgression, isRTLDirection, localPoint);
  } else {
    endIdx = 0;
  }
  if (!extendSelection)
    begIdx = endIdx;
  if (begIdx == endIdx) {
    begIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateStartIfInReadOnlyElement(textFlow, begIdx);
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateEndIfInReadOnlyElement(textFlow, endIdx);
  } else {
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateEndIfInReadOnlyElement(textFlow, endIdx);
  }
  return range.updateRange(begIdx, endIdx);
};


/**
 * Sets the TextRange down one page.
 * @asparam extendSelection	Indicates that only activeIndex should move
 * @asreturn true if selection changed.
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * @export
 * @param {org.apache.royale.textLayout.elements.TextRange} range
 * @param {boolean=} extendSelection
 * @return {boolean}
 */
org.apache.royale.textLayout.utils.NavigationUtil.nextPage = function(range, extendSelection) {
  extendSelection = typeof extendSelection !== 'undefined' ? extendSelection : false;
  var /** @type {number} */ nextLine = 0;
  var /** @type {org.apache.royale.textLayout.container.IContainerController} */ controller;
  if (!org.apache.royale.textLayout.utils.NavigationUtil.validateTextRange(range))
    return false;
  var /** @type {org.apache.royale.textLayout.elements.ITextFlow} */ textFlow = range.textFlow;
  var /** @type {number} */ controllerIndex = textFlow.flowComposer.findControllerIndexAtPosition(range.activePosition);
  if (controllerIndex != textFlow.flowComposer.numControllers - 1) {
    range.activePosition = textFlow.flowComposer.getControllerAt((controllerIndex + 1) >> 0).absoluteStart;
    if (!extendSelection)
      range.anchorPosition = range.activePosition;
    return true;
  }
  if (!org.apache.royale.textLayout.utils.NavigationUtil.isScrollable(textFlow, range.activePosition))
    return false;
  if (org.apache.royale.textLayout.utils.NavigationUtil.adjustForOversetForward(range))
    return true;
  var /** @type {number} */ begIdx = range.absoluteStart;
  var /** @type {number} */ endIdx = range.absoluteEnd;
  var /** @type {number} */ curLine = textFlow.flowComposer.findLineIndexAtPosition(endIdx);
  var /** @type {org.apache.royale.textLayout.compose.ITextFlowLine} */ curTextFlowLine = textFlow.flowComposer.getLineAt(curLine);
  var /** @type {number} */ lineStart = textFlow.flowComposer.getLineAt(curLine).absoluteStart;
  var /** @type {number} */ linePos = (endIdx - lineStart) >> 0;
  //var /** @type {number} */ nextLine = 0;
  var /** @type {org.apache.royale.textLayout.compose.ITextFlowLine} */ nextTextFlowLine = curTextFlowLine;
  var /** @type {boolean} */ isTTB = textFlow.computedFormat.blockProgression == org.apache.royale.textLayout.formats.BlockProgression.RL;
  var /** @type {number} */ amount;
  controller = textFlow.flowComposer.getControllerAt((textFlow.flowComposer.numControllers - 1) >> 0);
  if (isTTB) {
    amount = controller.compositionWidth * textFlow.configuration.scrollPagePercentage;
  } else {
    amount = controller.compositionHeight * textFlow.configuration.scrollPagePercentage;
  }
  if (isTTB) {
    var /** @type {number} */ contentWidth = controller.contentWidth;
    if ((controller.horizontalScrollPosition - amount) < -contentWidth) {
      controller.horizontalScrollPosition = -contentWidth;
      nextLine = (textFlow.flowComposer.numLines - 1) >> 0;
      nextTextFlowLine = textFlow.flowComposer.getLineAt(nextLine);
    } else {
      var /** @type {number} */ oldHorzScrollPos = controller.horizontalScrollPosition;
      controller.horizontalScrollPosition -= amount;
      var /** @type {number} */ newHorzScrollPos = controller.horizontalScrollPosition;
      if (oldHorzScrollPos == newHorzScrollPos) {
        nextLine = (textFlow.flowComposer.numLines - 1) >> 0;
        nextTextFlowLine = textFlow.flowComposer.getLineAt(nextLine);
      } else {
        nextLine = curLine;
        while (nextLine < (textFlow.flowComposer.numLines - 1)) {
          nextLine++;
          nextTextFlowLine = textFlow.flowComposer.getLineAt(nextLine);
          if ((curTextFlowLine.x - nextTextFlowLine.x) >= (oldHorzScrollPos - newHorzScrollPos))
            break;
        }
      }
    }
  } else {
    var /** @type {number} */ contentHeight = controller.contentHeight;
    if ((controller.verticalScrollPosition + amount) > contentHeight) {
      controller.verticalScrollPosition = contentHeight;
      nextLine = (textFlow.flowComposer.numLines - 1) >> 0;
      nextTextFlowLine = textFlow.flowComposer.getLineAt(nextLine);
    } else {
      var /** @type {number} */ oldVertScrollPos = controller.verticalScrollPosition;
      controller.verticalScrollPosition += amount;
      var /** @type {number} */ newVertScrollPos = controller.verticalScrollPosition;
      if (newVertScrollPos == oldVertScrollPos) {
        nextLine = (textFlow.flowComposer.numLines - 1) >> 0;
        nextTextFlowLine = textFlow.flowComposer.getLineAt(nextLine);
      } else {
        nextLine = curLine;
        while (nextLine < (textFlow.flowComposer.numLines - 1)) {
          nextLine++;
          nextTextFlowLine = textFlow.flowComposer.getLineAt(nextLine);
          if ((nextTextFlowLine.y - curTextFlowLine.y) >= (newVertScrollPos - oldVertScrollPos))
            break;
        }
      }
    }
  }
  endIdx = (nextTextFlowLine.absoluteStart + linePos) >> 0;
  var /** @type {number} */ nextLineEnd = (nextTextFlowLine.absoluteStart + nextTextFlowLine.textLength - 1) >> 0;
  if (endIdx > nextLineEnd) {
    endIdx = nextLineEnd;
  }
  if (!extendSelection)
    begIdx = endIdx;
  if (begIdx == endIdx) {
    begIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateEndIfInReadOnlyElement(textFlow, begIdx);
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateStartIfInReadOnlyElement(textFlow, endIdx);
  } else {
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateStartIfInReadOnlyElement(textFlow, endIdx);
  }
  return range.updateRange(begIdx, endIdx);
};


/**
 * Sets the TextRange up one page.
 * @asparam extendSelection	Indicates that only activeIndex should move
 * @asreturn true if selection changed.
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * @export
 * @param {org.apache.royale.textLayout.elements.TextRange} range
 * @param {boolean=} extendSelection
 * @return {boolean}
 */
org.apache.royale.textLayout.utils.NavigationUtil.previousPage = function(range, extendSelection) {
  extendSelection = typeof extendSelection !== 'undefined' ? extendSelection : false;
  var /** @type {number} */ nextLine = 0;
  if (!org.apache.royale.textLayout.utils.NavigationUtil.validateTextRange(range))
    return false;
  var /** @type {org.apache.royale.textLayout.elements.ITextFlow} */ textFlow = range.textFlow;
  var /** @type {number} */ controllerIndex = textFlow.flowComposer.findControllerIndexAtPosition(range.activePosition);
  var /** @type {org.apache.royale.textLayout.container.IContainerController} */ controller = textFlow.flowComposer.getControllerAt(controllerIndex);
  var /** @type {org.apache.royale.textLayout.compose.ITextFlowLine} */ controllerFirstLine = textFlow.flowComposer.findLineAtPosition(controller.absoluteStart);
  if (range.activePosition <= controller.absoluteStart + controllerFirstLine.textLength) {
    if (controllerIndex == 0)
      return false;
    range.activePosition = textFlow.flowComposer.getControllerAt((controllerIndex - 1) >> 0).absoluteStart;
    if (!extendSelection)
      range.anchorPosition = range.activePosition;
    return true;
  }
  if (controllerIndex != textFlow.flowComposer.numControllers - 1) {
    range.activePosition = controller.absoluteStart;
    if (!extendSelection)
      range.anchorPosition = range.activePosition;
    return true;
  }
  if (!org.apache.royale.textLayout.utils.NavigationUtil.isScrollable(textFlow, range.activePosition))
    return false;
  if (org.apache.royale.textLayout.utils.NavigationUtil.adjustForOversetBack(range))
    return true;
  var /** @type {number} */ begIdx = range.absoluteStart;
  var /** @type {number} */ endIdx = range.absoluteEnd;
  var /** @type {number} */ curLine = textFlow.flowComposer.findLineIndexAtPosition(endIdx);
  var /** @type {org.apache.royale.textLayout.compose.ITextFlowLine} */ curTextFlowLine = textFlow.flowComposer.getLineAt(curLine);
  var /** @type {number} */ lineStart = textFlow.flowComposer.getLineAt(curLine).absoluteStart;
  var /** @type {number} */ linePos = (endIdx - lineStart) >> 0;
  //var /** @type {number} */ nextLine = 0;
  var /** @type {org.apache.royale.textLayout.compose.ITextFlowLine} */ nextTextFlowLine = curTextFlowLine;
  var /** @type {boolean} */ isTTB = textFlow.computedFormat.blockProgression == org.apache.royale.textLayout.formats.BlockProgression.RL;
  var /** @type {number} */ amount;
  controller = textFlow.flowComposer.getControllerAt((textFlow.flowComposer.numControllers - 1) >> 0);
  if (isTTB) {
    amount = controller.compositionWidth * textFlow.configuration.scrollPagePercentage;
  } else {
    amount = controller.compositionHeight * textFlow.configuration.scrollPagePercentage;
  }
  if (isTTB) {
    if ((controller.horizontalScrollPosition + amount + controller.compositionWidth) > 0) {
      controller.horizontalScrollPosition = 0;
      nextLine = textFlow.flowComposer.findLineIndexAtPosition(controller.absoluteStart);
      nextTextFlowLine = textFlow.flowComposer.getLineAt(nextLine);
    } else {
      var /** @type {number} */ oldHorzPos = controller.horizontalScrollPosition;
      controller.horizontalScrollPosition += amount;
      var /** @type {number} */ newHorzPos = controller.horizontalScrollPosition;
      if (oldHorzPos == newHorzPos) {
        nextLine = textFlow.flowComposer.findLineIndexAtPosition(controller.absoluteStart);
        nextTextFlowLine = textFlow.flowComposer.getLineAt(nextLine);
      } else {
        nextLine = curLine;
        while (nextLine > 0) {
          nextLine--;
          nextTextFlowLine = textFlow.flowComposer.getLineAt(nextLine);
          if ((nextTextFlowLine.x - curTextFlowLine.x) >= (newHorzPos - oldHorzPos) || nextTextFlowLine.absoluteStart < controller.absoluteStart)
            break;
        }
      }
    }
  } else {
    if ((controller.verticalScrollPosition - amount + controller.compositionHeight) < 0) {
      controller.verticalScrollPosition = 0;
      nextLine = textFlow.flowComposer.findLineIndexAtPosition(controller.absoluteStart);
      nextTextFlowLine = textFlow.flowComposer.getLineAt(nextLine);
    } else {
      var /** @type {number} */ oldVertPos = controller.verticalScrollPosition;
      controller.verticalScrollPosition -= amount;
      var /** @type {number} */ newVertPos = controller.verticalScrollPosition;
      if (oldVertPos == newVertPos) {
        nextLine = textFlow.flowComposer.findLineIndexAtPosition(controller.absoluteStart);
        nextTextFlowLine = textFlow.flowComposer.getLineAt(nextLine);
      } else {
        nextLine = curLine;
        while (nextLine > 0) {
          nextLine--;
          nextTextFlowLine = textFlow.flowComposer.getLineAt(nextLine);
          if ((curTextFlowLine.y - nextTextFlowLine.y) >= (oldVertPos - newVertPos) || nextTextFlowLine.absoluteStart < controller.absoluteStart)
            break;
        }
      }
    }
  }
  endIdx = (nextTextFlowLine.absoluteStart + linePos) >> 0;
  var /** @type {number} */ nextLineEnd = (nextTextFlowLine.absoluteStart + nextTextFlowLine.textLength - 1) >> 0;
  if (endIdx > nextLineEnd) {
    endIdx = nextLineEnd;
  }
  if (!extendSelection)
    begIdx = endIdx;
  if (begIdx == endIdx) {
    begIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateEndIfInReadOnlyElement(textFlow, begIdx);
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateStartIfInReadOnlyElement(textFlow, endIdx);
  } else {
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateStartIfInReadOnlyElement(textFlow, endIdx);
  }
  return range.updateRange(begIdx, endIdx);
};


/**
 * Sets the TextRange at the end of the line.
 * @asparam extendSelection	Indicates that only activeIndex should move
 * @asreturn true if selection changed.
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * @export
 * @param {org.apache.royale.textLayout.elements.TextRange} range
 * @param {boolean=} extendSelection
 * @return {boolean}
 */
org.apache.royale.textLayout.utils.NavigationUtil.endOfLine = function(range, extendSelection) {
  extendSelection = typeof extendSelection !== 'undefined' ? extendSelection : false;
  if (!org.apache.royale.textLayout.utils.NavigationUtil.validateTextRange(range))
    return false;
  var /** @type {org.apache.royale.textLayout.elements.ITextFlow} */ textFlow = range.textFlow;
  org.apache.royale.textLayout.utils.NavigationUtil.checkCompose(textFlow.flowComposer, range.absoluteEnd);
  var /** @type {number} */ begIdx = range.anchorPosition;
  var /** @type {number} */ endIdx = range.activePosition;
  var /** @type {number} */ curLine = textFlow.flowComposer.findLineIndexAtPosition(endIdx);
  var /** @type {number} */ lineStart = textFlow.flowComposer.getLineAt(curLine).absoluteStart;
  var /** @type {number} */ lineEnd = (lineStart + textFlow.flowComposer.getLineAt(curLine).textLength - 1) >> 0;
  var /** @type {org.apache.royale.textLayout.elements.IFlowLeafElement} */ leaf = textFlow.findLeaf(endIdx);
  var /** @type {org.apache.royale.textLayout.elements.IParagraphElement} */ para = leaf.getParagraph();
  if (org.apache.royale.textLayout.utils.CharacterUtil.isWhitespace(para.getCharCodeAtPosition((lineEnd - para.getAbsoluteStart()) >> 0))) {
    endIdx = lineEnd;
  } else {
    endIdx = (lineEnd + 1) >> 0;
  }
  if (!extendSelection)
    begIdx = endIdx;
  if (begIdx == endIdx) {
    begIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateEndIfInReadOnlyElement(textFlow, begIdx);
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateStartIfInReadOnlyElement(textFlow, endIdx);
  } else {
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateStartIfInReadOnlyElement(textFlow, endIdx);
  }
  return range.updateRange(begIdx, endIdx);
};


/**
 * Sets the TextRange at the beginning of the line.
 * @asparam extendSelection	Indicates that only activeIndex should move
 * @asreturn true if selection changed.
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * @export
 * @param {org.apache.royale.textLayout.elements.TextRange} range
 * @param {boolean=} extendSelection
 * @return {boolean}
 */
org.apache.royale.textLayout.utils.NavigationUtil.startOfLine = function(range, extendSelection) {
  extendSelection = typeof extendSelection !== 'undefined' ? extendSelection : false;
  if (!org.apache.royale.textLayout.utils.NavigationUtil.validateTextRange(range))
    return false;
  var /** @type {org.apache.royale.textLayout.elements.ITextFlow} */ textFlow = range.textFlow;
  org.apache.royale.textLayout.utils.NavigationUtil.checkCompose(textFlow.flowComposer, range.absoluteEnd);
  var /** @type {number} */ begIdx = range.anchorPosition;
  var /** @type {number} */ endIdx = range.activePosition;
  var /** @type {number} */ curLine = textFlow.flowComposer.findLineIndexAtPosition(endIdx);
  var /** @type {number} */ lineStart = textFlow.flowComposer.getLineAt(curLine).absoluteStart;
  endIdx = lineStart;
  if (!extendSelection)
    begIdx = endIdx;
  if (begIdx == endIdx) {
    begIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateEndIfInReadOnlyElement(textFlow, begIdx);
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateStartIfInReadOnlyElement(textFlow, endIdx);
  } else {
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateStartIfInReadOnlyElement(textFlow, endIdx);
  }
  return range.updateRange(begIdx, endIdx);
};


/**
 * Sets the TextRange at the end of the document.
 * @asparam extendSelection	Indicates that only activeIndex should move
 * @asreturn true if selection changed.
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * @export
 * @param {org.apache.royale.textLayout.elements.TextRange} range
 * @param {boolean=} extendSelection
 * @return {boolean}
 */
org.apache.royale.textLayout.utils.NavigationUtil.endOfDocument = function(range, extendSelection) {
  extendSelection = typeof extendSelection !== 'undefined' ? extendSelection : false;
  if (!org.apache.royale.textLayout.utils.NavigationUtil.validateTextRange(range))
    return false;
  var /** @type {org.apache.royale.textLayout.elements.ITextFlow} */ textFlow = range.textFlow;
  var /** @type {number} */ begIdx = range.anchorPosition;
  var /** @type {number} */ endIdx = range.activePosition;
  endIdx = textFlow.textLength;
  if (!extendSelection)
    begIdx = endIdx;
  if (begIdx == endIdx) {
    begIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateEndIfInReadOnlyElement(textFlow, begIdx);
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateStartIfInReadOnlyElement(textFlow, endIdx);
  } else {
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateStartIfInReadOnlyElement(textFlow, endIdx);
  }
  return range.updateRange(begIdx, endIdx);
};


/**
 * Sets the TextRange at the beginning of the document.
 * @asparam extendSelection	Indicates that only activeIndex should move
 * @asreturn true if selection changed.
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * @export
 * @param {org.apache.royale.textLayout.elements.TextRange} range
 * @param {boolean=} extendSelection
 * @return {boolean}
 */
org.apache.royale.textLayout.utils.NavigationUtil.startOfDocument = function(range, extendSelection) {
  extendSelection = typeof extendSelection !== 'undefined' ? extendSelection : false;
  var /** @type {number} */ begIdx = range.anchorPosition;
  var /** @type {number} */ endIdx = 0;
  if (!extendSelection)
    begIdx = endIdx;
  if (begIdx == endIdx) {
    begIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateEndIfInReadOnlyElement(range.textFlow, begIdx);
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateStartIfInReadOnlyElement(range.textFlow, endIdx);
  } else {
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateStartIfInReadOnlyElement(range.textFlow, endIdx);
  }
  return range.updateRange(begIdx, endIdx);
};


/**
 * Sets the TextRange at the beginning of the paragraph.
 * @asparam extendSelection	Indicates that only activeIndex should move
 * @asreturn true if selection changed.
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * @export
 * @param {org.apache.royale.textLayout.elements.TextRange} range
 * @param {boolean=} extendSelection
 * @return {boolean}
 */
org.apache.royale.textLayout.utils.NavigationUtil.startOfParagraph = function(range, extendSelection) {
  extendSelection = typeof extendSelection !== 'undefined' ? extendSelection : false;
  var /** @type {number} */ begIdx = range.anchorPosition;
  var /** @type {number} */ endIdx = range.activePosition;
  var /** @type {org.apache.royale.textLayout.elements.IFlowLeafElement} */ leaf = range.textFlow.findLeaf(endIdx);
  var /** @type {org.apache.royale.textLayout.elements.IParagraphElement} */ para = leaf.getParagraph();
  endIdx = para.getAbsoluteStart();
  if (!extendSelection)
    begIdx = endIdx;
  if (begIdx == endIdx) {
    begIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateStartIfInReadOnlyElement(range.textFlow, begIdx);
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateEndIfInReadOnlyElement(range.textFlow, endIdx);
  } else {
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateEndIfInReadOnlyElement(range.textFlow, endIdx);
  }
  return range.updateRange(begIdx, endIdx);
};


/**
 * Sets the TextRange at the end of the paragraph.
 * @asparam extendSelection	Indicates that only activeIndex should move
 * @asreturn true if selection changed.
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * @export
 * @param {org.apache.royale.textLayout.elements.TextRange} range
 * @param {boolean=} extendSelection
 * @return {boolean}
 */
org.apache.royale.textLayout.utils.NavigationUtil.endOfParagraph = function(range, extendSelection) {
  extendSelection = typeof extendSelection !== 'undefined' ? extendSelection : false;
  if (!org.apache.royale.textLayout.utils.NavigationUtil.validateTextRange(range))
    return false;
  var /** @type {number} */ begIdx = range.anchorPosition;
  var /** @type {number} */ endIdx = range.activePosition;
  var /** @type {org.apache.royale.textLayout.elements.IFlowLeafElement} */ leaf = range.textFlow.findLeaf(endIdx);
  var /** @type {org.apache.royale.textLayout.elements.IParagraphElement} */ para = leaf.getParagraph();
  endIdx = (para.getAbsoluteStart() + para.textLength - 1) >> 0;
  if (!extendSelection)
    begIdx = endIdx;
  if (begIdx == endIdx) {
    begIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateStartIfInReadOnlyElement(range.textFlow, begIdx);
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateEndIfInReadOnlyElement(range.textFlow, endIdx);
  } else {
    endIdx = org.apache.royale.textLayout.utils.NavigationUtil.updateEndIfInReadOnlyElement(range.textFlow, endIdx);
  }
  return range.updateRange(begIdx, endIdx);
};


/** If the range is in overset text (after the last container in a non-scrolling flow), adjust the range so it is at the end of the flow. 
 * @private
 * @param {org.apache.royale.textLayout.elements.TextRange} range
 * @return {boolean}
 */
org.apache.royale.textLayout.utils.NavigationUtil.adjustForOversetForward = function(range) {
  var /** @type {org.apache.royale.textLayout.compose.IFlowComposer} */ flowComposer = range.textFlow.flowComposer;
  var /** @type {org.apache.royale.textLayout.container.IContainerController} */ controller = null;
  org.apache.royale.textLayout.utils.NavigationUtil.checkCompose(flowComposer, range.absoluteEnd);
  if (range.absoluteEnd >= flowComposer.damageAbsoluteStart - 1) {
    org.apache.royale.textLayout.utils.NavigationUtil.clampToFit(range, (flowComposer.damageAbsoluteStart - 1) >> 0);
    return false;
  }
  if (flowComposer && flowComposer.numControllers) {
    var /** @type {number} */ controllerIndex = flowComposer.findControllerIndexAtPosition(range.absoluteEnd);
    if (controllerIndex >= 0)
      controller = flowComposer.getControllerAt(controllerIndex);
    if (controllerIndex == flowComposer.numControllers - 1) {
      if (controller.absoluteStart + controller.textLength <= range.absoluteEnd && controller.absoluteStart + controller.textLength != range.textFlow.textLength)
        controller = null;
    }
  }
  if (!controller) {
    range.anchorPosition = range.textFlow.textLength;
    range.activePosition = range.anchorPosition;
    return true;
  }
  return false;
};


/**
 * @private
 * @param {org.apache.royale.textLayout.elements.TextRange} range
 * @param {number} endPos
 */
org.apache.royale.textLayout.utils.NavigationUtil.clampToFit = function(range, endPos) {
  if (endPos < 0)
    endPos = 0;
  range.anchorPosition = (Math.min(range.anchorPosition, endPos)) >> 0;
  range.activePosition = (Math.min(range.activePosition, endPos)) >> 0;
};


/** If the range is in overset text (after the last container in a non-scrolling flow), adjust the range so it is at the end of the last controller in the flow. 
 * @private
 * @param {org.apache.royale.textLayout.elements.TextRange} range
 * @return {boolean}
 */
org.apache.royale.textLayout.utils.NavigationUtil.adjustForOversetBack = function(range) {
  var /** @type {org.apache.royale.textLayout.compose.IFlowComposer} */ flowComposer = range.textFlow.flowComposer;
  if (flowComposer) {
    org.apache.royale.textLayout.utils.NavigationUtil.checkCompose(flowComposer, range.absoluteEnd);
    if (range.absoluteEnd > flowComposer.damageAbsoluteStart - 1) {
      org.apache.royale.textLayout.utils.NavigationUtil.clampToFit(range, (flowComposer.damageAbsoluteStart - 1) >> 0);
      return true;
    }
    if (flowComposer.findControllerIndexAtPosition(range.absoluteEnd) == -1) {
      range.anchorPosition = org.apache.royale.textLayout.utils.NavigationUtil.endOfLastController(range.textFlow);
      range.activePosition = range.anchorPosition;
      return true;
    }
  }
  return false;
};


/**
 * @private
 * @param {org.apache.royale.textLayout.compose.IFlowComposer} flowComposer
 * @param {number} pos
 */
org.apache.royale.textLayout.utils.NavigationUtil.checkCompose = function(flowComposer, pos) {
  if (flowComposer.damageAbsoluteStart <= pos)
    flowComposer.composeToPosition(pos);
};


/**
 * @private
 * @param {org.apache.royale.textLayout.elements.ITextFlow} flowRoot
 * @return {number}
 */
org.apache.royale.textLayout.utils.NavigationUtil.endOfLastController = function(flowRoot) {
  var /** @type {org.apache.royale.textLayout.compose.IFlowComposer} */ flowComposer = flowRoot.flowComposer;
  if (!flowComposer || flowComposer.numControllers <= 0)
    return 0;
  var /** @type {org.apache.royale.textLayout.container.IContainerController} */ controller = flowComposer.getControllerAt((flowComposer.numControllers - 1) >> 0);
  return (controller.absoluteStart + Math.max(controller.textLength - 1, 0)) >> 0;
};


/**
 * @private
 * @param {org.apache.royale.textLayout.elements.ITextFlow} flowRoot
 * @param {number} absolutePos
 * @return {boolean}
 */
org.apache.royale.textLayout.utils.NavigationUtil.isOverset = function(flowRoot, absolutePos) {
  var /** @type {org.apache.royale.textLayout.compose.IFlowComposer} */ flowComposer = flowRoot.flowComposer;
  return (!flowComposer || flowComposer.findControllerIndexAtPosition(absolutePos) == -1);
};


/**
 * @private
 * @param {org.apache.royale.textLayout.elements.ITextFlow} flowRoot
 * @param {number} absolutePos
 * @return {boolean}
 */
org.apache.royale.textLayout.utils.NavigationUtil.isScrollable = function(flowRoot, absolutePos) {
  var /** @type {org.apache.royale.textLayout.compose.IFlowComposer} */ flowComposer = flowRoot.flowComposer;
  if (!flowComposer)
    return false;
  var /** @type {number} */ controllerIndex = flowComposer.findControllerIndexAtPosition(absolutePos);
  if (controllerIndex >= 0) {
    var /** @type {org.apache.royale.textLayout.container.IContainerController} */ controller = flowComposer.getControllerAt(controllerIndex);
    var /** @type {string} */ blockProgression = org.apache.royale.utils.Language.string(controller.rootElement.computedFormat.blockProgression);
    return ((blockProgression == org.apache.royale.textLayout.formats.BlockProgression.TB && controller.verticalScrollPolicy != org.apache.royale.textLayout.container.ScrollPolicy.OFF) || (blockProgression == org.apache.royale.textLayout.formats.BlockProgression.RL && controller.horizontalScrollPolicy != org.apache.royale.textLayout.container.ScrollPolicy.OFF));
  }
  return false;
};


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
org.apache.royale.textLayout.utils.NavigationUtil.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'NavigationUtil', qName: 'org.apache.royale.textLayout.utils.NavigationUtil', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
org.apache.royale.textLayout.utils.NavigationUtil.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    methods: function () {
      return {
        '|previousAtomPosition': { type: 'int', declaredBy: 'org.apache.royale.textLayout.utils.NavigationUtil', parameters: function () { return [ 'org.apache.royale.textLayout.elements.ITextFlow', false ,'int', false ]; }},
        '|nextAtomPosition': { type: 'int', declaredBy: 'org.apache.royale.textLayout.utils.NavigationUtil', parameters: function () { return [ 'org.apache.royale.textLayout.elements.ITextFlow', false ,'int', false ]; }},
        '|previousWordPosition': { type: 'int', declaredBy: 'org.apache.royale.textLayout.utils.NavigationUtil', parameters: function () { return [ 'org.apache.royale.textLayout.elements.ITextFlow', false ,'int', false ]; }},
        '|nextWordPosition': { type: 'int', declaredBy: 'org.apache.royale.textLayout.utils.NavigationUtil', parameters: function () { return [ 'org.apache.royale.textLayout.elements.ITextFlow', false ,'int', false ]; }},
        '|updateStartIfInReadOnlyElement': { type: 'int', declaredBy: 'org.apache.royale.textLayout.utils.NavigationUtil', parameters: function () { return [ 'org.apache.royale.textLayout.elements.ITextFlow', false ,'int', false ]; }},
        '|updateEndIfInReadOnlyElement': { type: 'int', declaredBy: 'org.apache.royale.textLayout.utils.NavigationUtil', parameters: function () { return [ 'org.apache.royale.textLayout.elements.ITextFlow', false ,'int', false ]; }},
        '|nextCharacter': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.utils.NavigationUtil', parameters: function () { return [ 'org.apache.royale.textLayout.elements.TextRange', false ,'Boolean', true ]; }},
        '|previousCharacter': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.utils.NavigationUtil', parameters: function () { return [ 'org.apache.royale.textLayout.elements.TextRange', false ,'Boolean', true ]; }},
        '|nextWord': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.utils.NavigationUtil', parameters: function () { return [ 'org.apache.royale.textLayout.elements.TextRange', false ,'Boolean', true ]; }},
        '|previousWord': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.utils.NavigationUtil', parameters: function () { return [ 'org.apache.royale.textLayout.elements.TextRange', false ,'Boolean', true ]; }},
        '|computeEndIdx': { type: 'int', declaredBy: 'org.apache.royale.textLayout.utils.NavigationUtil', parameters: function () { return [ 'org.apache.royale.textLayout.compose.ITextFlowLine', false ,'org.apache.royale.textLayout.compose.ITextFlowLine', false ,'String', false ,'Boolean', false ,'org.apache.royale.geom.Point', false ]; }},
        '|nextLine': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.utils.NavigationUtil', parameters: function () { return [ 'org.apache.royale.textLayout.elements.TextRange', false ,'Boolean', true ]; }},
        '|previousLine': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.utils.NavigationUtil', parameters: function () { return [ 'org.apache.royale.textLayout.elements.TextRange', false ,'Boolean', true ]; }},
        '|nextPage': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.utils.NavigationUtil', parameters: function () { return [ 'org.apache.royale.textLayout.elements.TextRange', false ,'Boolean', true ]; }},
        '|previousPage': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.utils.NavigationUtil', parameters: function () { return [ 'org.apache.royale.textLayout.elements.TextRange', false ,'Boolean', true ]; }},
        '|endOfLine': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.utils.NavigationUtil', parameters: function () { return [ 'org.apache.royale.textLayout.elements.TextRange', false ,'Boolean', true ]; }},
        '|startOfLine': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.utils.NavigationUtil', parameters: function () { return [ 'org.apache.royale.textLayout.elements.TextRange', false ,'Boolean', true ]; }},
        '|endOfDocument': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.utils.NavigationUtil', parameters: function () { return [ 'org.apache.royale.textLayout.elements.TextRange', false ,'Boolean', true ]; }},
        '|startOfDocument': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.utils.NavigationUtil', parameters: function () { return [ 'org.apache.royale.textLayout.elements.TextRange', false ,'Boolean', true ]; }},
        '|startOfParagraph': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.utils.NavigationUtil', parameters: function () { return [ 'org.apache.royale.textLayout.elements.TextRange', false ,'Boolean', true ]; }},
        '|endOfParagraph': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.utils.NavigationUtil', parameters: function () { return [ 'org.apache.royale.textLayout.elements.TextRange', false ,'Boolean', true ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
org.apache.royale.textLayout.utils.NavigationUtil.prototype.ROYALE_COMPILE_FLAGS = 10;

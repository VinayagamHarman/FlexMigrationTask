/**
 * Generated by Apache Royale Compiler from org/apache/royale/textLayout/edit/TextFlowEdit.as
 * org.apache.royale.textLayout.edit.TextFlowEdit
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('org.apache.royale.textLayout.edit.TextFlowEdit');
/* Royale Dependency List: org.apache.royale.textLayout.conversion.ConversionConstants,org.apache.royale.textLayout.edit.IMemento,org.apache.royale.textLayout.edit.MementoList,org.apache.royale.textLayout.edit.ModelEdit,org.apache.royale.textLayout.edit.TextScrap,org.apache.royale.textLayout.elements.ElementHelper,org.apache.royale.textLayout.elements.FlowElement,org.apache.royale.textLayout.elements.IFlowElement,org.apache.royale.textLayout.elements.IFlowGroupElement,org.apache.royale.textLayout.elements.IFlowLeafElement,org.apache.royale.textLayout.elements.ILinkElement,org.apache.royale.textLayout.elements.IListItemElement,org.apache.royale.textLayout.elements.IParagraphElement,org.apache.royale.textLayout.elements.ISpanElement,org.apache.royale.textLayout.elements.ISubParagraphGroupElementBase,org.apache.royale.textLayout.elements.ITCYElement,org.apache.royale.textLayout.elements.ITextFlow,org.apache.royale.textLayout.formats.ITextLayoutFormat,org.apache.royale.textLayout.formats.TextLayoutFormat,org.apache.royale.utils.Language,XML*/




/**
 * @constructor
 */
org.apache.royale.textLayout.edit.TextFlowEdit = function() {
};


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('org.apache.royale.textLayout.edit.TextFlowEdit', org.apache.royale.textLayout.edit.TextFlowEdit);


/**
 * @export
 * @param {org.apache.royale.textLayout.elements.ITextFlow} textFlow
 * @param {number} startPos
 * @param {number} endPos
 * @return {org.apache.royale.textLayout.elements.IParagraphElement}
 */
org.apache.royale.textLayout.edit.TextFlowEdit.deleteRange = function(textFlow, startPos, endPos) {
  var /** @type {org.apache.royale.textLayout.elements.IParagraphElement} */ mergePara;
  if (endPos > startPos) {
    var /** @type {org.apache.royale.textLayout.elements.IFlowLeafElement} */ firstLeafInRange = textFlow.findLeaf(startPos);
    var /** @type {org.apache.royale.textLayout.elements.IFlowLeafElement} */ lastLeafInRange = textFlow.findLeaf((endPos - 1) >> 0);
    var /** @type {org.apache.royale.textLayout.elements.IParagraphElement} */ firstParagraphInRange = firstLeafInRange.getParagraph();
    var /** @type {org.apache.royale.textLayout.elements.IParagraphElement} */ lastParagraphInRange = lastLeafInRange.getParagraph();
    var /** @type {number} */ firstParaStart = firstParagraphInRange.getAbsoluteStart();
    var /** @type {number} */ lastParaEnd = (lastParagraphInRange.getAbsoluteStart() + lastParagraphInRange.textLength) >> 0;
    var /** @type {boolean} */ doMerge = false;
    if (firstParagraphInRange == lastParagraphInRange)
      doMerge = (endPos == lastParaEnd && startPos != firstParaStart);
    else
      doMerge = (startPos != firstParaStart);
    if (doMerge) {
      var /** @type {org.apache.royale.textLayout.elements.IFlowLeafElement} */ followingLeaf = textFlow.findLeaf(endPos);
      if (followingLeaf) {
        mergePara = followingLeaf.getParagraph();
        if (mergePara.textLength == 1 && org.apache.royale.utils.Language.is(mergePara.parent, org.apache.royale.textLayout.elements.IListItemElement) && mergePara.parent.numChildren > 1)
          mergePara = null;
      }
    }
  }
  org.apache.royale.textLayout.edit.TextFlowEdit.deleteRangeInternal(textFlow, startPos, (endPos - startPos) >> 0);
  if (mergePara) {
    var /** @type {org.apache.royale.textLayout.elements.IFlowLeafElement} */ previousLeaf = mergePara.getFirstLeaf().getPreviousLeaf();
    mergePara = previousLeaf ? previousLeaf.getParagraph() : null;
  }
  return mergePara;
};


/**
 * @royaleignorecoercion org.apache.royale.textLayout.elements.IFlowGroupElement
 * @royaleignorecoercion org.apache.royale.textLayout.elements.ISpanElement
 * @private
 * @param {Object} element
 * @param {number} relativeStart
 * @param {number} numToDelete
 */
org.apache.royale.textLayout.edit.TextFlowEdit.deleteRangeInternal = function(element, relativeStart, numToDelete) {
  var /** @type {number} */ pendingDeleteStart = -1;
  var /** @type {number} */ pendingDeleteCount = 0;
  var /** @type {number} */ childIndex = element.findChildIndexAtPosition(relativeStart);
  while (numToDelete > 0 && childIndex < element.numChildren) {
    var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ child = element.getChildAt(childIndex);
    if (relativeStart <= child.parentRelativeStart && numToDelete >= child.textLength) {
      if (pendingDeleteStart < 0)
        pendingDeleteStart = childIndex;
      pendingDeleteCount++;
      numToDelete -= child.textLength;
    } else {
      if (pendingDeleteStart >= 0) {
        element.replaceChildren(pendingDeleteStart, (pendingDeleteStart + pendingDeleteCount) >> 0);
        childIndex -= pendingDeleteCount;
        pendingDeleteStart = -1;
        pendingDeleteCount = 0;
      }
      var /** @type {number} */ childStart = child.parentRelativeStart;
      var /** @type {number} */ childRelativeStart = (Math.max(relativeStart - childStart, 0)) >> 0;
      var /** @type {number} */ childNumToDelete = (Math.min(child.textLength - childRelativeStart, numToDelete)) >> 0;
      if (org.apache.royale.utils.Language.is(child, org.apache.royale.textLayout.elements.ISpanElement)) {
        var /** @type {Object} */ span = child;
        span.replaceText(childRelativeStart, (childRelativeStart + childNumToDelete) >> 0, "");
        numToDelete -= childNumToDelete;
      } else {
        
        org.apache.royale.textLayout.edit.TextFlowEdit.deleteRangeInternal(child, childRelativeStart, childNumToDelete);
        numToDelete -= childNumToDelete;
      }
    }
    childIndex++;
  }
  if (pendingDeleteStart >= 0)
    element.replaceChildren(pendingDeleteStart, (pendingDeleteStart + pendingDeleteCount) >> 0);
};


/**
 * @private
 * @param {org.apache.royale.textLayout.elements.IFlowGroupElement} element
 * @param {org.apache.royale.textLayout.elements.IFlowElement} prospectiveChild
 * @return {org.apache.royale.textLayout.elements.IFlowGroupElement}
 */
org.apache.royale.textLayout.edit.TextFlowEdit.findLowestPossibleParent = function(element, prospectiveChild) {
  while (element && !element.canOwnFlowElement(prospectiveChild))
    element = element.parent;
  return element;
};


/**
 * @private
 * @param {org.apache.royale.textLayout.elements.IFlowElement} element
 */
org.apache.royale.textLayout.edit.TextFlowEdit.removePasteAttributes = function(element) {
  if (!element)
    return;
  if (org.apache.royale.utils.Language.is(element, org.apache.royale.textLayout.elements.IFlowGroupElement) && element.format) {
    var /** @type {org.apache.royale.textLayout.elements.IFlowGroupElement} */ flowGroupElement = org.apache.royale.utils.Language.as(element, org.apache.royale.textLayout.elements.IFlowGroupElement, true);
    if (element.format.getStyle(org.apache.royale.textLayout.conversion.ConversionConstants.MERGE_TO_NEXT_ON_PASTE) !== undefined)
      org.apache.royale.textLayout.edit.TextFlowEdit.removePasteAttributes(flowGroupElement.getChildAt((flowGroupElement.numChildren - 1) >> 0));
  }
  element.setStyle(org.apache.royale.textLayout.conversion.ConversionConstants.MERGE_TO_NEXT_ON_PASTE, undefined);
};


/**
 * @private
 * @param {org.apache.royale.textLayout.elements.IFlowGroupElement} destinationElement
 * @param {number} childIndex
 * @param {Object} insertThis
 */
org.apache.royale.textLayout.edit.TextFlowEdit.applyFormatToElement = function(destinationElement, childIndex, insertThis) {
  var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ formatSourceSibling;
  if (childIndex > 0)
    formatSourceSibling = destinationElement.getChildAt((childIndex - 1) >> 0);
  else
    formatSourceSibling = destinationElement.getChildAt(0);
  if (formatSourceSibling) {
    var /** @type {org.apache.royale.textLayout.formats.ITextLayoutFormat} */ spanFormat;
    if (org.apache.royale.utils.Language.is(formatSourceSibling, org.apache.royale.textLayout.elements.IFlowGroupElement)) {
      var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ element = org.apache.royale.utils.Language.as(formatSourceSibling, org.apache.royale.textLayout.elements.IFlowGroupElement, true).getLastLeaf();
      var /** @type {org.apache.royale.textLayout.formats.TextLayoutFormat} */ concatFormat;
      while (element != formatSourceSibling.parent) {
        if (element.format) {
          if (!concatFormat)
            concatFormat = new org.apache.royale.textLayout.formats.TextLayoutFormat(element.format);
          else
            concatFormat.concatInheritOnly(element.format);
        }
        element = element.parent;
      }
      spanFormat = concatFormat;
    }
    else
      spanFormat = formatSourceSibling.format;
    if (org.apache.royale.utils.Language.is(insertThis, Array)) {
      var foreachiter0_target = insertThis;
      for (var foreachiter0 in foreachiter0_target) 
      {
      var scrapElement = foreachiter0_target[foreachiter0];
      
        if (org.apache.royale.utils.Language.is(scrapElement, org.apache.royale.textLayout.elements.IFlowLeafElement))
          scrapElement.format = spanFormat;
        else
          scrapElement.format = formatSourceSibling.format;}
      
    }
    else if (org.apache.royale.utils.Language.is(insertThis, org.apache.royale.textLayout.elements.IFlowLeafElement))
      insertThis.format = spanFormat;
    else
      insertThis.format = formatSourceSibling.format;
  }
};


/**
 * Replaces the range of text positions that the <code>startPos</code> and
 * <code>endPos</code> parameters specify with the <code>textScrap</code> parameter in
 * <code>theFlow</code>.
 * <p>To delete elements, pass <code>null</code> for <code>newTextFlow</code>.</p>
 * <p>To insert an element, pass the same value for <code>startPos</code> and <code>endPos</code>.
 * <p>The new element will be inserted before the specified index.</p>
 * <p>To append the ITextFlow, pass <code>theFlow.length</code> for <code>startPos</code> and <code>endPos</code>.</p>
 * 
 * @asparam destinationFlow The ITextFlow that is being inserted into.
 * @asparam absoluteStart The index value of the first position of the replacement range in the ITextFlow.
 * @asparam textScrap The TextScrap to be pasted into theFlow.
 * @export
 * @param {org.apache.royale.textLayout.elements.ITextFlow} destinationFlow
 * @param {number} absoluteStart
 * @param {org.apache.royale.textLayout.edit.TextScrap} textScrap
 * @param {boolean} applyFormat
 * @return {number}
 */
org.apache.royale.textLayout.edit.TextFlowEdit.insertTextScrap = function(destinationFlow, absoluteStart, textScrap, applyFormat) {
  if (!textScrap)
    return absoluteStart;
  var /** @type {org.apache.royale.textLayout.elements.ITextFlow} */ scrapFlow = textScrap.textFlow.deepCopy();
  var /** @type {org.apache.royale.textLayout.elements.IFlowLeafElement} */ scrapLeaf = scrapFlow.getFirstLeaf();
  var /** @type {org.apache.royale.textLayout.elements.IFlowLeafElement} */ destinationLeaf = destinationFlow.findLeaf(absoluteStart);
  var /** @type {number} */ insertPosition = absoluteStart;
  var /** @type {boolean} */ firstParagraph = true;
  var /** @type {boolean} */ doSplit = false;
  var /** @type {org.apache.royale.textLayout.elements.IFlowGroupElement} */ destinationElement;
  while (scrapLeaf) {
    org.apache.royale.textLayout.edit.TextFlowEdit.removePasteAttributes(scrapLeaf);
    var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ scrapElement = scrapLeaf;
    var /** @type {org.apache.royale.textLayout.elements.IParagraphElement} */ scrapParagraph = scrapLeaf.getParagraph();
    var /** @type {org.apache.royale.textLayout.elements.IParagraphElement} */ destinationParagraph = destinationLeaf ? destinationLeaf.getParagraph() : destinationParagraph;
    if (firstParagraph && (destinationParagraph.textLength > 1 || applyFormat)) {
      if (!scrapParagraph.format || scrapParagraph.format.getStyle(org.apache.royale.textLayout.conversion.ConversionConstants.MERGE_TO_NEXT_ON_PASTE) === undefined)
        doSplit = true;
      scrapElement = scrapParagraph.getChildAt(0);
    } else {
      if (applyFormat) {
        destinationElement = destinationLeaf ? org.apache.royale.textLayout.edit.TextFlowEdit.findLowestPossibleParent(destinationLeaf.parent, scrapElement) : org.apache.royale.textLayout.edit.TextFlowEdit.findLowestPossibleParent(destinationElement, scrapElement);
        var /** @type {number} */ currentIndex = destinationElement.findChildIndexAtPosition((insertPosition - destinationElement.getAbsoluteStart()) >> 0);
        org.apache.royale.textLayout.edit.TextFlowEdit.applyFormatToElement(destinationElement, currentIndex, scrapElement);
      }
      while (scrapElement && scrapElement.parent && (!scrapElement.parent.format || scrapElement.parent.format.getStyle(org.apache.royale.textLayout.conversion.ConversionConstants.MERGE_TO_NEXT_ON_PASTE) === undefined) && !org.apache.royale.utils.Language.is(scrapElement.parent, org.apache.royale.textLayout.elements.ITextFlow))
        scrapElement = scrapElement.parent;
    }
    destinationElement = destinationLeaf ? org.apache.royale.textLayout.edit.TextFlowEdit.findLowestPossibleParent(destinationLeaf.parent, scrapElement) : org.apache.royale.textLayout.edit.TextFlowEdit.findLowestPossibleParent(destinationElement, scrapElement);
    while (!destinationElement) {
      scrapElement = scrapElement.parent;
      
      destinationElement = org.apache.royale.textLayout.edit.TextFlowEdit.findLowestPossibleParent(destinationLeaf.parent, scrapElement);
    }
    
    org.apache.royale.textLayout.edit.TextFlowEdit.removePasteAttributes(scrapElement);
    var /** @type {number} */ destinationStart = destinationElement.getAbsoluteStart();
    if (firstParagraph && doSplit) {
      
      org.apache.royale.textLayout.edit.ModelEdit.splitElement(destinationFlow, destinationElement, (insertPosition - destinationStart) >> 0);
      var /** @type {org.apache.royale.textLayout.elements.IFlowGroupElement} */ scrapParent = scrapElement.parent;
      var /** @type {Array} */ scrapChildren = scrapParent.mxmlChildren;
      scrapParent.replaceChildren(0, scrapParent.numChildren);
      if (scrapParent.parent)
        scrapParent.parent.removeChild(scrapParent);
      if (applyFormat)
        org.apache.royale.textLayout.edit.TextFlowEdit.applyFormatToElement(destinationElement, destinationElement.numChildren, scrapChildren);
      destinationElement.replaceChildren(destinationElement.numChildren, destinationElement.numChildren, scrapChildren);
      scrapElement = destinationElement.getChildAt((destinationElement.numChildren - 1) >> 0);
      firstParagraph = false;
    } else {
      var /** @type {number} */ childIndex = destinationElement.findChildIndexAtPosition((insertPosition - destinationElement.getAbsoluteStart()) >> 0);
      var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ child = destinationElement.getChildAt(childIndex);
      var /** @type {number} */ childStart = child.getAbsoluteStart();
      if (insertPosition == childStart + child.textLength)
        ++childIndex; else if (insertPosition > childStart) {
        if (org.apache.royale.utils.Language.is(child, org.apache.royale.textLayout.elements.IFlowLeafElement))
          child.splitAtPosition((insertPosition - childStart) >> 0);
        else
          org.apache.royale.textLayout.edit.ModelEdit.splitElement(destinationFlow, child, (insertPosition - childStart) >> 0);
        ++childIndex;
      }
      if (applyFormat)
        org.apache.royale.textLayout.edit.TextFlowEdit.applyFormatToElement(destinationElement, childIndex, scrapElement);
      destinationElement.replaceChildren(childIndex, childIndex, scrapElement);
    }
    destinationLeaf = org.apache.royale.utils.Language.is(scrapElement, org.apache.royale.textLayout.elements.IFlowLeafElement) ? org.apache.royale.utils.Language.as(scrapElement, org.apache.royale.textLayout.elements.IFlowLeafElement, true).getNextLeaf() : org.apache.royale.utils.Language.as(scrapElement, org.apache.royale.textLayout.elements.IFlowGroupElement, true).getLastLeaf().getNextLeaf();
    insertPosition = (destinationLeaf ? destinationLeaf.getAbsoluteStart() : destinationFlow.textLength - 1) >> 0;
    scrapLeaf = scrapFlow.getFirstLeaf();
    if (destinationLeaf && scrapLeaf && scrapLeaf.getParagraph() == scrapParagraph) {
      if (destinationLeaf.getParagraph() != destinationParagraph) {
        insertPosition--;
        destinationLeaf = null;
      }
    }
  }
  if (scrapParagraph.getStyle(org.apache.royale.textLayout.conversion.ConversionConstants.MERGE_TO_NEXT_ON_PASTE) == "true" && insertPosition == destinationParagraph.getAbsoluteStart() + destinationParagraph.textLength)
    insertPosition--;
  return insertPosition;
};


/**
 * Creates a TCY run out of the selected positions.
 * @asparam theFlow The ITextFlow of interest.
 * @asparam startPos The index value of the first position of the ITextFlow to be turned into a TCY run.
 * @asparam endPos The index value following the end position of the ITextFlow to be turned into a TCY run.
 * @export
 * @param {org.apache.royale.textLayout.elements.ITextFlow} theFlow
 * @param {number} startPos
 * @param {number} endPos
 * @return {boolean}
 */
org.apache.royale.textLayout.edit.TextFlowEdit.makeTCY = function(theFlow, startPos, endPos) {
  var /** @type {boolean} */ madeTCY = true;
  var /** @type {org.apache.royale.textLayout.elements.IParagraphElement} */ curPara = theFlow.findAbsoluteParagraph(startPos);
  if (!curPara)
    return false;
  while (curPara) {
    var /** @type {number} */ paraEnd = (curPara.getAbsoluteStart() + curPara.textLength) >> 0;
    var /** @type {number} */ curEndPos = (Math.min(paraEnd, endPos)) >> 0;
    if (org.apache.royale.textLayout.edit.TextFlowEdit.canInsertSPBlock(theFlow, startPos, curEndPos, "TCYElement") && curPara.textLength > 1) {
      var /** @type {org.apache.royale.textLayout.elements.ITCYElement} */ new_tcyElem = org.apache.royale.textLayout.elements.ElementHelper.getTCY();
      madeTCY = madeTCY && org.apache.royale.textLayout.edit.TextFlowEdit.insertNewSPBlock(theFlow, startPos, curEndPos, new_tcyElem, "TCYElement");
    }
    else
      madeTCY = false;
    if (paraEnd < endPos) {
      curPara = theFlow.findAbsoluteParagraph(curEndPos);
      startPos = curEndPos;
    }
    else
      curPara = null;
  }
  return madeTCY;
};


/**
 * Creates one or more LinkElements out of the selected positions. It will go through
 * every paragraph within the selected position and make links.
 * @asparam theFlow The ITextFlow of interest.
 * @asparam startPos The index value of the first position of the ITextFlow to be turned into a link.
 * @asparam endPos The index value following the end position of the ITextFlow to be turned into a link.
 * @asparam urlString The url string to be associated with the link.
 * @export
 * @param {org.apache.royale.textLayout.elements.ITextFlow} theFlow
 * @param {number} startPos
 * @param {number} endPos
 * @param {string} urlString
 * @param {string} target
 * @return {boolean}
 */
org.apache.royale.textLayout.edit.TextFlowEdit.makeLink = function(theFlow, startPos, endPos, urlString, target) {
  var /** @type {boolean} */ madeLink = true;
  var /** @type {org.apache.royale.textLayout.elements.IParagraphElement} */ curPara = theFlow.findAbsoluteParagraph(startPos);
  if (!curPara)
    return false;
  while (curPara) {
    var /** @type {number} */ paraEnd = (curPara.getAbsoluteStart() + curPara.textLength) >> 0;
    var /** @type {number} */ curEndPos = (Math.min(paraEnd, endPos)) >> 0;
    var /** @type {number} */ linkEndPos = ((curEndPos == paraEnd) ? (curEndPos - 1) : curEndPos) >> 0;
    if (linkEndPos > startPos) {
      if (!org.apache.royale.textLayout.edit.TextFlowEdit.canInsertSPBlock(theFlow, startPos, linkEndPos, "LinkElement")) {
        return false;
      }
      var /** @type {org.apache.royale.textLayout.elements.ILinkElement} */ newLinkElement = org.apache.royale.textLayout.elements.ElementHelper.getLink();
      newLinkElement.href = urlString;
      newLinkElement.target = target;
      madeLink = madeLink && org.apache.royale.textLayout.edit.TextFlowEdit.insertNewSPBlock(theFlow, startPos, linkEndPos, newLinkElement, "LinkElement");
    }
    if (paraEnd < endPos) {
      curPara = theFlow.findAbsoluteParagraph(curEndPos);
      startPos = curEndPos;
    }
    else
      curPara = null;
  }
  return madeLink;
};


/**
 * Removes the TCY block at the selected positions. 
 * @asparam theFlow The ITextFlow of interest.
 * @asparam startPos The index value of the first position of the ITextFlow.
 * @asparam endPos The index value following the end position of the ITextFlow.
 * @export
 * @param {org.apache.royale.textLayout.elements.ITextFlow} theFlow
 * @param {number} startPos
 * @param {number} endPos
 * @return {boolean}
 */
org.apache.royale.textLayout.edit.TextFlowEdit.removeTCY = function(theFlow, startPos, endPos) {
  if (endPos <= startPos) {
    return false;
  }
  return org.apache.royale.textLayout.edit.TextFlowEdit.findAndRemoveFlowGroupElement(theFlow, startPos, endPos, "TCYElement");
};


/**
 * Removes all LinkElements under the selected positions. It will go through
 * every paragraph within the selected position and remove any link.
 * @asparam theFlow The ITextFlow of interest.
 * @asparam startPos The index value of the first position of the ITextFlow.
 * @asparam endPos The index value following the end position of the ITextFlow.
 * @export
 * @param {org.apache.royale.textLayout.elements.ITextFlow} theFlow
 * @param {number} startPos
 * @param {number} endPos
 * @return {boolean}
 */
org.apache.royale.textLayout.edit.TextFlowEdit.removeLink = function(theFlow, startPos, endPos) {
  if (endPos <= startPos) {
    return false;
  }
  return org.apache.royale.textLayout.edit.TextFlowEdit.findAndRemoveFlowGroupElement(theFlow, startPos, endPos, "LinkElement");
};


/**
 * @asprivate
 * insertNewSPBlock - add a SubParagraphGroupElementBase (spg) to <code>theFlow</code> at the indicies specified by <code>startPos</code> and
 * <code>endPos</code>.  The <code>newSPB</code> will take ownership of any FlowElements within the range and will split them
 * as needed.  If the parent of the FlowGroupElement indicated by <code>startPos</code> is the same as <code>spgClass</code> then
 * the method fails and returns false because a spg cannot own children of the same class as itself.  Any spg of type <code>spgClass</code>
 * found within the indicies, however, is subsumed into <code>newSPB</code>, effectively replacing it.
 *
 * @asparam theFlow:ITextFlow - The ITextFlow that is the destination for the newSPB
 * @asparam startPos:int - The absolute index value of the first position of the range in the ITextFlow to perform the insertion.
 * @asparam endPos:int - The index value following the end position of the range in the ITextFlow to perform the insertion.
 * @asparam newSPB:SubParagraphGroupElementBase - The new SubParagraphElement which is to be added into theFlow.
 * @asparam spgClass:Class - the class of the fbe we intend to add.
 * 
 * Examples: Simple and complex where insertion is of <code>spgClass</code> b.  Selection is l~o
 *		1) <a><span>ghijklmnop</span></a>
 * 		2) <a><span>ghij</span><b><span>klm</span></b><span>nop</span></a>
 * 		3) <a><span>ghijk</span><c><span>lmn</span></c><span>op</span></a>
 * 
 * @export
 * @param {org.apache.royale.textLayout.elements.ITextFlow} theFlow
 * @param {number} startPos
 * @param {number} endPos
 * @param {org.apache.royale.textLayout.elements.ISubParagraphGroupElementBase} newSPB
 * @param {string} spgClass
 * @return {boolean}
 */
org.apache.royale.textLayout.edit.TextFlowEdit.insertNewSPBlock = function(theFlow, startPos, endPos, newSPB, spgClass) {
  var /** @type {number} */ curPos = startPos;
  var /** @type {org.apache.royale.textLayout.elements.IFlowGroupElement} */ curFBE = theFlow.findAbsoluteFlowGroupElement(curPos);
  var /** @type {number} */ elementIdx = 0;
  
  var /** @type {org.apache.royale.textLayout.elements.IParagraphElement} */ paraEl = curFBE.getParagraph();
  if (endPos == (paraEl.getAbsoluteStart() + paraEl.textLength - 1))
    ++endPos;
  var /** @type {number} */ parentStart = curFBE.parent.getAbsoluteStart();
  var /** @type {number} */ curFBEStart = curFBE.getAbsoluteStart();
  if (curFBE.parent && curFBE.parent.className == spgClass && !(parentStart == curFBEStart && parentStart + curFBE.parent.textLength == curFBEStart + curFBE.textLength)) {
    return false;
  }
  if (!org.apache.royale.utils.Language.is(curFBE, org.apache.royale.textLayout.elements.IParagraphElement) && curPos == curFBEStart && curPos + curFBE.textLength <= endPos) {
    elementIdx = curFBE.parent.getChildIndex(curFBE);
    curFBE = curFBE.parent;
  }
  if (curPos >= curFBEStart) {
    if (!(curFBE.className == spgClass))
      elementIdx = org.apache.royale.textLayout.edit.TextFlowEdit.findAndSplitElement(curFBE, elementIdx, curPos, true); else {
      elementIdx = org.apache.royale.textLayout.edit.TextFlowEdit.findAndSplitElement(curFBE.parent, curFBE.parent.getChildIndex(curFBE), curPos, false);
      curFBE = curFBE.parent;
    }
  }
  if (curFBE && curFBE.className == spgClass) {
    curFBEStart = curFBE.getAbsoluteStart();
    elementIdx = curFBE.parent.getChildIndex(curFBE);
    if (curPos > curFBEStart)
      elementIdx += 1;
    while (endPos >= curFBEStart + curFBE.textLength) {
      curFBE = curFBE.parent;
    }
    curFBE.replaceChildren(elementIdx, elementIdx, newSPB);
  } else {
    curFBE.replaceChildren(elementIdx, elementIdx, newSPB);
  }
  org.apache.royale.textLayout.edit.TextFlowEdit.subsumeElementsToSPBlock(curFBE, (elementIdx + 1) >> 0, curPos, endPos, newSPB, spgClass);
  return true;
};


/**
 * @asprivate
 * splitElement - split <code>elem</code> at the relative index of <code>splitPos</code>.  If <code>splitSubBlockContents</code>
 * is true, split the contents of <code>elem</code> if it is a ISubParagraphGroupElementBase, otherwise just split <code>elem</code>
 * 
 * @asparam elem:FlowElement - the FlowElement to split
 * @asparam splitPos:int - The elem relative index indicating where to split
 * @asparam splitSubBlockContents:Boolean - boolean indicating whether a ISubParagraphGroupElementBase is to be split OR that it's contents
 * should be split.  For example, are we splitting a link or are we splitting the child of the link
 * 
 * <spg><span>ABCDEF</span></spg>
 * 
 * if <code>splitPos</code> indicated index between C and D, then if <code>splitSubBlockContents</code> equals true,
 * result is:
 * 
 * <spg><span>ABC</span><span>DEF</span></spg>
 * 
 * if <code>splitSubBlockContents</code> equals false, result is:
 * 
 * <spg><span>ABC</span></spg><spg><span>DEF</span></spg>
 * @royaleignorecoercion org.apache.royale.textLayout.elements.ISpanElement
 * @export
 * @param {org.apache.royale.textLayout.elements.IFlowElement} elem
 * @param {number} splitPos
 * @param {boolean} splitSubBlockContents
 */
org.apache.royale.textLayout.edit.TextFlowEdit.splitElement = function(elem, splitPos, splitSubBlockContents) {
  
  if (org.apache.royale.utils.Language.is(elem, org.apache.royale.textLayout.elements.ISpanElement)) {
    elem.splitAtPosition(splitPos);
  } else if (org.apache.royale.utils.Language.is(elem, org.apache.royale.textLayout.elements.ISubParagraphGroupElementBase) && splitSubBlockContents) {
    var /** @type {org.apache.royale.textLayout.elements.ISubParagraphGroupElementBase} */ subBlock = org.apache.royale.utils.Language.as(elem, org.apache.royale.textLayout.elements.ISubParagraphGroupElementBase, true);
    var /** @type {Object} */ tempElem = subBlock.findLeaf(splitPos);
    if (tempElem)
      tempElem.splitAtPosition((splitPos - tempElem.getElementRelativeStart(subBlock)) >> 0);
  } else if (org.apache.royale.utils.Language.is(elem, org.apache.royale.textLayout.elements.IFlowGroupElement)) {
    org.apache.royale.utils.Language.as(elem, org.apache.royale.textLayout.elements.IFlowGroupElement, true).splitAtPosition(splitPos);
  } else {
    
  }
};


/**
 * @asprivate
 * findAndSplitElement - starting at the child <code>elementIdx</code> of <code>fbe</code>, iterate
 * through the elements until we find the one located at the aboslute index of <code>startIdx</code>. Upon
 * locating the child, split either the element itself OR its children based on the value of <code>splitSubBlockContents</code>
 * 
 * @asparam fbe:FlowGroupElement - the FBE into which the newSPB is being inserted.
 * @asparam elementIdx:int - The index into the <code>fbe's</code> child list to start
 * @asparam startIdx:int - The absolute index value into the ITextFlow.
 * @asparam splitSubBlockContents:Boolean - boolean indicating whether a subElement is to be split OR that it's contents
 * should be split.  For example, are we splitting a link or are we splitting the child of the link
 * 
 * <p>ZYX<link>ABCDEF</link>123</p>
 * 
 * if we are inserting a TCY into the link, splitSubBlockContents should be false. We want to split the span ABCDEF such that result is:
 * <p>ZYX<link>AB<tcy>CD</tcy>EF</link>123</p>
 * 
 * if we are creating a new link from X to B, then we want the link to split and splitSubBlockContents should be false:
 * 
 * <p>ZY<link>XAB</link><link>CDEF</link>123</p>
 * 
 * @asreturn int - the index of the last child of <code>fbe</code> processed.
 * @export
 * @param {org.apache.royale.textLayout.elements.IFlowGroupElement} fbe
 * @param {number} elementIdx
 * @param {number} startIdx
 * @param {boolean} splitSubBlockContents
 * @return {number}
 */
org.apache.royale.textLayout.edit.TextFlowEdit.findAndSplitElement = function(fbe, elementIdx, startIdx, splitSubBlockContents) {
  var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ curFlowEl = null;
  var /** @type {number} */ curIndexInPar = (startIdx - fbe.getAbsoluteStart()) >> 0;
  while (elementIdx < fbe.numChildren) {
    curFlowEl = fbe.getChildAt(elementIdx);
    if (curIndexInPar == curFlowEl.parentRelativeStart)
      return elementIdx;
    if ((curIndexInPar > curFlowEl.parentRelativeStart) && (curIndexInPar < curFlowEl.parentRelativeEnd)) {
      org.apache.royale.textLayout.edit.TextFlowEdit.splitElement(curFlowEl, (curIndexInPar - curFlowEl.parentRelativeStart) >> 0, splitSubBlockContents);
    }
    ++elementIdx;
  }
  return elementIdx;
};


/**
 * @asprivate
 * subsumeElementsToSPBlock - incorporates all elements of <code>parentFBE</code> into
 * the <code>newSPB</code> between the <code>curPos</code> and <code>endPos</code>.  If a child of
 * <code>parentFBE</code> is of type <code>spgClass</code> then the child's contents are removed from the child,
 * added to the <code>newSPB</code>, the child is then removed from the <code>parentFBE</code>
 * 
 * @asparam parentFBE:FlowGroupElement - the FBE into which the newSPB is being inserted.
 * @asparam startPos:int - The index value of the first position of the replacement range in the ITextFlow.
 * @asparam endPos:int - The index value following the end position of the replacement range in the ITextFlow.
 * @asparam newSPB:ISubParagraphGroupElementBase - the new ISubParagraphGroupElementBase we intend to insert.
 * @asparam spgClass:Class - the class of the fbe we intend to insert.
 * 
 * @asreturn int - the aboslute index in the text flow after insertion.
 * 
 *  Examples: Simple and complex where insertion is of <code>spgClass</class> b.  Selection is l~o
 *		1) <a><span>ghijk</span><b></b><span>lmnop</span></a>
 *		2) <a><span>ghij</span><b><span>k</span></b><b></b><b><span>lm</span></b><span>nop</span></a>
 * 
 * 	parentFBE = <a>
 *  elementIdx = 1) 2, 2) 3
 *  curPos = 5
 *  endPos = 9
 *  newSPB is of type <b>
 * @export
 * @param {org.apache.royale.textLayout.elements.IFlowGroupElement} parentFBE
 * @param {number} elementIdx
 * @param {number} curPos
 * @param {number} endPos
 * @param {org.apache.royale.textLayout.elements.ISubParagraphGroupElementBase} newSPB
 * @param {string} spgClass
 * @return {number}
 */
org.apache.royale.textLayout.edit.TextFlowEdit.subsumeElementsToSPBlock = function(parentFBE, elementIdx, curPos, endPos, newSPB, spgClass) {
  var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ curFlowEl = null;
  if (elementIdx >= parentFBE.numChildren)
    return curPos;
  while (curPos < endPos) {
    curFlowEl = parentFBE.getChildAt(elementIdx);
    if ((curPos + curFlowEl.textLength) > endPos) {
      org.apache.royale.textLayout.edit.TextFlowEdit.splitElement(curFlowEl, (endPos - curFlowEl.getAbsoluteStart()) >> 0, !(curFlowEl.className == spgClass));
    }
    curPos += curFlowEl.textLength;
    parentFBE.replaceChildren(elementIdx, (elementIdx + 1) >> 0);
    if (curFlowEl && curFlowEl.className == spgClass) {
      var /** @type {org.apache.royale.textLayout.elements.ISubParagraphGroupElementBase} */ subBlock = curFlowEl;
      while (subBlock.numChildren > 0) {
        var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ fe = subBlock.getChildAt(0);
        subBlock.replaceChildren(0, 1);
        newSPB.replaceChildren(newSPB.numChildren, newSPB.numChildren, fe);
      }
    } else {
      if (org.apache.royale.utils.Language.is(curFlowEl, org.apache.royale.textLayout.elements.ISubParagraphGroupElementBase)) {
        org.apache.royale.textLayout.edit.TextFlowEdit.flushSPBlock(curFlowEl, spgClass);
      }
      newSPB.replaceChildren(newSPB.numChildren, newSPB.numChildren, curFlowEl);
      if (newSPB.numChildren == 1 && org.apache.royale.utils.Language.is(curFlowEl, org.apache.royale.textLayout.elements.ISubParagraphGroupElementBase)) {
        var /** @type {org.apache.royale.textLayout.elements.ISubParagraphGroupElementBase} */ childSPGE = curFlowEl;
        if (childSPGE.textLength == newSPB.textLength && (curPos >= endPos)) {
          
          if (childSPGE.precedence > newSPB.precedence) {
            newSPB.replaceChildren(0, 1);
            while (childSPGE.numChildren > 0) {
              var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ tempFE = childSPGE.getChildAt(0);
              childSPGE.replaceChildren(0, 1);
              newSPB.replaceChildren(newSPB.numChildren, newSPB.numChildren, tempFE);
            }
            var /** @type {number} */ myIdx = newSPB.parent.getChildIndex(newSPB);
            
            newSPB.parent.replaceChildren(myIdx, (myIdx + 1) >> 0, childSPGE);
            childSPGE.replaceChildren(0, 0, newSPB);
          }
        }
      }
    }
  }
  return curPos;
};


/**
 * @asprivate
 * findAndRemoveFlowGroupElement 
 *
 * @asparam theFlow The ITextFlow that is containing the elements to remove.
 * @asparam startPos The index value of the first position of the range in the ITextFlow where we want to perform removal.
 * @asparam endPos The index value following the end position of the range in the ITextFlow where we want to perform removal.
 * @asparam fbeClass Class the class of the fbe we intend to remove.
 * 
 * Walks through the elements of <code>theFlow</code> looking for any FlowGroupElement of type <code>fbeClass</class>
 * On finding one, it removes the FBE's contents and adds them back into the FBE's parent.  If the class of object is
 * embedded within another spg and this removal would break the parent spg, then the method does nothing.
 * 
 * Example:
 * 	<link>ABC<tcy>DEF</tcy>GHI</link>
 * 	Selection is on E and removal of link is attempted.
 * 	Because E is a child of a spg (tcy), and removing the link from E would split the parent spg (link),
 *  the action is disallowed.
 * 
 * Running example:
 * 	1) <link><tcy><span>foo</span></tcy><span>bar</span></link>
 * @asreturn Boolean - true if items are removed or none are found.  false if operation is illegal.
 * @export
 * @param {org.apache.royale.textLayout.elements.ITextFlow} theFlow
 * @param {number} startPos
 * @param {number} endPos
 * @param {string} fbeClass
 * @return {boolean}
 */
org.apache.royale.textLayout.edit.TextFlowEdit.findAndRemoveFlowGroupElement = function(theFlow, startPos, endPos, fbeClass) {
  var /** @type {number} */ curPos = startPos;
  var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ curEl;
  while (curPos < endPos) {
    var /** @type {org.apache.royale.textLayout.elements.IFlowGroupElement} */ containerFBE = theFlow.findAbsoluteFlowGroupElement(curPos);
    while (containerFBE.parent && containerFBE.parent.getAbsoluteStart() == containerFBE.getAbsoluteStart() && !org.apache.royale.utils.Language.is(containerFBE.parent, org.apache.royale.textLayout.elements.IParagraphElement) && !org.apache.royale.utils.Language.is(containerFBE, org.apache.royale.textLayout.elements.IParagraphElement)) {
      containerFBE = containerFBE.parent;
    }
    if (containerFBE && containerFBE.className == fbeClass)
      containerFBE = containerFBE.parent;
    var /** @type {org.apache.royale.textLayout.elements.IFlowGroupElement} */ ancestorOfFBE = containerFBE.parent;
    while (ancestorOfFBE != null && !(ancestorOfFBE.className == fbeClass)) {
      if (ancestorOfFBE.parent && ancestorOfFBE.parent.className == fbeClass) {
        return false;
      }
      ancestorOfFBE = ancestorOfFBE.parent;
    }
    var /** @type {number} */ containerFBEStart = containerFBE.getAbsoluteStart();
    if (ancestorOfFBE && ancestorOfFBE.className == fbeClass && (containerFBEStart >= curPos && containerFBEStart + containerFBE.textLength <= endPos))
      containerFBE = ancestorOfFBE.parent;
    var /** @type {number} */ childIdx = containerFBE.findChildIndexAtPosition((curPos - containerFBEStart) >> 0);
    curEl = containerFBE.getChildAt(childIdx);
    if (curEl && curEl.className == fbeClass) {
      
      var /** @type {org.apache.royale.textLayout.elements.IFlowGroupElement} */ curFBE = curEl;
      var /** @type {org.apache.royale.textLayout.elements.IFlowGroupElement} */ parentBlock = curFBE.parent;
      var /** @type {number} */ idxInParent = parentBlock.getChildIndex(curFBE);
      if (curPos > curFBE.getAbsoluteStart()) {
        org.apache.royale.textLayout.edit.TextFlowEdit.splitElement(curFBE, (curPos - curFBE.getAbsoluteStart()) >> 0, false);
        curPos = (curFBE.getAbsoluteStart() + curFBE.textLength) >> 0;
        continue;
      }
      if (curFBE.getAbsoluteStart() + curFBE.textLength > endPos) {
        org.apache.royale.textLayout.edit.TextFlowEdit.splitElement(curFBE, (endPos - curFBE.getAbsoluteStart()) >> 0, false);
      }
      curPos = (curFBE.getAbsoluteStart() + curFBE.textLength) >> 0;
      while (curFBE.numChildren > 0) {
        var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ childFE = curFBE.getChildAt(0);
        curFBE.replaceChildren(0, 1);
        parentBlock.replaceChildren(idxInParent, idxInParent, childFE);
        idxInParent++;
      }
      parentBlock.replaceChildren(idxInParent, (idxInParent + 1) >> 0);
    } else if (org.apache.royale.utils.Language.is(curEl, org.apache.royale.textLayout.elements.ISubParagraphGroupElementBase)) {
      var /** @type {org.apache.royale.textLayout.elements.ISubParagraphGroupElementBase} */ curSPB = org.apache.royale.utils.Language.as(curEl, org.apache.royale.textLayout.elements.ISubParagraphGroupElementBase, true);
      if (curSPB.numChildren == 1)
        curPos = (curSPB.getAbsoluteStart() + curSPB.textLength) >> 0; else {
        curEl = curSPB.getChildAt(curSPB.findChildIndexAtPosition((curPos - curSPB.getAbsoluteStart()) >> 0));
        curPos = (curEl.getAbsoluteStart() + curEl.textLength) >> 0;
      }
    } else {
      curPos = (curEl.getAbsoluteStart() + curEl.textLength) >> 0;
    }
  }
  return true;
};


/**
 * @asprivate
 * canInsertSPBlock 
 * 
 * validate that we a valid selection to allow for insertion of a subBlock.  The rules are as
 * follows:
 * 	endPos > start
 * 	the new block will not span multiple paragraphs
 *  if the block is going into a SubParagraphGroupElementBase, it must not split the block:
 * 		example:  Text 		- ABCDEFG with a link on CDE
 * 		legal new Block		- D, CD, CDE, [n-chars]CDE[n1-chars]
 * 		illegal new Block 	- [1 + n-chars]C[D], [D]E[1 + n-chars]
 * 			exception - if the newBlock is the same class as the one we are trying to split
 * 			then we can truncate the original and add its contents to the new one, or extend it
 * 			as appropriate
 * 
 * @asparam theFlow The ITextFlow that is containing the elements to validate.
 * @asparam startPos The index value of the first position of the range in the ITextFlow to test.
 * @asparam endPos The index value following the end position of the range in the ITextFlow to test.
 * @asparam blockClass Class the class of the fbe we intend to insert.
 * @royaleignorecoercion org.apache.royale.textLayout.elements.IFlowGroupElement
 * @export
 * @param {org.apache.royale.textLayout.elements.ITextFlow} theFlow
 * @param {number} startPos
 * @param {number} endPos
 * @param {string} blockClass
 * @return {boolean}
 */
org.apache.royale.textLayout.edit.TextFlowEdit.canInsertSPBlock = function(theFlow, startPos, endPos, blockClass) {
  if (endPos <= startPos)
    return false;
  var /** @type {Object} */ anchorFBE = theFlow.findAbsoluteFlowGroupElement(startPos);
  if (anchorFBE.getParentByType(blockClass))
    anchorFBE = anchorFBE.getParentByType(blockClass);
  var /** @type {Object} */ tailFBE = theFlow.findAbsoluteFlowGroupElement((endPos - 1) >> 0);
  if (tailFBE.getParentByType(blockClass))
    tailFBE = tailFBE.getParentByType(blockClass);
  if (anchorFBE == tailFBE)
    return true;
  else if (anchorFBE.getParagraph() != tailFBE.getParagraph())
    return false;
  else if (anchorFBE.className == blockClass && tailFBE.className == blockClass)
    return true; else if (anchorFBE.className == "SubParagraphGroupElementBase" && !(anchorFBE.className == blockClass)) {
    var /** @type {number} */ anchorStart = anchorFBE.getAbsoluteStart();
    if (startPos > anchorStart && endPos > anchorStart + anchorFBE.textLength)
      return false;
  } else if ((org.apache.royale.utils.Language.is(anchorFBE.parent, org.apache.royale.textLayout.elements.ISubParagraphGroupElementBase) || org.apache.royale.utils.Language.is(tailFBE.parent, org.apache.royale.textLayout.elements.ISubParagraphGroupElementBase)) && anchorFBE.parent != tailFBE.parent) {
    return false;
  }
  if (org.apache.royale.utils.Language.is(tailFBE, org.apache.royale.textLayout.elements.ISubParagraphGroupElementBase) && !(tailFBE.className == blockClass) && endPos > tailFBE.getAbsoluteStart()) {
    var /** @type {number} */ tailStart = tailFBE.getAbsoluteStart();
    if (startPos < tailStart && endPos < tailStart + tailFBE.textLength)
      return false;
  }
  return true;
};


/**
 * @asprivate flushSPBlock recursively walk a spg looking for elements of type spgClass.  On finding one,
 * remove it's children and then remove the object itself.  Since spg's cannot hold children of the same type
 * as themselves, recursion is only needed for spg's of a class other than that of spgClass.
 * 
 * example: subPB = <b>bar<a>other</a><b> extending an <a> element to include all of "other"
 * @royaleignorecoercion org.apache.royale.textLayout.elements.IFlowGroupElement
 * @export
 * @param {org.apache.royale.textLayout.elements.ISubParagraphGroupElementBase} subPB
 * @param {string} spgClass
 */
org.apache.royale.textLayout.edit.TextFlowEdit.flushSPBlock = function(subPB, spgClass) {
  var /** @type {number} */ subParaIter = 0;
  while (subParaIter < subPB.numChildren) {
    var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ subFE = subPB.getChildAt(subParaIter);
    if (subFE && subFE.className == spgClass) {
      var /** @type {Object} */ subChildFBE = subFE;
      while (subChildFBE.numChildren > 0) {
        var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ subFEChild = subChildFBE.getChildAt(0);
        subChildFBE.replaceChildren(0, 1);
        subPB.replaceChildren(subParaIter, subParaIter, subFEChild);
      }
      ++subParaIter;
      subPB.replaceChildren(subParaIter, (subParaIter + 1) >> 0);
    } else if (org.apache.royale.utils.Language.is(subFE, org.apache.royale.textLayout.elements.ISubParagraphGroupElementBase)) {
      org.apache.royale.textLayout.edit.TextFlowEdit.flushSPBlock(subFE, spgClass);
      ++subParaIter;
    }
    else
      ++subParaIter;
  }
};


/** returns next paragraph in reading order after para. Used for merging paragraphs after delete.  
 * @export
 * @param {org.apache.royale.textLayout.elements.IParagraphElement} para
 * @return {org.apache.royale.textLayout.elements.IParagraphElement}
 */
org.apache.royale.textLayout.edit.TextFlowEdit.findNextParagraph = function(para) {
  if (para) {
    var /** @type {org.apache.royale.textLayout.elements.IFlowLeafElement} */ leaf = para.getLastLeaf();
    leaf = leaf.getNextLeaf();
    if (leaf)
      return leaf.getParagraph();
  }
  return null;
};


/** if parent is a singleton element, deletes it, then repeats deletion of singletons up the parent chain.  Used after paragraph merge. 
 * @export
 * @param {org.apache.royale.textLayout.elements.IFlowGroupElement} parent
 * @return {org.apache.royale.textLayout.edit.IMemento}
 */
org.apache.royale.textLayout.edit.TextFlowEdit.removeEmptyParentChain = function(parent) {
  if (org.apache.royale.utils.Language.is(parent, org.apache.royale.textLayout.elements.IParagraphElement))
    org.apache.royale.utils.Language.as(parent, org.apache.royale.textLayout.elements.IParagraphElement, true).removeEmptyTerminator();
  var /** @type {org.apache.royale.textLayout.edit.MementoList} */ mementoList = new org.apache.royale.textLayout.edit.MementoList(parent.getTextFlow());
  while (parent && (parent.numChildren == 0)) {
    var /** @type {org.apache.royale.textLayout.elements.IFlowGroupElement} */ grandParent = parent.parent;
    if (org.apache.royale.utils.Language.is(grandParent, org.apache.royale.textLayout.elements.IParagraphElement))
      org.apache.royale.utils.Language.as(grandParent, org.apache.royale.textLayout.elements.IParagraphElement, true).removeEmptyTerminator();
    if (grandParent) {
      var /** @type {number} */ parentIdx = grandParent.getChildIndex(parent);
      mementoList.push(org.apache.royale.textLayout.edit.ModelEdit.removeElements(grandParent.getTextFlow(), grandParent, parentIdx, 1));
    }
    parent = grandParent;
  }
  return mementoList;
};


/** Joins this paragraph's next sibling to this if it is a paragraph 
 * @export
 * @param {org.apache.royale.textLayout.elements.IParagraphElement} para
 * @param {boolean} inSameParent
 * @return {org.apache.royale.textLayout.edit.IMemento}
 */
org.apache.royale.textLayout.edit.TextFlowEdit.joinNextParagraph = function(para, inSameParent) {
  var /** @type {org.apache.royale.textLayout.elements.IParagraphElement} */ nextPara = org.apache.royale.textLayout.edit.TextFlowEdit.findNextParagraph(para);
  if (nextPara && (!inSameParent || para.parent == nextPara.parent))
    return org.apache.royale.textLayout.edit.TextFlowEdit.joinToElement(para, nextPara);
  return null;
};


/** Joins this paragraph's next sibling to this if it is a paragraph 
 * @export
 * @param {org.apache.royale.textLayout.elements.IParagraphElement} para
 * @param {boolean} inSameParent
 * @return {org.apache.royale.textLayout.edit.MementoList}
 */
org.apache.royale.textLayout.edit.TextFlowEdit.joinToNextParagraph = function(para, inSameParent) {
  var /** @type {org.apache.royale.textLayout.elements.IParagraphElement} */ sibParagraph = org.apache.royale.textLayout.edit.TextFlowEdit.findNextParagraph(para);
  if (sibParagraph && (!inSameParent || para.parent == sibParagraph.parent))
    return org.apache.royale.textLayout.edit.TextFlowEdit.joinToNextElement(para, sibParagraph);
  return null;
};


/** Joins this element2 to element1 -- all children of element2 added to end of element1 
 * @export
 * @param {org.apache.royale.textLayout.elements.IFlowGroupElement} element1
 * @param {org.apache.royale.textLayout.elements.IFlowGroupElement} element2
 * @return {org.apache.royale.textLayout.edit.IMemento}
 */
org.apache.royale.textLayout.edit.TextFlowEdit.joinToElement = function(element1, element2) {
  var /** @type {org.apache.royale.textLayout.edit.MementoList} */ list;
  if (element1 && element2) {
    return org.apache.royale.textLayout.edit.ModelEdit.joinElement(element2.getTextFlow(), element1, element2);
  }
  return list;
};


/** Joins this element1 to element2 -- all children of element1 added to front of element2 
 * @export
 * @param {org.apache.royale.textLayout.elements.IFlowGroupElement} element1
 * @param {org.apache.royale.textLayout.elements.IFlowGroupElement} element2
 * @return {org.apache.royale.textLayout.edit.MementoList}
 */
org.apache.royale.textLayout.edit.TextFlowEdit.joinToNextElement = function(element1, element2) {
  var /** @type {org.apache.royale.textLayout.edit.MementoList} */ list;
  if (element1 && element2) {
    list = new org.apache.royale.textLayout.edit.MementoList(element1.getTextFlow());
    var /** @type {Array} */ elementList = element1.mxmlChildren;
    list.push(org.apache.royale.textLayout.edit.ModelEdit.removeElements(element1.getTextFlow(), element1, 0, element1.numChildren));
    for (var /** @type {number} */ i = (elementList.length - 1) >> 0; i >= 0; --i) {
      list.push(org.apache.royale.textLayout.edit.ModelEdit.addElement(element2.getTextFlow(), elementList[i], element2, 0));
    }
    list.push(org.apache.royale.textLayout.edit.TextFlowEdit.removeEmptyParentChain(element1));
    return list;
  }
  return list;
};


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
org.apache.royale.textLayout.edit.TextFlowEdit.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'TextFlowEdit', qName: 'org.apache.royale.textLayout.edit.TextFlowEdit', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
org.apache.royale.textLayout.edit.TextFlowEdit.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    methods: function () {
      return {
        '|deleteRange': { type: 'org.apache.royale.textLayout.elements.IParagraphElement', declaredBy: 'org.apache.royale.textLayout.edit.TextFlowEdit', parameters: function () { return [ 'org.apache.royale.textLayout.elements.ITextFlow', false ,'int', false ,'int', false ]; }},
        '|insertTextScrap': { type: 'int', declaredBy: 'org.apache.royale.textLayout.edit.TextFlowEdit', parameters: function () { return [ 'org.apache.royale.textLayout.elements.ITextFlow', false ,'int', false ,'org.apache.royale.textLayout.edit.TextScrap', false ,'Boolean', false ]; }},
        '|makeTCY': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.edit.TextFlowEdit', parameters: function () { return [ 'org.apache.royale.textLayout.elements.ITextFlow', false ,'int', false ,'int', false ]; }},
        '|makeLink': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.edit.TextFlowEdit', parameters: function () { return [ 'org.apache.royale.textLayout.elements.ITextFlow', false ,'int', false ,'int', false ,'String', false ,'String', false ]; }},
        '|removeTCY': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.edit.TextFlowEdit', parameters: function () { return [ 'org.apache.royale.textLayout.elements.ITextFlow', false ,'int', false ,'int', false ]; }},
        '|removeLink': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.edit.TextFlowEdit', parameters: function () { return [ 'org.apache.royale.textLayout.elements.ITextFlow', false ,'int', false ,'int', false ]; }},
        '|insertNewSPBlock': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.edit.TextFlowEdit', parameters: function () { return [ 'org.apache.royale.textLayout.elements.ITextFlow', false ,'int', false ,'int', false ,'org.apache.royale.textLayout.elements.ISubParagraphGroupElementBase', false ,'String', false ]; }},
        '|splitElement': { type: 'void', declaredBy: 'org.apache.royale.textLayout.edit.TextFlowEdit', parameters: function () { return [ 'org.apache.royale.textLayout.elements.IFlowElement', false ,'int', false ,'Boolean', false ]; }},
        '|findAndSplitElement': { type: 'int', declaredBy: 'org.apache.royale.textLayout.edit.TextFlowEdit', parameters: function () { return [ 'org.apache.royale.textLayout.elements.IFlowGroupElement', false ,'int', false ,'int', false ,'Boolean', false ]; }},
        '|subsumeElementsToSPBlock': { type: 'int', declaredBy: 'org.apache.royale.textLayout.edit.TextFlowEdit', parameters: function () { return [ 'org.apache.royale.textLayout.elements.IFlowGroupElement', false ,'int', false ,'int', false ,'int', false ,'org.apache.royale.textLayout.elements.ISubParagraphGroupElementBase', false ,'String', false ]; }},
        '|findAndRemoveFlowGroupElement': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.edit.TextFlowEdit', parameters: function () { return [ 'org.apache.royale.textLayout.elements.ITextFlow', false ,'int', false ,'int', false ,'String', false ]; }},
        '|canInsertSPBlock': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.edit.TextFlowEdit', parameters: function () { return [ 'org.apache.royale.textLayout.elements.ITextFlow', false ,'int', false ,'int', false ,'String', false ]; }},
        '|flushSPBlock': { type: 'void', declaredBy: 'org.apache.royale.textLayout.edit.TextFlowEdit', parameters: function () { return [ 'org.apache.royale.textLayout.elements.ISubParagraphGroupElementBase', false ,'String', false ]; }},
        '|findNextParagraph': { type: 'org.apache.royale.textLayout.elements.IParagraphElement', declaredBy: 'org.apache.royale.textLayout.edit.TextFlowEdit', parameters: function () { return [ 'org.apache.royale.textLayout.elements.IParagraphElement', false ]; }},
        '|removeEmptyParentChain': { type: 'org.apache.royale.textLayout.edit.IMemento', declaredBy: 'org.apache.royale.textLayout.edit.TextFlowEdit', parameters: function () { return [ 'org.apache.royale.textLayout.elements.IFlowGroupElement', false ]; }},
        '|joinNextParagraph': { type: 'org.apache.royale.textLayout.edit.IMemento', declaredBy: 'org.apache.royale.textLayout.edit.TextFlowEdit', parameters: function () { return [ 'org.apache.royale.textLayout.elements.IParagraphElement', false ,'Boolean', false ]; }},
        '|joinToNextParagraph': { type: 'org.apache.royale.textLayout.edit.MementoList', declaredBy: 'org.apache.royale.textLayout.edit.TextFlowEdit', parameters: function () { return [ 'org.apache.royale.textLayout.elements.IParagraphElement', false ,'Boolean', false ]; }},
        '|joinToElement': { type: 'org.apache.royale.textLayout.edit.IMemento', declaredBy: 'org.apache.royale.textLayout.edit.TextFlowEdit', parameters: function () { return [ 'org.apache.royale.textLayout.elements.IFlowGroupElement', false ,'org.apache.royale.textLayout.elements.IFlowGroupElement', false ]; }},
        '|joinToNextElement': { type: 'org.apache.royale.textLayout.edit.MementoList', declaredBy: 'org.apache.royale.textLayout.edit.TextFlowEdit', parameters: function () { return [ 'org.apache.royale.textLayout.elements.IFlowGroupElement', false ,'org.apache.royale.textLayout.elements.IFlowGroupElement', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
org.apache.royale.textLayout.edit.TextFlowEdit.prototype.ROYALE_COMPILE_FLAGS = 10;

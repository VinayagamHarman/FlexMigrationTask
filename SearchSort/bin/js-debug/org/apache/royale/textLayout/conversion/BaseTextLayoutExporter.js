/**
 * Generated by Apache Royale Compiler from org/apache/royale/textLayout/conversion/BaseTextLayoutExporter.as
 * org.apache.royale.textLayout.conversion.BaseTextLayoutExporter
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('org.apache.royale.textLayout.conversion.BaseTextLayoutExporter');
/* Royale Dependency List: Namespace,XML,XMLList,org.apache.royale.reflection.getQualifiedClassName,org.apache.royale.textLayout.TextLayoutVersion,org.apache.royale.textLayout.conversion.ConversionConstants,org.apache.royale.textLayout.conversion.ConversionType,org.apache.royale.textLayout.conversion.FlowElementInfo,org.apache.royale.textLayout.conversion.ImportExportConfiguration,org.apache.royale.textLayout.elements.FlowGroupElement,org.apache.royale.textLayout.elements.IContainerFormattedElement,org.apache.royale.textLayout.elements.IFlowElement,org.apache.royale.textLayout.elements.IParagraphFormattedElement,org.apache.royale.textLayout.elements.ITextFlow,org.apache.royale.textLayout.elements.SpanElement,org.apache.royale.textLayout.elements.TableCellElement,org.apache.royale.textLayout.elements.TableElement,org.apache.royale.textLayout.elements.TableRowElement,org.apache.royale.utils.Language*/

goog.require('org.apache.royale.textLayout.conversion.ConverterBase');
goog.require('org.apache.royale.textLayout.conversion.ITextExporter');



/**
 * @constructor
 * @extends {org.apache.royale.textLayout.conversion.ConverterBase}
 * @implements {org.apache.royale.textLayout.conversion.ITextExporter}
 * @param {Namespace} ns
 * @param {XML} rootTag
 * @param {org.apache.royale.textLayout.conversion.ImportExportConfiguration} configuration
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter = function(ns, rootTag, configuration) {
  org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.base(this, 'constructor');
  this.config = configuration;
  this.org_apache_royale_textLayout_conversion_BaseTextLayoutExporter__ns = ns;
  this.org_apache_royale_textLayout_conversion_BaseTextLayoutExporter__rootTag = rootTag;
};
goog.inherits(org.apache.royale.textLayout.conversion.BaseTextLayoutExporter, org.apache.royale.textLayout.conversion.ConverterBase);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', org.apache.royale.textLayout.conversion.BaseTextLayoutExporter);


/**
 * @private
 * @type {XML}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.org_apache_royale_textLayout_conversion_BaseTextLayoutExporter__rootTag;


/**
 * @private
 * @type {Namespace}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.org_apache_royale_textLayout_conversion_BaseTextLayoutExporter__ns;


/** 
 * @copy ITextExporter#export()
 * @export
 * @param {org.apache.royale.textLayout.elements.ITextFlow} source
 * @param {string} conversionType
 * @return {Object}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.export = function(source, conversionType) {
  this.clear();
  var /** @type {XML} */ result = this.exportToXML(source);
  return conversionType == org.apache.royale.textLayout.conversion.ConversionType.STRING_TYPE ? org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.convertXMLToString(result) : result;
};


/** 
 * Export text content of a TextFlow into XFL format.
 * 
 * @asparam source	the text to export
 * @asreturn XML	the exported content
 * @protected
 * @param {org.apache.royale.textLayout.elements.ITextFlow} textFlow
 * @return {XML}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.exportToXML = function(textFlow) {
  var /** @type {XML} */ result;
  if (this.org_apache_royale_textLayout_conversion_BaseTextLayoutExporter__rootTag) {
    result = new XML(this.org_apache_royale_textLayout_conversion_BaseTextLayoutExporter__rootTag);
    result.addNamespace(this.org_apache_royale_textLayout_conversion_BaseTextLayoutExporter__ns);
    result.appendChild(this.exportChild(textFlow));
  } else {
    result = XML.conversion(org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.exportTextFlow(this, textFlow));
    result.addNamespace(this.org_apache_royale_textLayout_conversion_BaseTextLayoutExporter__ns);
  }
  return result;
};


/** 
 * Export text content as a string
 * 
 * @asparam xml	the XML to convert
 * @asreturn String	the exported content
 * @asprivate
 * @export
 * @param {XML} xml
 * @return {string}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.convertXMLToString = function(xml) {
  var /** @type {string} */ result;
  var /** @type {Object} */ originalSettings = XML.settings();
  try {
    XML.ignoreProcessingInstructions = false;
    XML.ignoreWhitespace = false;
    XML.prettyPrinting = false;
    result = xml.toXMLString();
    XML.setSettings(originalSettings);
  } catch (e) {
    XML.setSettings(originalSettings);
    throw e;
  }
  return result;
};


/** 
 * Base functionality for exporting a FlowElement.
 *  
 * @asparam exporter	Root object for the export
 * @asparam flowElement	Element to export
 * @asreturn XMLList	XML for the element
 * @export
 * @param {org.apache.royale.textLayout.conversion.BaseTextLayoutExporter} exporter
 * @param {org.apache.royale.textLayout.elements.IFlowElement} flowElement
 * @return {XMLList}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.exportFlowElement = function(exporter, flowElement) {
  return exporter.exportFlowElement(flowElement);
};


/** 
 * Overridable worker method for exporting a FlowElement. Creates the XMLList.
 * 
 * @asparam flowElement	Element to export
 * @asreturn XMLList	XML for the element
 * @protected
 * @param {org.apache.royale.textLayout.elements.IFlowElement} flowElement
 * @return {XMLList}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.exportFlowElement = function(flowElement) {
  var /** @type {string} */ className = org.apache.royale.reflection.getQualifiedClassName(flowElement);
  var /** @type {string} */ elementName = this.config.lookupName(className);
  var /** @type {XML} */ output = new XML( '<' + elementName + '/>');
  output.setNamespace(this.org_apache_royale_textLayout_conversion_BaseTextLayoutExporter__ns);
  return XMLList.conversion(output);
};


/**
 * @export
 * @param {XML} destination
 * @param {org.apache.royale.textLayout.elements.SpanElement} span
 * @param {RegExp} replacementRegex
 * @param {Function} replacementXMLCallback
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.exportSpanText = function(destination, span, replacementRegex, replacementXMLCallback) {
  var /** @type {string} */ spanText = span.text;
  var /** @type {Array} */ matchLocation = spanText.match(replacementRegex);
  if (matchLocation) {
    var /** @type {XML} */ dummy;
    while (matchLocation != null) {
      var /** @type {number} */ ix = (matchLocation.index) >> 0;
      var /** @type {string} */ tempStr = spanText.substr(0, ix);
      if (tempStr.length > 0) {
        dummy = new XML( '<dummy/>');
        dummy.appendChild(tempStr);
        destination.appendChild(dummy.text()[0]);
      }
      var /** @type {XML} */ replacementXML = replacementXMLCallback(spanText.charAt(ix));
      
      destination.appendChild(replacementXML);
      spanText = spanText.slice(ix + 1, spanText.length);
      matchLocation = spanText.match(replacementRegex);
      if (!matchLocation && spanText.length > 0) {
        dummy = new XML( '<dummy/>');
        dummy.appendChild(spanText);
        destination.appendChild(dummy.text()[0]);
      }
    }
  } else {
    destination.appendChild(spanText);
  }
};


/** 
 * Base functionality for exporting a Span. Exports as a FlowElement,
 * and exports the text of the span.
 * 
 * @asparam exporter	Root object for the export
 * @asparam span	Element to export
 * @asreturn XMLList	XML for the element
 * @export
 * @param {org.apache.royale.textLayout.conversion.BaseTextLayoutExporter} exporter
 * @param {org.apache.royale.textLayout.elements.SpanElement} span
 * @return {XMLList}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.exportSpan = function(exporter, span) {
  var /** @type {XMLList} */ output = org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.exportFlowElement(exporter, span);
  org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.exportSpanText(output[0], span, exporter.spanTextReplacementRegex, org.apache.royale.utils.Language.closure(exporter.getSpanTextReplacementXML, exporter, 'getSpanTextReplacementXML'));
  return output;
};


/**
 * @private
 * @const
 * @type {RegExp}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.brRegEx = /\u2028/;


/** 
 * Gets the xml element used to represent a character in the export format
 * @protected
 * @param {string} ch
 * @return {XML}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.getSpanTextReplacementXML = function(ch) {
  
  var /** @type {XML} */ breakXML = new XML( '<br/>');
  breakXML.setNamespace(this.flowNS);
  return breakXML;
};


/** 
 * Base functionality for exporting a FlowGroupElement. Exports as a FlowElement,
 * and exports the children of a element.
 * 
 * @asparam exporter	Root object for the export
 * @asparam flowBlockElement	Element to export
 * @asreturn XMLList	XML for the element
 * @export
 * @param {org.apache.royale.textLayout.conversion.BaseTextLayoutExporter} exporter
 * @param {org.apache.royale.textLayout.elements.FlowGroupElement} flowBlockElement
 * @return {XMLList}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.exportFlowGroupElement = function(exporter, flowBlockElement) {
  var /** @type {XMLList} */ output = org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.exportFlowElement(exporter, flowBlockElement);
  var /** @type {number} */ count = flowBlockElement.numChildren;
  for (var /** @type {number} */ index = 0; index < count; ++index) {
    var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ flowChild = flowBlockElement.getChildAt(index);
    var /** @type {XMLList} */ childXML = exporter.exportChild(flowChild);
    if (childXML) {
      output.appendChild(childXML);
    }
  }
  return output;
};


/** 
 * Base functionality for exporting a IParagraphFormattedElement. Exports as a FlowGroupElement,
 * and exports paragraph attributes.
 * 
 * @asparam exporter	Root object for the export
 * @asparam flowParagraph	Element to export
 * @asreturn XMLList	XML for the element
 * @export
 * @param {org.apache.royale.textLayout.conversion.BaseTextLayoutExporter} exporter
 * @param {org.apache.royale.textLayout.elements.IParagraphFormattedElement} flowParagraph
 * @return {XMLList}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.exportParagraphFormattedElement = function(exporter, flowParagraph) {
  return exporter.exportParagraphFormattedElement(flowParagraph);
};


/**
 * @export
 * @param {org.apache.royale.textLayout.conversion.BaseTextLayoutExporter} exporter
 * @param {org.apache.royale.textLayout.elements.IParagraphFormattedElement} flowParagraph
 * @return {XMLList}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.exportList = function(exporter, flowParagraph) {
  return exporter.exportList(flowParagraph);
};


/**
 * @protected
 * @param {org.apache.royale.textLayout.elements.IFlowElement} flowElement
 * @return {XMLList}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.exportList = function(flowElement) {
  var /** @type {XMLList} */ result = this.exportFlowElement(flowElement);
  var /** @type {number} */ count = org.apache.royale.utils.Language.as(flowElement, org.apache.royale.textLayout.elements.FlowGroupElement, true).numChildren;
  for (var /** @type {number} */ index = 0; index < count; ++index) {
    var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ flowChild = org.apache.royale.utils.Language.as(flowElement, org.apache.royale.textLayout.elements.FlowGroupElement, true).getChildAt(index);
    result.appendChild(this.exportChild(flowChild));
  }
  return result;
};


/**
 * @export
 * @param {org.apache.royale.textLayout.conversion.BaseTextLayoutExporter} exporter
 * @param {org.apache.royale.textLayout.elements.IParagraphFormattedElement} flowParagraph
 * @return {XMLList}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.exportListItem = function(exporter, flowParagraph) {
  return exporter.exportListItem(flowParagraph);
};


/**
 * @protected
 * @param {org.apache.royale.textLayout.elements.IFlowElement} flowElement
 * @return {XMLList}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.exportListItem = function(flowElement) {
  var /** @type {XMLList} */ result = this.exportFlowElement(flowElement);
  var /** @type {number} */ count = org.apache.royale.utils.Language.as(flowElement, org.apache.royale.textLayout.elements.FlowGroupElement, true).numChildren;
  for (var /** @type {number} */ index = 0; index < count; ++index) {
    var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ flowChild = org.apache.royale.utils.Language.as(flowElement, org.apache.royale.textLayout.elements.FlowGroupElement, true).getChildAt(index);
    result.appendChild(this.exportChild(flowChild));
  }
  return result;
};


/** 
 * Base functionality for exporting a IContainerFormattedElement. Exports as a IParagraphFormattedElement,
 * and exports container attributes.
 * 
 * @asparam exporter	Root object for the export
 * @asparam container	Element to export
 * @asreturn XMLList	XML for the element
 * @export
 * @param {org.apache.royale.textLayout.conversion.BaseTextLayoutExporter} exporter
 * @param {org.apache.royale.textLayout.elements.IContainerFormattedElement} container
 * @return {XMLList}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.exportContainerFormattedElement = function(exporter, container) {
  return exporter.exportContainerFormattedElement(container);
};


/** 
 * Overridable worker method for exporting a IParagraphFormattedElement. Creates the XMLList.
 * 
 * @asparam flowElement	Element to export
 * @asreturn XMLList	XML for the element
 * @protected
 * @param {org.apache.royale.textLayout.elements.IFlowElement} flowElement
 * @return {XMLList}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.exportContainerFormattedElement = function(flowElement) {
  return this.exportParagraphFormattedElement(flowElement);
};


/** 
 * Base functionality for exporting a TableElement. Exports as a TableElement,
 * and exports table attributes.
 * 
 * @asparam exporter	Root object for the export
 * @asparam container	Element to export
 * @asreturn XMLList	XML for the element
 * @export
 * @param {org.apache.royale.textLayout.conversion.BaseTextLayoutExporter} exporter
 * @param {org.apache.royale.textLayout.elements.TableElement} table
 * @return {XMLList}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.exportTableElement = function(exporter, table) {
  return exporter.exportTableElement(table);
};


/** 
 * Overridable worker method for exporting a TableElement. Creates the XMLList.
 * 
 * @asparam flowElement	Element to export
 * @asreturn XMLList	XML for the element
 * @protected
 * @param {org.apache.royale.textLayout.elements.TableElement} tableElement
 * @return {XMLList}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.exportTableElement = function(tableElement) {
  var /** @type {XMLList} */ result = this.exportFlowElement(tableElement);
  var /** @type {number} */ count = tableElement.numRows;
  for (var /** @type {number} */ index = 0; index < count; ++index) {
    var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ flowChild = tableElement.getRowAt(index);
    result.appendChild(this.exportChild(flowChild));
  }
  return result;
};


/** 
 * Base functionality for exporting a TableRowElement. Exports as a TableRowElement,
 * and exports table row attributes.
 * 
 * @asparam exporter	Root object for the export
 * @asparam container	Element to export
 * @asreturn XMLList	XML for the element
 * @export
 * @param {org.apache.royale.textLayout.conversion.BaseTextLayoutExporter} exporter
 * @param {org.apache.royale.textLayout.elements.TableRowElement} tableRow
 * @return {XMLList}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.exportTableRowElement = function(exporter, tableRow) {
  return exporter.exportTableRowElement(tableRow);
};


/** 
 * Overridable worker method for exporting a TableRowElement. Creates the XMLList.
 * 
 * @asparam flowElement	Element to export
 * @asreturn XMLList	XML for the element
 * @protected
 * @param {org.apache.royale.textLayout.elements.TableRowElement} tableRowElement
 * @return {XMLList}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.exportTableRowElement = function(tableRowElement) {
  var /** @type {XMLList} */ result = this.exportFlowElement(tableRowElement);
  var /** @type {number} */ count = tableRowElement.numCells;
  for (var /** @type {number} */ index = 0; index < count; ++index) {
    var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ flowChild = tableRowElement.getCellAt(index);
    result.appendChild(this.exportChild(flowChild));
  }
  return result;
};


/** 
 * Base functionality for exporting a TableCellElement. Exports as a TableCellElement,
 * and exports table cell attributes.
 * 
 * @asparam exporter	Root object for the export
 * @asparam container	Element to export
 * @asreturn XMLList	XML for the element
 * @export
 * @param {org.apache.royale.textLayout.conversion.BaseTextLayoutExporter} exporter
 * @param {org.apache.royale.textLayout.elements.TableCellElement} tableCell
 * @return {XMLList}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.exportTableCellElement = function(exporter, tableCell) {
  return exporter.exportTableCellElement(tableCell);
};


/** 
 * Overridable worker method for exporting a TableCellElement. Creates the XMLList.
 * 
 * @asparam flowElement	Element to export
 * @asreturn XMLList	XML for the element
 * @protected
 * @param {org.apache.royale.textLayout.elements.TableCellElement} tableCellElement
 * @return {XMLList}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.exportTableCellElement = function(tableCellElement) {
  var /** @type {XMLList} */ result = this.exportFlowElement(tableCellElement);
  return result;
};


/** 
 * Overridable worker method for exporting a IParagraphFormattedElement. Creates the XMLList.
 * 
 * @asparam flowElement	Element to export
 * @asreturn XMLList	XML for the element
 * @protected
 * @param {org.apache.royale.textLayout.elements.IFlowElement} flowElement
 * @return {XMLList}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.exportParagraphFormattedElement = function(flowElement) {
  var /** @type {XMLList} */ result = this.exportFlowElement(flowElement);
  var /** @type {number} */ count = org.apache.royale.utils.Language.as(flowElement, org.apache.royale.textLayout.elements.IParagraphFormattedElement, true).numChildren;
  for (var /** @type {number} */ index = 0; index < count; ++index) {
    var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ flowChild = org.apache.royale.utils.Language.as(flowElement, org.apache.royale.textLayout.elements.IParagraphFormattedElement, true).getChildAt(index);
    result.appendChild(this.exportChild(flowChild));
  }
  return result;
};


/** 
 * Base functionality for exporting a TextFlow. Exports as a ContainerElement,
 * and exports container attributes.
 * 
 * @asparam exporter	Root object for the export
 * @asparam textFlow	Element to export
 * @asreturn XMLList	XML for the element
 * @export
 * @param {org.apache.royale.textLayout.conversion.BaseTextLayoutExporter} exporter
 * @param {org.apache.royale.textLayout.elements.ITextFlow} textFlow
 * @return {XMLList}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.exportTextFlow = function(exporter, textFlow) {
  var /** @type {XMLList} */ output = org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.exportContainerFormattedElement(exporter, textFlow);
  output.setAttribute('version', org.apache.royale.textLayout.TextLayoutVersion.getVersionString(org.apache.royale.textLayout.TextLayoutVersion.CURRENT_VERSION));
  return output;
};


/** 
 * Exports the object. It will find the appropriate exporter and use it to 
 * export the object.
 * 
 * @asparam exporter	Root object for the export
 * @asparam flowElement	Element to export
 * @asreturn XMLList	XML for the flowElement
 * @export
 * @param {org.apache.royale.textLayout.elements.IFlowElement} flowElement
 * @return {XMLList}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.exportChild = function(flowElement) {
  var /** @type {string} */ className = org.apache.royale.reflection.getQualifiedClassName(flowElement);
  var /** @type {org.apache.royale.textLayout.conversion.FlowElementInfo} */ info = this.config.lookupByClass(className);
  if (info != null)
    return info.exporter(this, flowElement);
  return null;
};


/** 
 * Helper function to export styles (core or user) in the form of xml attributes or xml children.
 * 
 * @asparam xml object to which attributes/children are added 
 * @asparam sortableStyles an array of objects (xmlName,xmlVal) members that is sorted and exported.
 * @protected
 * @param {XMLList} xml
 * @param {Array} sortableStyles
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.exportStyles = function(xml, sortableStyles) {
  org.apache.royale.utils.Language.sortOn(sortableStyles, "xmlName");
  var foreachiter0_target = sortableStyles;
  for (var foreachiter0 in foreachiter0_target) 
  {
  var exportInfo = foreachiter0_target[foreachiter0];
  {
    var /** @type {Object} */ xmlVal = exportInfo.xmlVal;
    
    if (!this.useClipboardAnnotations && exportInfo.xmlName == org.apache.royale.textLayout.conversion.ConversionConstants.MERGE_TO_NEXT_ON_PASTE)
      continue;
    xml.appendChild(xmlVal);
  }}
  
};


org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.get__spanTextReplacementRegex = function() {
  return org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.brRegEx;
};


org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.get__flowNS = function() {
  return this.org_apache_royale_textLayout_conversion_BaseTextLayoutExporter__ns;
};


org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.get__formatDescription = function() {
  return null;
};


Object.defineProperties(org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype, /** @lends {org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype} */ {
/**
  * @type {RegExp} */
spanTextReplacementRegex: {
get: org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.get__spanTextReplacementRegex},
/**
  * @type {Namespace} */
flowNS: {
get: org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.get__flowNS},
/**
  * @type {Object} */
formatDescription: {
get: org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.get__formatDescription}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'BaseTextLayoutExporter', qName: 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', kind: 'class' }], interfaces: [org.apache.royale.textLayout.conversion.ITextExporter] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    methods: function () {
      return {
        'BaseTextLayoutExporter': { type: '', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', parameters: function () { return [ 'Namespace', false ,'XML', false ,'org.apache.royale.textLayout.conversion.ImportExportConfiguration', false ]; }},
        'export': { type: 'Object', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', parameters: function () { return [ 'org.apache.royale.textLayout.elements.ITextFlow', false ,'String', false ]; }},
        '|convertXMLToString': { type: 'String', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', parameters: function () { return [ 'XML', false ]; }},
        '|exportFlowElement': { type: 'XMLList', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', parameters: function () { return [ 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', false ,'org.apache.royale.textLayout.elements.IFlowElement', false ]; }},
        '|exportSpanText': { type: 'void', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', parameters: function () { return [ 'XML', false ,'org.apache.royale.textLayout.elements.SpanElement', false ,'RegExp', false ,'Function', false ]; }},
        '|exportSpan': { type: 'XMLList', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', parameters: function () { return [ 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', false ,'org.apache.royale.textLayout.elements.SpanElement', false ]; }},
        '|exportFlowGroupElement': { type: 'XMLList', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', parameters: function () { return [ 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', false ,'org.apache.royale.textLayout.elements.FlowGroupElement', false ]; }},
        '|exportParagraphFormattedElement': { type: 'XMLList', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', parameters: function () { return [ 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', false ,'org.apache.royale.textLayout.elements.IParagraphFormattedElement', false ]; }},
        '|exportList': { type: 'XMLList', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', parameters: function () { return [ 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', false ,'org.apache.royale.textLayout.elements.IParagraphFormattedElement', false ]; }},
        '|exportListItem': { type: 'XMLList', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', parameters: function () { return [ 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', false ,'org.apache.royale.textLayout.elements.IParagraphFormattedElement', false ]; }},
        '|exportContainerFormattedElement': { type: 'XMLList', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', parameters: function () { return [ 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', false ,'org.apache.royale.textLayout.elements.IContainerFormattedElement', false ]; }},
        '|exportTableElement': { type: 'XMLList', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', parameters: function () { return [ 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', false ,'org.apache.royale.textLayout.elements.TableElement', false ]; }},
        '|exportTableRowElement': { type: 'XMLList', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', parameters: function () { return [ 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', false ,'org.apache.royale.textLayout.elements.TableRowElement', false ]; }},
        '|exportTableCellElement': { type: 'XMLList', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', parameters: function () { return [ 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', false ,'org.apache.royale.textLayout.elements.TableCellElement', false ]; }},
        '|exportTextFlow': { type: 'XMLList', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', parameters: function () { return [ 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', false ,'org.apache.royale.textLayout.elements.ITextFlow', false ]; }},
        'exportChild': { type: 'XMLList', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutExporter', parameters: function () { return [ 'org.apache.royale.textLayout.elements.IFlowElement', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutExporter.prototype.ROYALE_COMPILE_FLAGS = 10;

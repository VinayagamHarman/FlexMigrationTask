/**
 * Generated by Apache Royale Compiler from org/apache/royale/textLayout/conversion/TextConverter.as
 * org.apache.royale.textLayout.conversion.TextConverter
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('org.apache.royale.textLayout.conversion.TextConverter');
/* Royale Dependency List: org.apache.royale.textLayout.conversion.FormatDescriptor,org.apache.royale.textLayout.conversion.ITextExporter,org.apache.royale.textLayout.conversion.ITextImporter,org.apache.royale.textLayout.conversion.PlainTextExporter,org.apache.royale.textLayout.conversion.PlainTextImporter,org.apache.royale.textLayout.conversion.TextFieldHtmlExporter,org.apache.royale.textLayout.conversion.TextFieldHtmlImporter,org.apache.royale.textLayout.conversion.TextLayoutExporter,org.apache.royale.textLayout.conversion.TextLayoutImporter,org.apache.royale.textLayout.elements.IConfiguration,org.apache.royale.textLayout.elements.ITextFlow,org.apache.royale.textLayout.elements.TextFlow,XML*/




/**
 * @constructor
 */
org.apache.royale.textLayout.conversion.TextConverter = function() {
};


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('org.apache.royale.textLayout.conversion.TextConverter', org.apache.royale.textLayout.conversion.TextConverter);


/**
 * @export
 * @nocollapse
 * @const
 * @type {string}
 */
org.apache.royale.textLayout.conversion.TextConverter.TEXT_FIELD_HTML_FORMAT = "textFieldHTMLFormat";


/**
 * @export
 * @nocollapse
 * @const
 * @type {string}
 */
org.apache.royale.textLayout.conversion.TextConverter.PLAIN_TEXT_FORMAT = "plainTextFormat";


/**
 * @export
 * @nocollapse
 * @const
 * @type {string}
 */
org.apache.royale.textLayout.conversion.TextConverter.TEXT_LAYOUT_FORMAT = "textLayoutFormat";


/**
 * @private
 * @type {Array}
 */
org.apache.royale.textLayout.conversion.TextConverter._descs = [];


/** @asprivate 
 * @export
 */
org.apache.royale.textLayout.conversion.TextConverter.setFormatsToDefault = function() {
  org.apache.royale.textLayout.conversion.TextConverter._descs = [];
  org.apache.royale.textLayout.conversion.TextConverter.addFormat(org.apache.royale.textLayout.conversion.TextConverter.TEXT_LAYOUT_FORMAT, org.apache.royale.textLayout.conversion.TextLayoutImporter, org.apache.royale.textLayout.conversion.TextLayoutExporter, org.apache.royale.textLayout.conversion.TextConverter.TEXT_LAYOUT_FORMAT, org.apache.royale.textLayout.conversion.TextConverter._descs);
  org.apache.royale.textLayout.conversion.TextConverter.addFormat(org.apache.royale.textLayout.conversion.TextConverter.TEXT_FIELD_HTML_FORMAT, org.apache.royale.textLayout.conversion.TextFieldHtmlImporter, org.apache.royale.textLayout.conversion.TextFieldHtmlExporter, null, org.apache.royale.textLayout.conversion.TextConverter._descs);
  org.apache.royale.textLayout.conversion.TextConverter.addFormat(org.apache.royale.textLayout.conversion.TextConverter.PLAIN_TEXT_FORMAT, org.apache.royale.textLayout.conversion.PlainTextImporter, org.apache.royale.textLayout.conversion.PlainTextExporter, "air:text", org.apache.royale.textLayout.conversion.TextConverter._descs);
};


/** 
 * Creates a TextFlow from source content in a specified format.
 * <p>Use one of the static constants supplied with this class, a MIME type,
 * to specify the <code>format</code> parameter, or use a user defined
 * value for user-registered importers:
 * <ul>
 * <li>TextConverter.TEXT_FIELD_HTML_FORMAT</li>
 * <li>TextConverter.PLAIN_TEXT_FORMAT</li>
 * <li>TextConverter.TEXT_LAYOUT_FORMAT</li>
 * </ul>
 * </p>
 * @asparam source	Source content
 * @asparam format	Format of source content
 * @asparam config    IConfiguration to use when creating new TextFlows
 * @asreturn TextFlow that was created from the source, or null on errors.
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0 
 * @see #TEXT_FIELD_HTML_FORMAT
 * @see #PLAIN_TEXT_FORMAT
 * @see #TEXT_LAYOUT_FORMAT
 * @export
 * @param {Object} source
 * @param {string} format
 * @param {org.apache.royale.textLayout.elements.IConfiguration=} config
 * @return {org.apache.royale.textLayout.elements.ITextFlow}
 */
org.apache.royale.textLayout.conversion.TextConverter.importToFlow = function(source, format, config) {
  config = typeof config !== 'undefined' ? config : null;
  var /** @type {org.apache.royale.textLayout.conversion.ITextImporter} */ parser = org.apache.royale.textLayout.conversion.TextConverter.getImporter(format, config);
  if (!parser)
    return null;
  parser.throwOnError = false;
  return parser.importToFlow(source);
};


/** 
 * Exports a TextFlow to a specified format. 
 * <p>Use one of the static constants supplied with this class, a MIME type,
 * or a user defined format for user defined exporters to specify 
 * the <code>format</code> parameter:
 * <ul>
 * <li>TextConverter.TEXT_FIELD_HTML_FORMAT</li>
 * <li>TextConverter.PLAIN_TEXT_FORMAT</li>
 * <li>TextConverter.TEXT_LAYOUT_FORMAT</li>
 * </ul>
 * </p>
 * <p>Specify the type of the exported data in the <code>conversionType</code> parameter 
 * with one of the static constants supplied by the ConversionType class, or a user defined
 * data type for user defined exporters:
 * <ul>
 * <li>ConversionType.STRING_TYPE</li>
 * <li>ConversionType.XML_TYPE</li>
 * </ul>
 * </p>
 * 
 * Returns a representation of the TextFlow in the specified format, or null on errors.
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0 
 * @asparam source	Source content
 * @asparam format	Output format
 * @asparam conversionType	Type of exported data
 * @asreturn Object	Exported form of the TextFlow, or null on errors
 * @see #TEXT_FIELD_HTML_FORMAT
 * @see #PLAIN_TEXT_FORMAT
 * @see #TEXT_LAYOUT_FORMAT
 * @see org.apache.royale.textLayout.conversion.ConversionType
 * @export
 * @param {org.apache.royale.textLayout.elements.TextFlow} source
 * @param {string} format
 * @param {string} conversionType
 * @return {Object}
 */
org.apache.royale.textLayout.conversion.TextConverter.export = function(source, format, conversionType) {
  var /** @type {org.apache.royale.textLayout.conversion.ITextExporter} */ exporter = org.apache.royale.textLayout.conversion.TextConverter.getExporter(format);
  if (!exporter)
    return null;
  exporter.throwOnError = false;
  return exporter.export(source, conversionType);
};


/** 
 * Creates and returns an import converter, which you can then use to import from a 
 * source string, an XML object, or any user defined data formats to a TextFlow. 
 * Use this method if you have many separate imports to perform, or if you want to 
 * handle errors during import. It is equivalent to calling 
 * <code>org.apache.royale.textLayout.conversion.TextConverter.importToFlow()</code>.
 * <p>Use one of the static constants supplied with this class
 * to specify the <code>format</code> parameter, a MIME type, or a user defined
 * data format.
 * <ul>
 * <li>TextConverter.TEXT_FIELD_HTML_FORMAT</li>
 * <li>TextConverter.PLAIN_TEXT_FORMAT</li>
 * <li>TextConverter.TEXT_LAYOUT_FORMAT</li>
 * </ul>
 * </p>
 * <p>If the format has been added multiple times, the first one found will be used.</p>
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0 
 * @asparam format	Format of source content. Use constants from 
 * 					org.apache.royale.textLayout.conversion.TextConverter.TEXT_LAYOUT_FORMAT, PLAIN_TEXT_FORMAT, TEXT_FIELD_HTML_FORMAT etc,
 * 					a MIME type, or a user defined format.
 * @asparam config    configuration to use during this import. null means take the current default.
 * 					You can also set the configuration via the <code>ITextImporter.configuration</code>
 * 					property.
 * @asreturn ITextImporter	Text importer that can import the source data
 * @see #TEXT_FIELD_HTML_FORMAT
 * @see #PLAIN_TEXT_FORMAT
 * @see #TEXT_LAYOUT_FORMAT
 * @export
 * @param {string} format
 * @param {org.apache.royale.textLayout.elements.IConfiguration=} config
 * @return {org.apache.royale.textLayout.conversion.ITextImporter}
 */
org.apache.royale.textLayout.conversion.TextConverter.getImporter = function(format, config) {
  config = typeof config !== 'undefined' ? config : null;
  var /** @type {org.apache.royale.textLayout.conversion.ITextImporter} */ importer = null;
  var /** @type {number} */ i = org.apache.royale.textLayout.conversion.TextConverter.findFormatIndex(format);
  if (i >= 0) {
    var /** @type {org.apache.royale.textLayout.conversion.FormatDescriptor} */ descriptor = org.apache.royale.textLayout.conversion.TextConverter["descArray"][i];
    if (descriptor && descriptor.importerClass) {
      importer = new descriptor.importerClass();
      importer.configuration = config;
    }
  }
  return importer;
};


/** 
 * Creates and returns an export converter, which you can then use to export from 
 * a TextFlow to a source string or XML object. Use this function if 
 * you have many separate exports to perform. It is equivalent to calling 
 * <code>org.apache.royale.textLayout.conversion.TextConverter.export()</code>.
 * <p>Use one of the static constants supplied with this class
 * to specify the <code>format</code> parameter:
 * <ul>
 * <li>TextConverter.TEXT_FIELD_HTML_FORMAT</li>
 * <li>TextConverter.PLAIN_TEXT_FORMAT</li>
 * <li>TextConverter.TEXT_LAYOUT_FORMAT</li>
 * </ul>
 * </p>
 * <p>If the format has been added multiple times, the first one found will be used.</p>
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0 
 * @asparam format	Target format for exported data
 * @asreturn ITextExporter	Text exporter that can export in the specified format
 * @see #TEXT_FIELD_HTML_FORMAT
 * @see #PLAIN_TEXT_FORMAT
 * @see #TEXT_LAYOUT_FORMAT
 * @export
 * @param {string} format
 * @return {org.apache.royale.textLayout.conversion.ITextExporter}
 */
org.apache.royale.textLayout.conversion.TextConverter.getExporter = function(format) {
  var /** @type {org.apache.royale.textLayout.conversion.ITextExporter} */ exporter = null;
  var /** @type {number} */ i = org.apache.royale.textLayout.conversion.TextConverter.findFormatIndex(format);
  if (i >= 0) {
    var /** @type {org.apache.royale.textLayout.conversion.FormatDescriptor} */ descriptor = org.apache.royale.textLayout.conversion.TextConverter["descArray"][i];
    if (descriptor && descriptor.exporterClass)
      exporter = new descriptor.exporterClass();
  }
  return exporter;
};


/**
 * Register a new format for import/export, at the specified location.
 * Location can be significant for clients that have multiple 
 * choices for which format to use, such as when importing from the external clipboard. 
 * Lower numbers indicate higher priority; these converters will be tried first.
 * The new format may support importing and/or exporting.
 * If the format has already been added, then it will be present in multiple locations. The 
 * first one found will be used.
 * 
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0 
 * @asparam importClass    The import converter class to register or null
 * @asparam exportClass    The export converter class to register or null
 * @asparam format         The format string tagging the converter classes
 * @asparam clipboardFormat	The string used as the clipboard format when converting to/from the clipboard. Make this null if the format doesn't support clipboard access.
 * @export
 * @param {number} index
 * @param {string} format
 * @param {Object} importerClass
 * @param {Object=} exporterClass
 * @param {string=} clipboardFormat
 * @param {Array=} arr
 */
org.apache.royale.textLayout.conversion.TextConverter.addFormatAt = function(index, format, importerClass, exporterClass, clipboardFormat, arr) {
  exporterClass = typeof exporterClass !== 'undefined' ? exporterClass : null;
  clipboardFormat = typeof clipboardFormat !== 'undefined' ? clipboardFormat : null;
  arr = typeof arr !== 'undefined' ? arr : null;
  var /** @type {org.apache.royale.textLayout.conversion.FormatDescriptor} */ descriptor = new org.apache.royale.textLayout.conversion.FormatDescriptor(format, importerClass, exporterClass, clipboardFormat);
  if (arr != null) {
    arr.splice(index, 0, descriptor);
  } else {
    org.apache.royale.textLayout.conversion.TextConverter["descArray"].splice(index, 0, descriptor);
  }
};


/**
 * Register a new format for import/export. The new format will be added at the end,
 * as the lowest priority. Location can be significant for clients that have multiple 
 * choices for which format to use, such as when importing from the external clipboard. 
 * The new format may support importing and/or exporting.
 * If the format has already been added, then it will be present in multiple locations. The 
 * first one found will be used.
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0 
 * @asparam importClass    The import converter class to register or null
 * @asparam exportClass    The export converter class to register or null
 * @asparam format         The format string tagging the converter classes. Formats can be any name, but must be unique. 
 * @asparam clipboardFormat	The string used as the clipboard format when converting to/from the clipboard. Make this null if the format doesn't support clipboard access.
 * @export
 * @param {string} format
 * @param {Object} importerClass
 * @param {Object} exporterClass
 * @param {string} clipboardFormat
 * @param {Array=} arr
 */
org.apache.royale.textLayout.conversion.TextConverter.addFormat = function(format, importerClass, exporterClass, clipboardFormat, arr) {
  arr = typeof arr !== 'undefined' ? arr : null;
  if (arr != null) {
    org.apache.royale.textLayout.conversion.TextConverter.addFormatAt((arr.length) >> 0, format, importerClass, exporterClass, clipboardFormat, arr);
  } else {
    org.apache.royale.textLayout.conversion.TextConverter.addFormatAt((org.apache.royale.textLayout.conversion.TextConverter["descArray"].length) >> 0, format, importerClass, exporterClass, clipboardFormat);
  }
};


/**
 * Remove the format at the index location. 
 *
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0 
 * @asparam index     The format to remove
 * @export
 * @param {number} index
 */
org.apache.royale.textLayout.conversion.TextConverter.removeFormatAt = function(index) {
  if (index >= 0 && index < org.apache.royale.textLayout.conversion.TextConverter["descArray"].length)
    org.apache.royale.textLayout.conversion.TextConverter["descArray"].splice(index, 1);
};


/**
 * @private
 * @param {string} format
 * @return {number}
 */
org.apache.royale.textLayout.conversion.TextConverter.findFormatIndex = function(format) {
  for (var /** @type {number} */ i = 0; i < org.apache.royale.textLayout.conversion.TextConverter["numFormats"]; i++) {
    if (org.apache.royale.textLayout.conversion.TextConverter["descArray"][i].format == format)
      return i;
  }
  return -1;
};


/**
 * Remove the format. 
 * If a format was added multiple times, only the first one found is removed.
 * 
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0 
 * @asparam format     The converter format string to remove
 * @export
 * @param {string} format
 */
org.apache.royale.textLayout.conversion.TextConverter.removeFormat = function(format) {
  org.apache.royale.textLayout.conversion.TextConverter.removeFormatAt(org.apache.royale.textLayout.conversion.TextConverter.findFormatIndex(format));
};


/** Returns the format name for the index'th format.
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0 
 * @export
 * @param {number} index
 * @return {string}
 */
org.apache.royale.textLayout.conversion.TextConverter.getFormatAt = function(index) {
  return org.apache.royale.utils.Language.string(org.apache.royale.textLayout.conversion.TextConverter["descArray"][index].format);
};


/** Returns the FormatDescriptor for the index'th format. 
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0 
 * @export
 * @param {number} index
 * @return {org.apache.royale.textLayout.conversion.FormatDescriptor}
 */
org.apache.royale.textLayout.conversion.TextConverter.getFormatDescriptorAt = function(index) {
  return org.apache.royale.textLayout.conversion.TextConverter["descArray"][index];
};


org.apache.royale.textLayout.conversion.TextConverter.get__descArray = function() {
  if (org.apache.royale.textLayout.conversion.TextConverter._descs.length == 0) {
    org.apache.royale.textLayout.conversion.TextConverter.setFormatsToDefault();
  }
  return org.apache.royale.textLayout.conversion.TextConverter._descs;
};


org.apache.royale.textLayout.conversion.TextConverter.get__numFormats = function() {
  return (org.apache.royale.textLayout.conversion.TextConverter["descArray"].length) >> 0;
};


Object.defineProperties(org.apache.royale.textLayout.conversion.TextConverter, /** @lends {org.apache.royale.textLayout.conversion.TextConverter} */ {
/**
  * @export
  * @type {Array} */
descArray: {
get: org.apache.royale.textLayout.conversion.TextConverter.get__descArray},
/**
  * @export
  * @type {number} */
numFormats: {
get: org.apache.royale.textLayout.conversion.TextConverter.get__numFormats}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
org.apache.royale.textLayout.conversion.TextConverter.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'TextConverter', qName: 'org.apache.royale.textLayout.conversion.TextConverter', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
org.apache.royale.textLayout.conversion.TextConverter.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    accessors: function () {
      return {
        '|descArray': { type: 'Array', access: 'readonly', declaredBy: 'org.apache.royale.textLayout.conversion.TextConverter'},
        '|numFormats': { type: 'int', access: 'readonly', declaredBy: 'org.apache.royale.textLayout.conversion.TextConverter'}
      };
    },
    methods: function () {
      return {
        '|setFormatsToDefault': { type: 'void', declaredBy: 'org.apache.royale.textLayout.conversion.TextConverter'},
        '|importToFlow': { type: 'org.apache.royale.textLayout.elements.ITextFlow', declaredBy: 'org.apache.royale.textLayout.conversion.TextConverter', parameters: function () { return [ 'Object', false ,'String', false ,'org.apache.royale.textLayout.elements.IConfiguration', true ]; }},
        '|export': { type: 'Object', declaredBy: 'org.apache.royale.textLayout.conversion.TextConverter', parameters: function () { return [ 'org.apache.royale.textLayout.elements.TextFlow', false ,'String', false ,'String', false ]; }},
        '|getImporter': { type: 'org.apache.royale.textLayout.conversion.ITextImporter', declaredBy: 'org.apache.royale.textLayout.conversion.TextConverter', parameters: function () { return [ 'String', false ,'org.apache.royale.textLayout.elements.IConfiguration', true ]; }},
        '|getExporter': { type: 'org.apache.royale.textLayout.conversion.ITextExporter', declaredBy: 'org.apache.royale.textLayout.conversion.TextConverter', parameters: function () { return [ 'String', false ]; }},
        '|addFormatAt': { type: 'void', declaredBy: 'org.apache.royale.textLayout.conversion.TextConverter', parameters: function () { return [ 'int', false ,'String', false ,'Class', false ,'Class', true ,'String', true ,'Array', true ]; }},
        '|addFormat': { type: 'void', declaredBy: 'org.apache.royale.textLayout.conversion.TextConverter', parameters: function () { return [ 'String', false ,'Class', false ,'Class', false ,'String', false ,'Array', true ]; }},
        '|removeFormatAt': { type: 'void', declaredBy: 'org.apache.royale.textLayout.conversion.TextConverter', parameters: function () { return [ 'int', false ]; }},
        '|removeFormat': { type: 'void', declaredBy: 'org.apache.royale.textLayout.conversion.TextConverter', parameters: function () { return [ 'String', false ]; }},
        '|getFormatAt': { type: 'String', declaredBy: 'org.apache.royale.textLayout.conversion.TextConverter', parameters: function () { return [ 'int', false ]; }},
        '|getFormatDescriptorAt': { type: 'org.apache.royale.textLayout.conversion.FormatDescriptor', declaredBy: 'org.apache.royale.textLayout.conversion.TextConverter', parameters: function () { return [ 'int', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
org.apache.royale.textLayout.conversion.TextConverter.prototype.ROYALE_COMPILE_FLAGS = 10;

/**
 * Generated by Apache Royale Compiler from org/apache/royale/textLayout/conversion/BaseTextLayoutImporter.as
 * org.apache.royale.textLayout.conversion.BaseTextLayoutImporter
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('org.apache.royale.textLayout.conversion.BaseTextLayoutImporter');
/* Royale Dependency List: Namespace,XML,XMLList,org.apache.royale.textLayout.TextLayoutVersion,org.apache.royale.textLayout.conversion.FlowElementInfo,org.apache.royale.textLayout.conversion.IFormatImporter,org.apache.royale.textLayout.conversion.ImportExportConfiguration,org.apache.royale.textLayout.conversion.TLFormatImporter,org.apache.royale.textLayout.elements.BreakElement,org.apache.royale.textLayout.elements.ElementHelper,org.apache.royale.textLayout.elements.FlowGroupElement,org.apache.royale.textLayout.elements.GlobalSettings,org.apache.royale.textLayout.elements.IConfiguration,org.apache.royale.textLayout.elements.IContainerFormattedElement,org.apache.royale.textLayout.elements.IFlowElement,org.apache.royale.textLayout.elements.IFlowGroupElement,org.apache.royale.textLayout.elements.IFlowLeafElement,org.apache.royale.textLayout.elements.IListElement,org.apache.royale.textLayout.elements.IListItemElement,org.apache.royale.textLayout.elements.IParagraphElement,org.apache.royale.textLayout.elements.IParagraphFormattedElement,org.apache.royale.textLayout.elements.ISpanElement,org.apache.royale.textLayout.elements.ITextFlow,org.apache.royale.textLayout.elements.SpanElement,org.apache.royale.textLayout.elements.TabElement,org.apache.royale.textLayout.elements.TableCellElement,org.apache.royale.textLayout.elements.TextFlow,org.apache.royale.textLayout.factory.TLFFactory,org.apache.royale.textLayout.property.Property,org.apache.royale.textLayout.property.PropertyUtil,org.apache.royale.utils.Language*/

goog.require('org.apache.royale.textLayout.conversion.ConverterBase');
goog.require('org.apache.royale.textLayout.conversion.ITextImporter');



/**
 * @constructor
 * @extends {org.apache.royale.textLayout.conversion.ConverterBase}
 * @implements {org.apache.royale.textLayout.conversion.ITextImporter}
 * @param {Namespace} nsValue
 * @param {org.apache.royale.textLayout.conversion.ImportExportConfiguration} config
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter = function(nsValue, config) {
  org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.base(this, 'constructor');
  this.org_apache_royale_textLayout_conversion_BaseTextLayoutImporter__ns = nsValue;
  this._config = config;
};
goog.inherits(org.apache.royale.textLayout.conversion.BaseTextLayoutImporter, org.apache.royale.textLayout.conversion.ConverterBase);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', org.apache.royale.textLayout.conversion.BaseTextLayoutImporter);


/**
 * @private
 * @type {Namespace}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.org_apache_royale_textLayout_conversion_BaseTextLayoutImporter__ns;


/**
 * @private
 * @type {Namespace}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.org_apache_royale_textLayout_conversion_BaseTextLayoutImporter__textFlowNamespace;


/**
 * @protected
 * @type {org.apache.royale.textLayout.conversion.ImportExportConfiguration}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype._config;


/**
 * @protected
 * @type {org.apache.royale.textLayout.elements.IConfiguration}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype._textFlowConfiguration = null;


/**
 * @protected
 * @type {number}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype._importVersion = 0;


/**
 * @private
 * @const
 * @type {RegExp}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.anyPrintChar = /[^\u0009\u000a\u000d\u0020]/g;


/**
 * @export
 * @override
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.clear = function() {
  org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.superClass_.clear.apply(this);
  this.org_apache_royale_textLayout_conversion_BaseTextLayoutImporter__textFlowNamespace = null;
  this.org_apache_royale_textLayout_conversion_BaseTextLayoutImporter__impliedPara = null;
};


/** @copy ITextImporter#importToFlow()
 * @export
 * @param {Object} source
 * @return {org.apache.royale.textLayout.elements.ITextFlow}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.importToFlow = function(source) {
  this.clear();
  if (this.throwOnError)
    return this.org_apache_royale_textLayout_conversion_BaseTextLayoutImporter_importToFlowCanThrow(source);
  var /** @type {org.apache.royale.textLayout.elements.TextFlow} */ rslt = null;
  var /** @type {Function} */ savedErrorHandler = org.apache.royale.textLayout.property.PropertyUtil.errorHandler;
  try {
    org.apache.royale.textLayout.property.PropertyUtil.errorHandler = org.apache.royale.utils.Language.closure(this.importPropertyErrorHandler, this, 'importPropertyErrorHandler');
    rslt = this.org_apache_royale_textLayout_conversion_BaseTextLayoutImporter_importToFlowCanThrow(source);
  } catch (e) {
    this.reportError(e.toString());
  }
  org.apache.royale.textLayout.property.PropertyUtil.errorHandler = savedErrorHandler;
  return rslt;
};


/** @asprivate 
 * @protected
 * @param {org.apache.royale.textLayout.property.Property} p
 * @param {Object} value
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.importPropertyErrorHandler = function(p, value) {
  this.reportError(org.apache.royale.textLayout.property.PropertyUtil.createErrorString(p, value));
};


/**
 * @private
 * @param {Object} source
 * @return {org.apache.royale.textLayout.elements.TextFlow}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.org_apache_royale_textLayout_conversion_BaseTextLayoutImporter_importToFlowCanThrow = function(source) {
  if (org.apache.royale.utils.Language.is(source, String))
    return this.importFromString(String(source));
  else if (org.apache.royale.utils.Language.is(source, XML))
    return this.importFromXML(XML.conversion(source));
  return null;
};


/** Parse and convert input data.
 * 
 * @asparam source - a string which is in XFL format. String is applied to an XML object then passed
 * to importFromXML to be processed.  The source must be capable of being cast as an XML
 * object (E4X). 
 * @protected
 * @param {string} source
 * @return {org.apache.royale.textLayout.elements.TextFlow}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.importFromString = function(source) {
  var /** @type {Object} */ originalSettings = XML.settings();
  try {
    XML.ignoreProcessingInstructions = false;
    XML.ignoreWhitespace = false;
    var /** @type {XML} */ xmlTree = new XML(source);
  } finally {
    XML.setSettings(originalSettings);
  }
  var /** @type {org.apache.royale.textLayout.elements.TextFlow} */ textFlow = this.importFromXML(xmlTree);
  return textFlow;
};


/** Parse and convert input data.
 * 
 * xflSource is a XFL formated object which must be capable of being cast as an XML
 * object (E4X). 
 * @protected
 * @param {XML} xmlSource
 * @return {org.apache.royale.textLayout.elements.TextFlow}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.importFromXML = function(xmlSource) {
  return this.parseContent(xmlSource[0]);
};


/**
 * @protected
 * @param {XML} rootStory
 * @return {org.apache.royale.textLayout.elements.TextFlow}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.parseContent = function(rootStory) {
  var /** @type {XML} */ child = rootStory.descendants(new QName(null,'TextFlow'))[0];
  if (child)
    return org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.parseTextFlow(this, rootStory);
  return null;
};


/**
 * @private
 * @const
 * @type {RegExp}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.dblSpacePattern = /[\u0020]{2,}/g;


/**
 * @private
 * @const
 * @type {RegExp}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.tabNewLinePattern = /[\u0009\u000a\u000d]/g;


/**
 * @protected
 * @param {string} insertString
 * @return {string}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.stripWhitespace = function(insertString) {
  return insertString.replace(org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.tabNewLinePattern, " ");
};


/** Parse XML and convert to  TextFlow. 
 * @asparam importer		parser object
 * @asparam xmlToParse	content to parse
 * @asparam parent always null - this parameter is only provided to match FlowElementInfo.importer signature
 * @asreturn TextFlow	the new TextFlow created as a result of the parse
 * @export
 * @param {org.apache.royale.textLayout.conversion.BaseTextLayoutImporter} importer
 * @param {XML} xmlToParse
 * @param {Object=} parent
 * @return {org.apache.royale.textLayout.elements.TextFlow}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.parseTextFlow = function(importer, xmlToParse, parent) {
  parent = typeof parent !== 'undefined' ? parent : null;
  return importer.createTextFlowFromXML(xmlToParse, null);
};


/** 
 * Static method to parse the supplied XML into a paragrph. 
 * Parse the <p ...> tag and it's children.
 * 
 * @asparam importer	parser object
 * @asparam xmlToParse	content to parse
 * @asparam parent 		the parent for the new content
 * @export
 * @param {org.apache.royale.textLayout.conversion.BaseTextLayoutImporter} importer
 * @param {XML} xmlToParse
 * @param {org.apache.royale.textLayout.elements.FlowGroupElement} parent
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.parsePara = function(importer, xmlToParse, parent) {
  var /** @type {org.apache.royale.textLayout.elements.IParagraphElement} */ paraElem = importer.createParagraphFromXML(xmlToParse);
  if (importer.addChild(parent, paraElem)) {
    importer.parseFlowGroupElementChildren(xmlToParse, paraElem);
    if (paraElem.numChildren == 0)
      paraElem.addChild(new org.apache.royale.textLayout.elements.SpanElement());
  }
};


/**
 * @protected
 * @param {org.apache.royale.textLayout.elements.IFlowLeafElement} dst
 * @param {org.apache.royale.textLayout.elements.IFlowLeafElement} src
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.copyAllStyleProps = function(dst, src) {
  dst.format = src.format;
  dst.typeName = src.typeName;
  dst.id = src.id;
};


/** 
 * Static method for constructing a span from XML. Parse the <span> ... </span> tag. 
 * Insert the span into its parent
 * 
 * @asparam importer	parser object
 * @asparam xmlToParse	content to parse
 * @asparam parent 		the parent for the new content
 * @export
 * @param {org.apache.royale.textLayout.conversion.BaseTextLayoutImporter} importer
 * @param {XML} xmlToParse
 * @param {org.apache.royale.textLayout.elements.IFlowGroupElement} parent
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.parseSpan = function(importer, xmlToParse, parent) {
  var /** @type {org.apache.royale.textLayout.elements.ISpanElement} */ firstSpan = importer.createSpanFromXML(xmlToParse);
  var /** @type {XMLList} */ elemList = xmlToParse[0].children();
  if (elemList.length() == 0) {
    importer.addChild(parent, firstSpan);
    return;
  }
  var foreachiter0_target = elemList;
  for (var foreachiter0 in foreachiter0_target.elementNames()) 
  {
  var child = foreachiter0_target[foreachiter0];
  {
    var /** @type {string} */ elemName = org.apache.royale.utils.Language.string(child.name() ? child.name().localName : null);
    if (elemName == null) {
      if (firstSpan.parent == null) {
        firstSpan.text = child.toString();
        importer.addChild(parent, firstSpan);
      } else {
        var /** @type {org.apache.royale.textLayout.elements.SpanElement} */ s = new org.apache.royale.textLayout.elements.SpanElement();
        org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.copyAllStyleProps(s, firstSpan);
        s.text = child.toString();
        importer.addChild(parent, s);
      }
    } else if (elemName == "br") {
      var /** @type {org.apache.royale.textLayout.elements.BreakElement} */ brElem = importer.createBreakFromXML(child);
      if (brElem) {
        org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.copyAllStyleProps(brElem, firstSpan);
        importer.addChild(parent, brElem);
      }
      else
        importer.reportError(org.apache.royale.utils.Language.string(org.apache.royale.textLayout.elements.GlobalSettings["resourceStringFunction"]("unexpectedXMLElementInSpan", [elemName])));
    } else if (elemName == "tab") {
      var /** @type {org.apache.royale.textLayout.elements.TabElement} */ tabElem = importer.createTabFromXML(child);
      if (tabElem) {
        org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.copyAllStyleProps(tabElem, firstSpan);
        importer.addChild(parent, tabElem);
      }
      else
        importer.reportError(org.apache.royale.utils.Language.string(org.apache.royale.textLayout.elements.GlobalSettings["resourceStringFunction"]("unexpectedXMLElementInSpan", [elemName])));
    }
    else
      importer.reportError(org.apache.royale.utils.Language.string(org.apache.royale.textLayout.elements.GlobalSettings["resourceStringFunction"]("unexpectedXMLElementInSpan", [elemName])));
  }}
  
};


/** 
 * Static method for constructing a break element from XML. Validate the <br> ... </br> tag. 
 * Use "\u2028" as the text; Insert the new element into its parent 
 * 
 * @asparam importer	parser object
 * @asparam xmlToParse	content to parse
 * @asparam parent 		the parent for the new content
 * @export
 * @param {org.apache.royale.textLayout.conversion.BaseTextLayoutImporter} importer
 * @param {XML} xmlToParse
 * @param {org.apache.royale.textLayout.elements.IFlowGroupElement} parent
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.parseBreak = function(importer, xmlToParse, parent) {
  var /** @type {org.apache.royale.textLayout.elements.BreakElement} */ breakElem = importer.createBreakFromXML(xmlToParse);
  importer.addChild(parent, breakElem);
};


/** 
 * Static method for constructing a tab element from XML. Validate the <tab> ... </tab> tag. 
 * Use "\t" as the text; Insert the new element into its parent 
 * 
 * @asparam importer	parser object
 * @asparam xmlToParse	content to parse
 * @asparam parent 		the parent for the new content
 * @export
 * @param {org.apache.royale.textLayout.conversion.BaseTextLayoutImporter} importer
 * @param {XML} xmlToParse
 * @param {org.apache.royale.textLayout.elements.IFlowGroupElement} parent
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.parseTab = function(importer, xmlToParse, parent) {
  var /** @type {org.apache.royale.textLayout.elements.TabElement} */ tabElem = importer.createTabFromXML(xmlToParse);
  if (tabElem)
    importer.addChild(parent, tabElem);
};


/** 
 * Static method for constructing a list element from XML. 
 * 
 * @asparam importer	parser object
 * @asparam xmlToParse	content to parse
 * @asparam parent 		the parent for the new content
 * @export
 * @param {org.apache.royale.textLayout.conversion.BaseTextLayoutImporter} importer
 * @param {XML} xmlToParse
 * @param {org.apache.royale.textLayout.elements.IFlowGroupElement} parent
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.parseList = function(importer, xmlToParse, parent) {
  var /** @type {org.apache.royale.textLayout.elements.IListElement} */ listElem = importer.createListFromXML(xmlToParse);
  if (importer.addChild(parent, listElem)) {
    importer.parseFlowGroupElementChildren(xmlToParse, listElem);
  }
};


/** 
 * Static method for constructing a list item from XML. 
 * 
 * @asparam importer	parser object
 * @asparam xmlToParse	content to parse
 * @asparam parent 		the parent for the new content
 * @export
 * @param {org.apache.royale.textLayout.conversion.BaseTextLayoutImporter} importer
 * @param {XML} xmlToParse
 * @param {org.apache.royale.textLayout.elements.IFlowGroupElement} parent
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.parseListItem = function(importer, xmlToParse, parent) {
  var /** @type {org.apache.royale.textLayout.elements.IListItemElement} */ listItem = importer.createListItemFromXML(xmlToParse);
  if (importer.addChild(parent, listItem)) {
    importer.parseFlowGroupElementChildren(xmlToParse, listItem);
    if (listItem.numChildren == 0)
      listItem.addChild(org.apache.royale.textLayout.elements.ElementHelper.getParagraph());
  }
};


/**
 * @protected
 * @param {XML} xmlToParse
 * @return {boolean}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.checkNamespace = function(xmlToParse) {
  var /** @type {Namespace} */ elementNS = xmlToParse.namespace();
  if (!this.org_apache_royale_textLayout_conversion_BaseTextLayoutImporter__textFlowNamespace) {
    if (elementNS != this.ns) {
      this.reportError(org.apache.royale.utils.Language.string(org.apache.royale.textLayout.elements.GlobalSettings["resourceStringFunction"]("unexpectedNamespace", [elementNS.toString()])));
      return false;
    }
    this.org_apache_royale_textLayout_conversion_BaseTextLayoutImporter__textFlowNamespace = elementNS;
  } else if (elementNS != this.org_apache_royale_textLayout_conversion_BaseTextLayoutImporter__textFlowNamespace) {
    this.reportError(org.apache.royale.utils.Language.string(org.apache.royale.textLayout.elements.GlobalSettings["resourceStringFunction"]("unexpectedNamespace", [elementNS.toString()])));
    return false;
  }
  return true;
};


/**
 * @export
 * @param {XML} xmlToParse
 * @param {Array} formatImporters
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.parseAttributes = function(xmlToParse, formatImporters) {
  var /** @type {org.apache.royale.textLayout.conversion.IFormatImporter} */ importer;
  var foreachiter1_target = formatImporters;
  for (var foreachiter1 in foreachiter1_target) 
  {
  importer = foreachiter1_target[foreachiter1];
  
    importer.reset();}
  
  if (!xmlToParse)
    return;
  var foreachiter2_target = xmlToParse.attributes();
  for (var foreachiter2 in foreachiter2_target.elementNames()) 
  {
  var item = foreachiter2_target[foreachiter2];
  {
    var /** @type {string} */ propertyName = item.name().localName;
    var /** @type {string} */ propertyValue = item.toString();
    var /** @type {boolean} */ imported = false;
    if (xmlToParse.localName() == "TextFlow") {
      if (propertyName == "version")
        continue;
    }
    else if (this._importVersion < org.apache.royale.textLayout.TextLayoutVersion.VERSION_2_0 && (propertyName == "paddingLeft" || propertyName == "paddingTop" || propertyName == "paddingRight" || propertyName == "paddingBottom"))
      continue;
    var foreachiter3_target = formatImporters;
    for (var foreachiter3 in foreachiter3_target) 
    {
    importer = foreachiter3_target[foreachiter3];
    {
      if (importer.importOneFormat(propertyName, propertyValue)) {
        imported = true;
        break;
      }
    }}
    
    if (!imported)
      this.handleUnknownAttribute(xmlToParse.name().localName, propertyName);
  }}
  
};


/**
 * @protected
 * @param {Object} curAttrs
 * @param {org.apache.royale.textLayout.conversion.TLFormatImporter} importer
 * @return {Object}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.extractAttributesHelper = function(curAttrs, importer) {
  if (curAttrs == null)
    return importer.result;
  if (importer.result == null)
    return curAttrs;
  var /** @type {Object} */ workAttrs = new importer.classType(curAttrs);
  workAttrs.apply(importer.result);
  return workAttrs;
};


/** 
 * Parse XML and convert to  TextFlow.
 * 
 * @asparam xmlToParse	content to parse
 * @asparam textFlow 		TextFlow we're parsing. If null, create or find a new TextFlow based on XML content
 * @asreturn TextFlow	the new TextFlow created as a result of the parse
 * @export
 * @param {XML} xmlToParse
 * @param {org.apache.royale.textLayout.elements.TextFlow=} newFlow
 * @return {org.apache.royale.textLayout.elements.TextFlow}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.createTextFlowFromXML = function(xmlToParse, newFlow) {
  newFlow = typeof newFlow !== 'undefined' ? newFlow : null;
  
  return null;
};


/**
 * @export
 * @param {XML} xmlToParse
 * @return {org.apache.royale.textLayout.elements.IParagraphElement}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.createParagraphFromXML = function(xmlToParse) {
  
  return null;
};


/**
 * @export
 * @param {XML} xmlToParse
 * @return {org.apache.royale.textLayout.elements.ISpanElement}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.createSpanFromXML = function(xmlToParse) {
  
  return null;
};


/**
 * @export
 * @param {XML} xmlToParse
 * @return {org.apache.royale.textLayout.elements.BreakElement}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.createBreakFromXML = function(xmlToParse) {
  this.parseAttributes(xmlToParse, null);
  return new org.apache.royale.textLayout.elements.BreakElement();
};


/**
 * @export
 * @param {XML} xmlToParse
 * @return {org.apache.royale.textLayout.elements.IListElement}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.createListFromXML = function(xmlToParse) {
  
  return null;
};


/**
 * @export
 * @param {XML} xmlToParse
 * @return {org.apache.royale.textLayout.elements.IListItemElement}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.createListItemFromXML = function(xmlToParse) {
  
  return null;
};


/**
 * @export
 * @param {XML} xmlToParse
 * @return {org.apache.royale.textLayout.elements.TabElement}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.createTabFromXML = function(xmlToParse) {
  this.parseAttributes(xmlToParse, null);
  return new org.apache.royale.textLayout.elements.TabElement();
};


/** 
 * Parse XML, convert to FlowElements and add to the parent.
 * 
 * @asparam xmlToParse	content to parse
 * @asparam parent 		the parent for the new content
 * @export
 * @param {XML} xmlToParse
 * @param {org.apache.royale.textLayout.elements.FlowGroupElement} parent
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.parseFlowChildren = function(xmlToParse, parent) {
  this.parseFlowGroupElementChildren(xmlToParse, parent);
};


/** 
 * Parse XML, convert to FlowElements and add to the parent.
 * 
 * @asparam xmlToParse	content to parse
 * @asparam parent 		the parent for the new content
 * @asparam chainedParent whether parent actually corresponds to xmlToParse or has been chained (such as when xmlToParse is a formatting element) 
 * @export
 * @param {XML} xmlToParse
 * @param {org.apache.royale.textLayout.elements.IFlowGroupElement} parent
 * @param {Object=} exceptionElements
 * @param {boolean=} chainedParent
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.parseFlowGroupElementChildren = function(xmlToParse, parent, exceptionElements, chainedParent) {
  exceptionElements = typeof exceptionElements !== 'undefined' ? exceptionElements : null;
  chainedParent = typeof chainedParent !== 'undefined' ? chainedParent : false;
  var foreachiter4_target = xmlToParse.children();
  for (var foreachiter4 in foreachiter4_target.elementNames()) 
  {
  var child = foreachiter4_target[foreachiter4];
  {
    if (child.nodeKind() == "element") {
      this.parseObject(child.name().localName, child, parent, exceptionElements);
    } else if (child.nodeKind() == "text") {
      var /** @type {string} */ txt = child.toString();
      var /** @type {boolean} */ strip = false;
      if (org.apache.royale.utils.Language.is(parent, org.apache.royale.textLayout.elements.IContainerFormattedElement)) {
        strip = txt.search(org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.anyPrintChar) == -1;
      }
      if (!strip)
        this.addChild(parent, this.createImpliedSpan(txt));
    }
  }}
  
  if (!chainedParent && org.apache.royale.utils.Language.is(parent, org.apache.royale.textLayout.elements.IContainerFormattedElement))
    this.resetImpliedPara();
};


/** 
 * Parse XML, convert XML to FlowElements and TextFlow and add to the parent table cell
 * 
 * @asparam xmlToParse	content to parse
 * @asparam parent 		the parent for the new content
 * @asparam chainedParent whether parent actually corresponds to xmlToParse or has been chained (such as when xmlToParse is a formatting element) 
 * @export
 * @param {XML} xmlToParse
 * @param {org.apache.royale.textLayout.elements.IFlowGroupElement} parent
 * @param {Object=} exceptionElements
 * @param {boolean=} chainedParent
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.parseTableCellElementChildren = function(xmlToParse, parent, exceptionElements, chainedParent) {
  exceptionElements = typeof exceptionElements !== 'undefined' ? exceptionElements : null;
  chainedParent = typeof chainedParent !== 'undefined' ? chainedParent : false;
  var /** @type {org.apache.royale.textLayout.elements.TextFlow} */ textFlow;
  var foreachiter5_target = xmlToParse.children();
  for (var foreachiter5 in foreachiter5_target.elementNames()) 
  {
  var child = foreachiter5_target[foreachiter5];
  {
    if (child.nodeKind() == "element") {
      if (child.name().localName == "p") {
        textFlow = new org.apache.royale.textLayout.elements.TextFlow(org.apache.royale.textLayout.factory.TLFFactory["defaultTLFFactory"]);
        this.parseObject(child.name().localName, child, textFlow, exceptionElements);
      } else if (child.name().localName == "TextFlow") {
        org.apache.royale.utils.Language.as(parent, org.apache.royale.textLayout.elements.TableCellElement, true).textFlow = this.createTextFlowFromXML(child);
      }
    } else if (child.nodeKind() == "text") {
      var /** @type {string} */ txt = child.toString();
      var /** @type {boolean} */ strip = false;
      if (org.apache.royale.utils.Language.is(parent, org.apache.royale.textLayout.elements.IContainerFormattedElement)) {
        strip = txt.search(org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.anyPrintChar) == -1;
      }
      if (!strip) {
        textFlow = new org.apache.royale.textLayout.elements.TextFlow(org.apache.royale.textLayout.factory.TLFFactory["defaultTLFFactory"]);
        this.parseObject(child.name().localName, child, textFlow, exceptionElements);
      }
    }
    if (textFlow) {
      org.apache.royale.utils.Language.as(parent, org.apache.royale.textLayout.elements.TableCellElement, true).textFlow = textFlow;
      textFlow = null;
    }
  }}
  
};


/** create an implied span with specified text 
 * @export
 * @param {string} text
 * @return {org.apache.royale.textLayout.elements.SpanElement}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.createImpliedSpan = function(text) {
  var /** @type {org.apache.royale.textLayout.elements.SpanElement} */ span = new org.apache.royale.textLayout.elements.SpanElement();
  span.text = text;
  return span;
};


/**
 * @export
 * @param {XML} xmlToParse
 * @param {org.apache.royale.textLayout.elements.TextFlow=} newFlow
 * @return {org.apache.royale.textLayout.elements.TextFlow}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.createParagraphFlowFromXML = function(xmlToParse, newFlow) {
  newFlow = typeof newFlow !== 'undefined' ? newFlow : null;
  
  return null;
};


/**
 * @export
 * @param {string} name
 * @param {XML} xmlToParse
 * @param {org.apache.royale.textLayout.elements.IFlowGroupElement} parent
 * @param {Object=} exceptionElements
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.parseObject = function(name, xmlToParse, parent, exceptionElements) {
  exceptionElements = typeof exceptionElements !== 'undefined' ? exceptionElements : null;
  if (!this.checkNamespace(xmlToParse))
    return;
  var /** @type {org.apache.royale.textLayout.conversion.FlowElementInfo} */ info = this._config.lookup(name);
  if (!info) {
    if (exceptionElements == null || exceptionElements[name] === undefined)
      this.handleUnknownElement(name, xmlToParse, parent);
  }
  else
    info.parser(this, xmlToParse, parent);
};


/**
 * @protected
 * @param {string} name
 * @param {XML} xmlToParse
 * @param {org.apache.royale.textLayout.elements.IFlowGroupElement} parent
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.handleUnknownElement = function(name, xmlToParse, parent) {
  this.reportError(org.apache.royale.utils.Language.string(org.apache.royale.textLayout.elements.GlobalSettings["resourceStringFunction"]("unknownElement", [name])));
};


/**
 * @protected
 * @param {string} elementName
 * @param {string} propertyName
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.handleUnknownAttribute = function(elementName, propertyName) {
  this.reportError(org.apache.royale.utils.Language.string(org.apache.royale.textLayout.elements.GlobalSettings["resourceStringFunction"]("unknownAttribute", [propertyName, elementName])));
};


/**
 * @protected
 * @param {XML} xmlToParse
 * @return {org.apache.royale.textLayout.conversion.FlowElementInfo}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.getElementInfo = function(xmlToParse) {
  return this._config.lookup(xmlToParse.name().localName);
};


/**
 * @protected
 * @param {XML} xmlToParse
 * @return {Object}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.GetClass = function(xmlToParse) {
  var /** @type {org.apache.royale.textLayout.conversion.FlowElementInfo} */ info = this._config.lookup(xmlToParse.name().localName);
  return info ? info.flowClass : null;
};


/**
 * @private
 * @type {org.apache.royale.textLayout.elements.IParagraphElement}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.org_apache_royale_textLayout_conversion_BaseTextLayoutImporter__impliedPara = null;


/** @asprivate 
 * @export
 * @return {org.apache.royale.textLayout.elements.IParagraphElement}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.createImpliedParagraph = function() {
  return this.createParagraphFromXML(new XML( '<p/>'));
};


/**
 * @asprivate
 * Helper function for adding a child flow element that honors throwOnError setting and uses the parent override
 * NOTE: You MUST NOT call addChild directly unless you are sure
 * - There is not possibility of an implied paragraph, and
 * - Parent is of type that can contain child
 * @export
 * @param {org.apache.royale.textLayout.elements.IFlowGroupElement} parent
 * @param {org.apache.royale.textLayout.elements.IFlowElement} child
 * @return {boolean}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.addChild = function(parent, child) {
  if (org.apache.royale.utils.Language.is(child, org.apache.royale.textLayout.elements.IParagraphFormattedElement)) {
    this.resetImpliedPara();
  } else if (org.apache.royale.utils.Language.is(parent, org.apache.royale.textLayout.elements.IContainerFormattedElement)) {
    if (!this.org_apache_royale_textLayout_conversion_BaseTextLayoutImporter__impliedPara) {
      this.org_apache_royale_textLayout_conversion_BaseTextLayoutImporter__impliedPara = this.createImpliedParagraph();
      parent.addChild(this.org_apache_royale_textLayout_conversion_BaseTextLayoutImporter__impliedPara);
    }
    parent = this.org_apache_royale_textLayout_conversion_BaseTextLayoutImporter__impliedPara;
  }
  if (this.throwOnError)
    parent.addChild(child); else {
    try {
      parent.addChild(child);
    } catch (e) {
      this.reportError(org.apache.royale.utils.Language.string(e));
      return false;
    }
  }
  return true;
};


/**
 * @export
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.resetImpliedPara = function() {
  if (this.org_apache_royale_textLayout_conversion_BaseTextLayoutImporter__impliedPara) {
    this.onResetImpliedPara(this.org_apache_royale_textLayout_conversion_BaseTextLayoutImporter__impliedPara);
    this.org_apache_royale_textLayout_conversion_BaseTextLayoutImporter__impliedPara = null;
  }
};


/**
 * @protected
 * @param {org.apache.royale.textLayout.elements.IParagraphElement} para
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.onResetImpliedPara = function(para) {
};


org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.get__configuration = function() {
  return this._textFlowConfiguration;
};


org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.set__configuration = function(value) {
  this._textFlowConfiguration = value;
};


org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.get__ns = function() {
  return this.org_apache_royale_textLayout_conversion_BaseTextLayoutImporter__ns;
};


Object.defineProperties(org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype, /** @lends {org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype} */ {
/**
  * @export
  * @type {org.apache.royale.textLayout.elements.IConfiguration} */
configuration: {
get: org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.get__configuration,
set: org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.set__configuration},
/**
  * @export
  * @type {Namespace} */
ns: {
get: org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.get__ns}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'BaseTextLayoutImporter', qName: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', kind: 'class' }], interfaces: [org.apache.royale.textLayout.conversion.ITextImporter] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    accessors: function () {
      return {
        'configuration': { type: 'org.apache.royale.textLayout.elements.IConfiguration', access: 'readwrite', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter'},
        'ns': { type: 'Namespace', access: 'readonly', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter'}
      };
    },
    methods: function () {
      return {
        'BaseTextLayoutImporter': { type: '', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'Namespace', false ,'org.apache.royale.textLayout.conversion.ImportExportConfiguration', false ]; }},
        'clear': { type: 'void', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter'},
        'importToFlow': { type: 'org.apache.royale.textLayout.elements.ITextFlow', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'Object', false ]; }},
        '|parseTextFlow': { type: 'org.apache.royale.textLayout.elements.TextFlow', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', false ,'XML', false ,'Object', true ]; }},
        '|parsePara': { type: 'void', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', false ,'XML', false ,'org.apache.royale.textLayout.elements.FlowGroupElement', false ]; }},
        '|parseSpan': { type: 'void', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', false ,'XML', false ,'org.apache.royale.textLayout.elements.IFlowGroupElement', false ]; }},
        '|parseBreak': { type: 'void', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', false ,'XML', false ,'org.apache.royale.textLayout.elements.IFlowGroupElement', false ]; }},
        '|parseTab': { type: 'void', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', false ,'XML', false ,'org.apache.royale.textLayout.elements.IFlowGroupElement', false ]; }},
        '|parseList': { type: 'void', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', false ,'XML', false ,'org.apache.royale.textLayout.elements.IFlowGroupElement', false ]; }},
        '|parseListItem': { type: 'void', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', false ,'XML', false ,'org.apache.royale.textLayout.elements.IFlowGroupElement', false ]; }},
        'parseAttributes': { type: 'void', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'XML', false ,'Array', false ]; }},
        'createTextFlowFromXML': { type: 'org.apache.royale.textLayout.elements.TextFlow', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'XML', false ,'org.apache.royale.textLayout.elements.TextFlow', true ]; }},
        'createParagraphFromXML': { type: 'org.apache.royale.textLayout.elements.IParagraphElement', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'XML', false ]; }},
        'createSpanFromXML': { type: 'org.apache.royale.textLayout.elements.ISpanElement', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'XML', false ]; }},
        'createBreakFromXML': { type: 'org.apache.royale.textLayout.elements.BreakElement', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'XML', false ]; }},
        'createListFromXML': { type: 'org.apache.royale.textLayout.elements.IListElement', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'XML', false ]; }},
        'createListItemFromXML': { type: 'org.apache.royale.textLayout.elements.IListItemElement', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'XML', false ]; }},
        'createTabFromXML': { type: 'org.apache.royale.textLayout.elements.TabElement', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'XML', false ]; }},
        'parseFlowChildren': { type: 'void', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'XML', false ,'org.apache.royale.textLayout.elements.FlowGroupElement', false ]; }},
        'parseFlowGroupElementChildren': { type: 'void', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'XML', false ,'org.apache.royale.textLayout.elements.IFlowGroupElement', false ,'Object', true ,'Boolean', true ]; }},
        'parseTableCellElementChildren': { type: 'void', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'XML', false ,'org.apache.royale.textLayout.elements.IFlowGroupElement', false ,'Object', true ,'Boolean', true ]; }},
        'createImpliedSpan': { type: 'org.apache.royale.textLayout.elements.SpanElement', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'String', false ]; }},
        'createParagraphFlowFromXML': { type: 'org.apache.royale.textLayout.elements.TextFlow', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'XML', false ,'org.apache.royale.textLayout.elements.TextFlow', true ]; }},
        'parseObject': { type: 'void', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'String', false ,'XML', false ,'org.apache.royale.textLayout.elements.IFlowGroupElement', false ,'Object', true ]; }},
        'createImpliedParagraph': { type: 'org.apache.royale.textLayout.elements.IParagraphElement', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter'},
        'addChild': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter', parameters: function () { return [ 'org.apache.royale.textLayout.elements.IFlowGroupElement', false ,'org.apache.royale.textLayout.elements.IFlowElement', false ]; }},
        'resetImpliedPara': { type: 'void', declaredBy: 'org.apache.royale.textLayout.conversion.BaseTextLayoutImporter'}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
org.apache.royale.textLayout.conversion.BaseTextLayoutImporter.prototype.ROYALE_COMPILE_FLAGS = 10;
